'use strict';

var require$$0$1 = require('buffer');
var bn_js = require('bn.js');
var crypto = require('crypto');
var secp256k1 = require('secp256k1');
var cloneDeep = require('lodash/cloneDeep');
var events = require('events');
var zod = require('zod');

function _interopNamespaceDefault(e) {
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n.default = e;
	return Object.freeze(n);
}

var crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);
var secp256k1__namespace = /*#__PURE__*/_interopNamespaceDefault(secp256k1);

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

// eslint-disable-next-line @typescript-eslint/no-var-requires
const asn = require("@chromia/asn1/lib/asn1");
const ASNDictPair = asn.define("DictPair", function () {
    this.seq().obj(this.key("name").utf8str(), this.key("value").use(rawGTV));
});
const rawGTV = asn.define("GtvValue", function () {
    this.choice({
        null: this.explicit(0).null_(),
        byteArray: this.explicit(1).octstr(),
        string: this.explicit(2).utf8str(),
        integer: this.explicit(3).int(),
        dict: this.explicit(4).seqof(ASNDictPair),
        array: this.explicit(5).seqof(rawGTV),
        bigInteger: this.explicit(6).int(),
    });
});
asn.define("Buffer", function () {
    this.octstr();
});

class CustomError extends Error {
    constructor(message, status) {
        super(message);
        this.name = this.constructor.name;
        this.status = status;
    }
}

class UnexpectedArgumentTypeError extends CustomError {
    constructor(typedArg) {
        super(`Cannot parse typedArg ${JSON.stringify(typedArg)}. Unknown type ${typedArg.type}`, 400);
    }
}
class MissingGtxException extends CustomError {
    constructor() {
        super(`Missing instance of gtx protocol (used for communicating with postchain) to add operation to`, 400);
    }
}
class AlreadySignedTransactionException extends CustomError {
    constructor(operation) {
        super(`Cannot add ${operation} calls to an already signed gtx`, 400);
    }
}
class NumberOfSignersAndSignaturesException extends CustomError {
    constructor() {
        super(`Not matching number of signers and signatures`, 400);
    }
}
class MissingSignerException extends CustomError {
    constructor() {
        super(`No such signer, remember to add signer to transaction before adding a signature`, 400);
    }
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function pgBytes(buffer) {
    if (!require$$0$1.Buffer.isBuffer(buffer)) {
        throw new PgBytesInputException(buffer);
    }
    return `\\x${buffer.toString("hex")}`;
}
/**
 * Converts hex string to Buffer
 * @param key: string
 * @returns {Buffer}
 */
function toBuffer(key) {
    return require$$0$1.Buffer.from(key, "hex");
}
/**
 * Converts Buffer to hex string
 * @param buffer: Buffer
 * @returns {string}
 */
function toString(buffer) {
    return buffer.toString("hex").toUpperCase();
}
function toQueryObjectGTV(nameOrObject, queryArguments) {
    let name;
    if (typeof nameOrObject === "string") {
        name = nameOrObject;
        return [name, Object.assign({}, queryArguments)];
    }
    else {
        const objectCopy = Object.assign({}, nameOrObject);
        const { type } = objectCopy, restProps = __rest(objectCopy, ["type"]);
        return [type, restProps];
    }
}
class PgBytesInputException extends Error {
    constructor(buffer) {
        super(`util.pgBytes expects a buffer, but got ${typeof buffer}`);
    }
}
function ensureBuffer(value) {
    if (value instanceof require$$0$1.Buffer) {
        return value;
    }
    else {
        return toBuffer(value);
    }
}
function checkGtvType(value) {
    try {
        if (value == null) {
            return true;
        }
        if (require$$0$1.Buffer.isBuffer(value)) {
            return true;
        }
        if (typeof value === "string") {
            return true;
        }
        if (typeof value === "number") {
            if (!Number.isInteger(value)) {
                throw Error("User error: Only integers are supported");
            }
            return true;
        }
        if (typeof value === "bigint") {
            return true;
        }
        if (value.constructor === Array) {
            value.map((item) => checkGtvType(item));
            return true;
        }
        if (typeof value === "object") {
            Object.keys(value).map(function (key) {
                checkGtvType(value[key]);
            });
            return true;
        }
    }
    catch (error) {
        throw new Error(`Failed to check type: ${error}`);
    }
    return false;
}
function rawGtxToGtx(rawGtx) {
    const rawGtxBody = rawGtx[0];
    const signatures = rawGtx[1];
    const gtxBody = {
        blockchainRid: rawGtxBody[0],
        operations: rawGtxBody[1].map((operation) => ({
            opName: operation[0],
            args: operation[1],
        })),
        signers: rawGtxBody[2],
    };
    return {
        blockchainRid: gtxBody.blockchainRid,
        operations: gtxBody.operations,
        signers: gtxBody.signers,
        signatures,
    };
}
function rawGtxToRawGtxBody(rawGtx) {
    return rawGtx[0];
}
function checkGtxType(value) {
    try {
        rawGtxToGtx(value);
        return true;
    }
    catch (error) {
        return false;
    }
}
function removeDuplicateSigners(signers) {
    const signersAsString = [];
    signers.forEach((item) => {
        const itemAsString = item.toString("hex");
        if (!signersAsString.includes(itemAsString)) {
            signersAsString.push(itemAsString);
        }
    });
    const result = [];
    signersAsString.forEach((item) => {
        result.push(require$$0$1.Buffer.from(item, "hex"));
    });
    return result;
}
function matchRellErrorString(rellError) {
    const parsed = rellError.match(/\[([^\]]+)\]\sOperation\s'([^']+)'\sfailed:\s(.+)$/);
    if (!parsed)
        return {};
    const [rellLine, operation, shortReason] = parsed.slice(1);
    return { shortReason, rellLine, operation };
}

var formatter = /*#__PURE__*/Object.freeze({
	__proto__: null,
	PgBytesInputException: PgBytesInputException,
	checkGtvType: checkGtvType,
	checkGtxType: checkGtxType,
	ensureBuffer: ensureBuffer,
	matchRellErrorString: matchRellErrorString,
	pgBytes: pgBytes,
	rawGtxToGtx: rawGtxToGtx,
	rawGtxToRawGtxBody: rawGtxToRawGtxBody,
	removeDuplicateSigners: removeDuplicateSigners,
	toBuffer: toBuffer,
	toQueryObjectGTV: toQueryObjectGTV,
	toString: toString
});

function encodeValue(rawGtv) {
    return rawGTV.encode(createTypedArg(rawGtv));
}
function encodeValueGtx(rawGtx) {
    return encodeValue(rawGtx);
}
function decodeValue(bytes) {
    //TODO add a try catch to catch asn1 errors to be more readable error
    const obj = rawGTV.decode(bytes);
    return parseValue(obj);
}
function decodeValueGtx(bytes) {
    const decodedValue = decodeValue(bytes);
    if (!checkGtxType(decodedValue)) {
        throw new Error(`Unexpected type of value: ${decodedValue}, expected decoded value to be of type RawGtx`);
    }
    return decodedValue;
}
function parseValue(typedArg) {
    var _a, _b;
    if (typedArg.type === "null") {
        return null;
    }
    else if (typedArg.type === "byteArray") {
        return typedArg.value;
    }
    else if (typedArg.type === "string") {
        return typedArg.value;
    }
    else if (typedArg.type === "integer") {
        return Number(typedArg.value);
    }
    else if (typedArg.type === "array") {
        const arrayValue = typedArg.value;
        return arrayValue.map((item) => parseValue(item));
    }
    else if (typedArg.type === "bigInteger") {
        return BigInt((_b = (_a = typedArg.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "");
    }
    else if (typedArg.type === "dict") {
        const arrayValue = typedArg.value;
        const result = {};
        arrayValue.forEach((pair) => {
            result[pair.name] = parseValue(pair.value);
        });
        return result;
    }
    else {
        throw new UnexpectedArgumentTypeError(typedArg);
    }
}
function createTypedArg(value) {
    try {
        if (value == null) {
            return { type: "null", value: null };
        }
        if (require$$0$1.Buffer.isBuffer(value)) {
            return { type: "byteArray", value: value };
        }
        if (typeof value === "boolean") {
            return { type: "integer", value: value ? 1 : 0 };
        }
        if (typeof value === "string") {
            return { type: "string", value: value };
        }
        if (typeof value === "number") {
            if (!Number.isInteger(value)) {
                throw Error("User error: Only integers are supported");
            }
            return { type: "integer", value: new bn_js.BN(value) };
        }
        if (typeof value === "bigint") {
            return { type: "bigInteger", value: new bn_js.BN(value.toString()) };
        }
        if (value.constructor === Array) {
            return {
                type: "array",
                value: value.map((item) => createTypedArg(item)),
            };
        }
        if (typeof value === "object") {
            let valueAsDictPair = value;
            if (isDictPairWithStringKey(valueAsDictPair)) {
                valueAsDictPair = sortDictPairByKey(valueAsDictPair);
            }
            return {
                type: "dict",
                value: Object.keys(valueAsDictPair).map(function (key) {
                    return { name: key, value: createTypedArg(valueAsDictPair[key]) };
                }),
            };
        }
    }
    catch (error) {
        const message = value ? value.toString() : "RawGtv";
        throw new Error(`Failed to encode ${message}: ${error}`);
    }
    throw new Error(`value ${value} have unsupported type: ${typeof value}`);
}
function isDictPairWithStringKey(obj) {
    for (const key in obj) {
        if (typeof key !== "string") {
            return false;
        }
    }
    return true;
}
function sortDictPairByKey(dict) {
    const sortedArray = Object.entries(dict).sort(([keyA], [keyB]) => {
        if (keyA < keyB) {
            return -1;
        }
        if (keyA > keyB) {
            return 1;
        }
        return 0;
    });
    const sortedDict = {};
    for (const [key, value] of sortedArray) {
        sortedDict[key] = value;
    }
    return sortedDict;
}

var serialization$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createTypedArg: createTypedArg,
	decodeValue: decodeValue,
	decodeValueGtx: decodeValueGtx,
	encodeValue: encodeValue,
	encodeValueGtx: encodeValueGtx,
	parseValue: parseValue
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(serialization$1);

var require$$0 = /*@__PURE__*/getAugmentedNamespace(formatter);

var util$1 = require$$0;
function PathElement(previous) {
    this.previous = previous;
}
PathElement.prototype.getSearchKey = function () { };
function PathLeafElement$3(previous) {
    PathElement.call(this, previous);
}
PathLeafElement$3.prototype = Object.create(PathElement.prototype);
PathLeafElement$3.prototype.constructor = PathLeafElement$3;
PathLeafElement$3.prototype.equals = function (other) {
    if (this === other)
        return true;
    if (typeof this !== typeof other)
        return false;
    return true;
};
function SearchablePathElement(previous) {
    PathElement.call(this, previous);
}
SearchablePathElement.prototype = Object.create(PathElement.prototype);
SearchablePathElement.prototype.constructor = SearchablePathElement;
SearchablePathElement.prototype.getSearchKey = function () { };
/**
 *
 * @param {SearchablePathElement} previous
 * @param {number} index
 */
function ArrayPathElement(previous, index) {
    SearchablePathElement.call(this, previous);
    this.index = index;
}
ArrayPathElement.prototype = Object.create(SearchablePathElement.prototype);
ArrayPathElement.prototype.constructor = ArrayPathElement;
ArrayPathElement.prototype.getSearchKey = function () {
    return this.index;
};
/**
 * @param {ArrayPathElement} other
 */
ArrayPathElement.prototype.equals = function (other) {
    if (this === other)
        return true;
    if (typeof this !== typeof other)
        return false;
    if (this.index != other.index)
        return false;
    return true;
};
/**
 *
 * @param {SearchablePathElement} previous
 * @param {string} key
 */
function DictPathElement(previous, key) {
    SearchablePathElement.call(this, previous);
    this.key = key;
}
DictPathElement.prototype = Object.create(SearchablePathElement.prototype);
DictPathElement.prototype.constructor = DictPathElement;
DictPathElement.prototype.getSearchKey = function () {
    return this.key;
};
/**
 * @param {DictPathElement} other
 */
DictPathElement.prototype.equals = function (other) {
    if (this === other)
        return true;
    if (typeof this !== typeof other)
        return false;
    if (this.key != other.key)
        return false;
    return true;
};
/**
 *
 * @param {Array} pathElements
 */
function Path(pathElements) {
    this.pathElements = pathElements;
}
/**
 *
 */
Path.prototype.getCurrentPathElement = function () {
    return this.pathElements[0];
};
/**
 *
 */
Path.prototype.size = function () {
    return this.pathElements.length;
};
/**
 *
 */
Path.prototype.tail = function () {
    if (this.pathElements.length == 0) {
        throw new Error("Impossible to tail this array");
    }
    else {
        var tail = this.pathElements.slice(1);
        return new Path(tail);
    }
};
Path.prototype.debugString = function () {
    var sb = "";
    this.pathElements.forEach(elem => {
        if (elem instanceof SearchablePathElement) {
            sb = sb + "-> " + elem.getSearchKey();
        }
        else if (elem instanceof PathLeafElement$3) {
            sb = sb + "-> Leaf";
        }
    });
    return sb;
};
/**
 * @param {Path} other
 */
Path.prototype.equals = function (other) {
    if (this === other)
        return true;
    if (typeof this != typeof other)
        return false;
    return this.pathElements == other.pathElements;
};
/**
 * @param {number} index
 * @param {Path} path
 */
var getTailIfFirstElementIsArrayOfThisIndex = function (index, path) {
    return getTail(index, path);
};
/**
 *
 * @param {string} key
 * @param {Path} path
 */
var getTailIfFirstElementIsDictOfThisKey = function (key, path) {
    return getTail(key, path);
};
/**
 *
 * @param {string|number} searchKey
 * @param {Path} path
 */
var getTail = function (searchKey, path) {
    if (searchKey === null) {
        throw new Error("Have to provide a search key");
    }
    try {
        var firstElement = path.pathElements[0];
        if (firstElement instanceof SearchablePathElement) {
            if (firstElement.getSearchKey() == searchKey) {
                return path.tail();
            }
        }
    }
    catch (err) {
        util$1.logError("Why are we dropping first element of an empty path? " + err);
        return null;
    }
    return null;
};
/**
 *
 * @param {Array} paths
 */
function PathSet$1(paths) {
    this.paths = paths;
}
/**
 *
 */
PathSet$1.prototype.isEmpty = function () {
    return this.paths.length == 0;
};
/**
 *
 */
PathSet$1.prototype.getPathLeafOrElseAnyCurrentPathElement = function () {
    var leafElem = null;
    var currElem = null;
    var prev = {
        "path": null,
        "elem": null,
    };
    this.paths.forEach(path => {
        currElem = path.getCurrentPathElement();
        if (currElem instanceof PathLeafElement$3) {
            leafElem = currElem;
        }
        prev = this.errorCheckUnequalParent(path, currElem, prev.path, prev.elem);
    });
    if (leafElem != null) {
        return leafElem;
    }
    else {
        return currElem; // It doesn't matter which one we return (Next step we will get the "previous" from this one)
    }
};
/**
 * Yeah, this might be a completely un-needed check (but it MIGHT save us later on if we forget this rule).
 * What we are looking for here is an impossible state where two paths in the same set don't have the same parent.
 * (Since we usually only have one path in a path set, this check should be cheap)
 *
 * @param {Path} currPath
 * @param {PathElement} currElem
 * @param {Path} prevPath
 * @param {PathElement} prevElem
 */
PathSet$1.prototype.errorCheckUnequalParent = function (currPath, currElem, prevPath, prevElem) {
    if (prevElem != null) {
        // weird: javascript cannot compare null == null then we have to compare each with null separately :(
        if (currElem.previous == null && prevElem.previous == null) {
            return {
                "path": currPath,
                "elem": currElem
            };
        }
        else if ((currElem.previous == null && prevElem.previous != null) || (currElem.previous != null && prevElem.previous == null)) {
            throw new Error("Something is wrong, these paths do not have the same parent. (" + currPath + ") (" + prevPath + ")");
        }
        else if (!currElem.previous.equals(prevElem.previous)) {
            throw new Error("Something is wrong, these paths do not have the same parent. (" + currPath + ") (" + prevPath + ")");
        }
    }
    return {
        "path": currPath,
        "elem": currElem
    };
};
/**
 *
 */
PathSet$1.prototype.keepOnlyArrayPaths = function () {
    var filteredPaths = this.paths.filter(path => {
        return path.pathElements[0] instanceof ArrayPathElement;
    });
    return new PathSet$1(filteredPaths);
};
/**
 *
 */
PathSet$1.prototype.keepOnlyDictPaths = function () {
    var filteredPaths = this.paths.filter(path => {
        return path.pathElements[0] instanceof DictPathElement;
    });
    return new PathSet$1(filteredPaths);
};
/**
 *
 */
PathSet$1.prototype.getTailIfFirstElementIsArrayOfThisIndexFromList = function (index) {
    return this.getTailFromList(index, getTailIfFirstElementIsArrayOfThisIndex);
};
/**
 *
 */
PathSet$1.prototype.getTailIfFirstElementIsDictOfThisKeyFromList = function (key) {
    return this.getTailFromList(key, getTailIfFirstElementIsDictOfThisKey);
};
/**
 *
 */
PathSet$1.prototype.getTailFromList = function (searchKey, filterFunc) {
    var retPaths = new Array();
    this.paths.forEach(path => {
        var newPath = filterFunc(searchKey, path);
        if (newPath != null) {
            retPaths.push(newPath);
        }
    });
    return new PathSet$1(retPaths);
};
/**
 *
 * @param {Array} arr
 */
var buildPathFromArray = function (arr) {
    var pathElements = new Array();
    var lastPathElem = null;
    arr.forEach(item => {
        var newElem = null;
        if (typeof item === 'number') {
            newElem = new ArrayPathElement(lastPathElem, item);
        }
        else if (typeof item === 'string') {
            newElem = new DictPathElement(lastPathElem, item);
        }
        else {
            throw new Error("A path structure must only consist of Ints and Strings, not " + item);
        }
        pathElements.push(newElem);
        lastPathElem = newElem;
    });
    var lastOne = lastPathElem;
    pathElements.push(new PathLeafElement$3(lastOne));
    return new Path(pathElements);
};
var path = { Path, PathElement, PathLeafElement: PathLeafElement$3, ArrayPathElement, SearchablePathElement, DictPathElement, PathSet: PathSet$1,
    getTailIfFirstElementIsArrayOfThisIndex, buildPathFromArray };

var PathLeafElement$2 = path.PathLeafElement;
const HASH_PREFIX_NODE$1 = 0;
const HASH_PREFIX_LEAF$1 = 1;
const HASH_PREFIX_NODE_ARRAY$1 = 7;
const HASH_PREFIX_NODE_DICT$1 = 8;
/**
 *
 */
function BinaryTreeElement() {
    this.pathElem = null;
}
BinaryTreeElement.prototype.isPath = function () {
    return this.pathElem != null;
};
BinaryTreeElement.prototype.isPathLeaf = function () {
    if (this.pathElem == null) {
        return false;
    }
    if (this.pathElem instanceof PathLeafElement$2) {
        return true;
    }
    else {
        return false;
    }
};
BinaryTreeElement.prototype.setPathElement = function (pathElem) {
    this.pathElem = pathElem;
};
BinaryTreeElement.prototype.getPrefixByte = function () {
    return HASH_PREFIX_NODE$1;
};
/**
 *
 * @param {BinaryTreeElement} left
 * @param {BinaryTreeElement} right
 */
function Node$2(left, right) {
    this.left = left;
    this.right = right;
}
Node$2.prototype = Object.create(BinaryTreeElement.prototype);
Node$2.prototype.constructor = Node$2;
Node$2.prototype.getPrefixByte = function () {
    return HASH_PREFIX_NODE$1;
};
/**
 *
 * @param {BinaryTreeElement} left
 * @param {BinaryTreeElement} right
 * @param {*} content
 * @param {PathSet} pathElem
 */
function SubTreeRootNode$1(left, right, content, pathElem) {
    Node$2.call(this, left, right);
    this.content = content;
    BinaryTreeElement.prototype.setPathElement.call(this, pathElem);
}
SubTreeRootNode$1.prototype = Object.create(Node$2.prototype);
SubTreeRootNode$1.prototype.constructor = SubTreeRootNode$1;
/**
 *
 * @param {*} content
 * @param {PathElement} pathElem
 */
function Leaf$2(content, pathElem = null) {
    this.content = content;
    if (pathElem != null) {
        if (pathElem instanceof PathLeafElement$2) {
            BinaryTreeElement.prototype.setPathElement.call(this, pathElem);
        }
        else {
            throw new Error("The path and object structure does not match! We are at a leaf, but the path expects a sub structure.");
        }
    }
}
Leaf$2.prototype = Object.create(BinaryTreeElement.prototype);
Leaf$2.prototype.constructor = Leaf$2;
Leaf$2.prototype.getPrefixByte = function () {
    return HASH_PREFIX_LEAF$1;
};
function EmptyLeaf$2() { }
EmptyLeaf$2.prototype = Object.create(BinaryTreeElement.prototype);
EmptyLeaf$2.prototype.constructor = EmptyLeaf$2;
/**
 * Wrapper class for the root object.
 * @param {BinaryTreeElement} root
 */
function BinaryTree$1(root) {
    this.root = root;
}
BinaryTree$1.prototype.maxLevel = function () {
    return this.maxLevelInternal(this.root);
};
BinaryTree$1.prototype.maxLevelInternal = function (node) {
    if (node instanceof EmptyLeaf$2) {
        return 0;
    }
    else if (node instanceof Leaf$2) {
        return 1;
    }
    else if (node instanceof Node$2) {
        return Math.max(this.maxLevelInternal(node.left), this.maxLevelInternal(node.right)) + 1;
    }
    else {
        throw new Error("What is this type? " + typeof node);
    }
};
/**
 * Represents the top of a sub tree generated by a [Array]
 *
 * @param {*} left
 * @param {*} right
 * @param {*} content
 * @param {*} size
 * @param {PathElement} pathElem
 */
function ArrayHeadNode$2(left, right, content, size, pathElem = null) {
    SubTreeRootNode$1.call(this, left, right, content, pathElem);
    this.size = size;
}
ArrayHeadNode$2.prototype = Object.create(SubTreeRootNode$1.prototype);
ArrayHeadNode$2.prototype.constructor = ArrayHeadNode$2;
ArrayHeadNode$2.prototype.getPrefixByte = function () {
    return HASH_PREFIX_NODE_ARRAY$1;
};
/**
 * Represents the top a sub tree generated by a [Dictionary]
 * @param {*} left
 * @param {*} right
 * @param {*} content
 * @param {*} size
 * @param {PathElement} pathElem
 */
function DictHeadNode$2(left, right, content, size, pathElem = null) {
    SubTreeRootNode$1.call(this, left, right, content, pathElem);
    this.size = size;
}
DictHeadNode$2.prototype = Object.create(SubTreeRootNode$1.prototype);
DictHeadNode$2.prototype.constructor = DictHeadNode$2;
DictHeadNode$2.prototype.getPrefixByte = function () {
    return HASH_PREFIX_NODE_DICT$1;
};
var binarytree = { HASH_PREFIX_NODE: HASH_PREFIX_NODE$1, HASH_PREFIX_LEAF: HASH_PREFIX_LEAF$1, HASH_PREFIX_NODE_ARRAY: HASH_PREFIX_NODE_ARRAY$1, HASH_PREFIX_NODE_DICT: HASH_PREFIX_NODE_DICT$1,
    Node: Node$2, Leaf: Leaf$2, EmptyLeaf: EmptyLeaf$2, SubTreeRootNode: SubTreeRootNode$1, BinaryTreeElement, BinaryTree: BinaryTree$1, ArrayHeadNode: ArrayHeadNode$2, DictHeadNode: DictHeadNode$2 };

class PrivKeyFormatException extends Error {
    constructor(privKey) {
        super(`Invalid key length. Expected 32, but got ${privKey.length}`);
    }
}
class MissingPrivKeyArgumentException extends Error {
    constructor() {
        super(`Missing argument privKey`);
    }
}

function createPublicKey(privKey) {
    validatePrivKeyFormat(privKey);
    return require$$0$1.Buffer.from(secp256k1__namespace.publicKeyCreate(privKey, true).buffer);
}
function randomBytes(size) {
    return crypto__namespace.randomBytes(size);
}
function sha256(buffer) {
    return crypto__namespace.createHash("sha256").update(buffer).digest();
}
const hash256 = sha256;
function hashConcat(items) {
    return hash256(require$$0$1.Buffer.concat(items));
}
/**
 * @param content the content that the signature signs. It will be digested before validating.
 * @param pubKey The pubKey to validate the signature with
 * @param signature the signature to validate
 *
 * @return true if signature ok, false otherwise
 */
function checkSignature(content, pubKey, signature) {
    const digest = hash256(content);
    return checkDigestSignature(digest, pubKey, signature);
}
/**
 * @param digest the signed digest. It will not be digested before validating.
 * @param pubKey The pubKey to validate the signature with
 * @param signature the signature to validate
 *
 * @return true if signature ok, false otherwise
 */
function checkDigestSignature(digest, pubKey, signature) {
    if (!signature)
        return false;
    return secp256k1__namespace.ecdsaVerify(signature, digest, pubKey);
}
/**
 * @param content to sign. It will be digested before signing.
 * @param privKey The private key to sign the content with
 *
 * @return the signature
 */
function sign$1(content, privKey) {
    validatePrivKeyFormat(privKey);
    const digestBuffer = sha256(content);
    return signDigest(digestBuffer, privKey);
}
/**
 * @param digestBuffer to sign. It will not be digested before signing.
 * @param privKey The private key to sign the digest with
 *
 * @return the signature
 */
function signDigest(digestBuffer, privKey) {
    return require$$0$1.Buffer.from(secp256k1__namespace.ecdsaSign(digestBuffer, privKey).signature);
}
/**
 * Creates a key pair (which usually represents one user)
 * @param privKey to create key pair based on
 * @returns {{pubKey: Buffer, privKey: Buffer}}
 */
function makeKeyPair(privKey) {
    let pubKey;
    if (privKey) {
        privKey = ensureBuffer(privKey);
        pubKey = createPublicKey(privKey);
    }
    else {
        do {
            privKey = randomBytes(32);
        } while (!secp256k1__namespace.privateKeyVerify(privKey));
        pubKey = require$$0$1.Buffer.from(secp256k1__namespace.publicKeyCreate(privKey).buffer);
    }
    return { pubKey, privKey };
}
/**
 * Generates a 16bytes TUID (Text unique ID) (a 32characters long string)
 * @returns string
 */
function makeTuid() {
    return randomBytes(16).toString("hex");
}
/**
 * Verify that keypair is correct. Providing the private key, this function returns its associated public key
 * @param privKey: Buffer
 * @returns {{pubKey: Buffer, privKey: Buffer}}
 */
function verifyKeyPair(privKey) {
    validatePrivKeyFormat(privKey);
    const pubKey = require$$0$1.Buffer.from(secp256k1__namespace.publicKeyCreate(privKey).buffer);
    return { pubKey, privKey };
}
function validatePrivKeyFormat(privKey) {
    if (!privKey) {
        throw new MissingPrivKeyArgumentException();
    }
    if (!require$$0$1.Buffer.isBuffer(privKey) || privKey.length !== 32) {
        throw new PrivKeyFormatException(privKey);
    }
}

var encryption$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	checkDigestSignature: checkDigestSignature,
	checkSignature: checkSignature,
	createPublicKey: createPublicKey,
	hash256: hash256,
	hashConcat: hashConcat,
	makeKeyPair: makeKeyPair,
	makeTuid: makeTuid,
	randomBytes: randomBytes,
	sha256: sha256,
	sign: sign$1,
	signDigest: signDigest,
	verifyKeyPair: verifyKeyPair
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(encryption$1);

const { Buffer: Buffer$3 } = require$$0$1;
var serialization = require$$1;
var HASH_PREFIX_LEAF = binarytree.HASH_PREFIX_LEAF;
var encryption = require$$3;
function CryptoSystem() { }
CryptoSystem.prototype.digest = function (buffer) {
    return encryption.hash256(buffer);
};
/**
 *
 * @param {Buffer} buffer
 * @param {CryptoSystem} cryptoSystem
 */
function hashingFun(buffer, cryptoSystem) {
    if (cryptoSystem === null) {
        throw new Error("In this case we need the CryptoSystem to calculate the hash");
    }
    else {
        return cryptoSystem.digest(buffer);
    }
}
/**
 *
 * @param {CryptoSystem} cryptoSystem
 */
function MerkleHashCalculator(cryptoSystem) {
    this.cryptoSystem = cryptoSystem;
}
/**
 * @param {number} prefix
 * @param {Buffer} hashLeft
 * @param {Buffer} hashRight
 */
MerkleHashCalculator.prototype.calculateNodeHash = function (prefix, hashLeft, hashRight) {
    return this.calculateNodeHashInternal(prefix, hashLeft, hashRight, hashingFun);
};
/**
 * @param {*} value
 */
MerkleHashCalculator.prototype.calculateLeafHash = function (value) {
    return this.calculateHashOfValueInternal(value, serialization.encodeValue, hashingFun);
};
/**
 * @param {number} prefix
 * @param {Buffer} hashLeft
 * @param {Buffer} hashRight
 */
MerkleHashCalculator.prototype.calculateNodeHashInternal = function (prefix, hashLeft, hashRight, hashFunc) {
    var buf = Buffer$3.alloc(1);
    buf.writeInt8(prefix);
    var bufferSum = Buffer$3.concat([buf, hashLeft, hashRight]);
    return hashFunc(bufferSum, this.cryptoSystem);
};
MerkleHashCalculator.prototype.calculateHashOfValueInternal = function (valuetoHash, serializeFun, hashFunc) {
    var buf = Buffer$3.alloc(1);
    buf.writeInt8(HASH_PREFIX_LEAF);
    var bufferSum = Buffer$3.concat([buf, serializeFun(valuetoHash)]);
    return hashFunc(bufferSum, this.cryptoSystem);
};
MerkleHashCalculator.prototype.isContainerProofValueLeaf = function (value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Array || typeof value === 'object') {
        return true;
    }
    else {
        return false;
    }
};
var merklehashcalculator = { MerkleHashCalculator, CryptoSystem };

var util = require$$0;
const { Buffer: Buffer$2 } = require$$0$1;
var PathSet = path.PathSet;
var PathLeafElement$1 = path.PathLeafElement;
var EmptyLeaf$1 = binarytree.EmptyLeaf;
var Leaf$1 = binarytree.Leaf;
var Node$1 = binarytree.Node;
var BinaryTree = binarytree.BinaryTree;
var ArrayHeadNode$1 = binarytree.ArrayHeadNode;
var DictHeadNode$1 = binarytree.DictHeadNode;
const NO_PATHS = new PathSet([]);
/**
 * The factory does the conversion between list of elements and tree of elements.
 *
 * Note: The idea is that you should sub class for each type of element you want to build.
 */
function BinaryTreeFactory$1() { }
/**
 * Transforms the incoming leaf into an [BinaryTreeElement]
 * The idea with this function is that it can be recursive (if the leaf in turn is complex object with sub objects).
 *
 * Note: If we don't have a path here we can try to find the leaf in the cache.
 *
 * @param leaf the raw data we should wrap in a leaf
 * @param paths a collection of proof paths that might point to this leaf
 * @return the resulting [BinaryTreeElement] the leaf got converted to
 */
BinaryTreeFactory$1.prototype.handleLeaf = function (leaf, paths, isRoot = false) {
    if (paths.length == 0 && !isRoot) {
        return this.innerHandleLeaf(leaf, this.getEmptyPathSet());
    }
    else {
        return this.innerHandleLeaf(leaf, paths);
    }
};
/**
 *
 */
BinaryTreeFactory$1.prototype.getEmptyPathSet = function () {
    return NO_PATHS;
};
/**
 * At this point we should have looked in cache.
 *
 * @param leaf we should turn into a tree element
 * @param {PathSet} paths
 * @return the tree element we created.
 */
BinaryTreeFactory$1.prototype.innerHandleLeaf = function (leaf, paths) {
    if (leaf == null) {
        return this.handlePrimitiveLeaf(leaf, paths);
    }
    if (Buffer$2.isBuffer(leaf)) {
        return this.handlePrimitiveLeaf(leaf, paths);
    }
    if (typeof leaf === 'string') {
        return this.handlePrimitiveLeaf(leaf, paths);
    }
    if (typeof leaf === 'number') {
        return this.handlePrimitiveLeaf(leaf, paths);
    }
    if (typeof leaf === 'bigint') {
        return this.handlePrimitiveLeaf(leaf, paths);
    }
    if (typeof leaf === 'boolean') {
        return this.handlePrimitiveLeaf(leaf ? 1 : 0, paths);
    }
    if (leaf.constructor === Array) {
        return this.buildFromArray(leaf, paths);
    }
    if (typeof leaf === 'object') {
        return this.buildFromDictionary(leaf, paths);
    }
    else {
        throw new Error("Unsupporting data type");
    }
};
/**
 * Just like [handleLeaf] but we know that this leaf should not be a complex type, but something we can
 * immediately wrap
 *
 * @param leaf
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.handlePrimitiveLeaf = function (leaf, paths) {
    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
    if (pathElem != null && !(pathElem instanceof PathLeafElement$1)) {
        throw new Error("Path does not match the tree structure. We are at a leaf " + leaf + " but found path element " + pathElem);
    }
    return new Leaf$1(leaf, pathElem);
};
/**
 * Calls itself until the return value only holds 1 element
 *
 * Note: This method can only create standard [Node] that fills up the area between the "top" and the leaves.
 *        These "in-between" nodes cannot be "path leaf" or have any interesting properties.
 *
 * @param layer What layer we aim calculate
 * @param inList The args of nodes we should build from
 * @return All [BinaryTreeElement] nodes of the next layer
 */
BinaryTreeFactory$1.prototype.buildHigherLayer = function (layer, inList) {
    if (inList.length === 0) {
        throw new Error("Cannot work on empty arrays. Layer: " + layer);
    }
    else if (inList.length === 1) {
        return inList;
    }
    var returnArray = new Array();
    var nrOfNodesToCreate = Math.floor(inList.length / 2);
    var leftValue = null;
    var isLeft = true;
    for (var i = 0; i < inList.length; i++) {
        if (isLeft) {
            leftValue = inList[i];
            isLeft = false;
        }
        else {
            var tempNode = new Node$1(leftValue, inList[i]);
            returnArray.push(tempNode);
            nrOfNodesToCreate--;
            isLeft = true;
            leftValue = null;
        }
    }
    if (!isLeft) {
        // If there is odd number of nodes, then move the last node up one level
        returnArray.push(leftValue);
    }
    // Extra check
    if (nrOfNodesToCreate != 0) {
        util.logDebug("Why didn't we build exactly the correct amount? Layer: " + layer + " , residue: " + nrOfNodesToCreate + " , input args size: " + inList.length + ".");
    }
    return this.buildHigherLayer((layer + 1), returnArray);
};
BinaryTreeFactory$1.prototype.build = function (data) {
    return this.buildWithPath(data, NO_PATHS);
};
/**
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.buildWithPath = function (data, paths) {
    var result = this.handleLeaf(data, paths, true);
    return new BinaryTree(result);
};
/**
 * @param {Array} array
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.buildFromArray = function (array, paths) {
    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
    // 1. Build leaf layer
    if (array.length == 0) {
        return new ArrayHeadNode$1(new EmptyLeaf$1(), new EmptyLeaf$1(), array, 0, 0, pathElem);
    }
    var leafArray = this.buildLeafElements(array, paths);
    // 2. Build all higher layers
    var result = this.buildHigherLayer(1, leafArray);
    // 3. Fix and return the root node
    var orgRoot = result[0];
    if (orgRoot instanceof Node$1) {
        return new ArrayHeadNode$1(orgRoot.left, orgRoot.right, array, array.length, pathElem);
    }
    if (orgRoot instanceof Leaf$1) {
        return this.buildFromOneLeaf(array, orgRoot, pathElem);
    }
    else {
        throw new Error("Should not find element of this type here");
    }
};
/**
 *
 */
BinaryTreeFactory$1.prototype.buildFromOneLeaf = function (array, orgRoot, pathElem) {
    if (array.length > 1) {
        throw new Error("How come we got a leaf returned when we had " + array.length + " elements is the args?");
    }
    else {
        return new ArrayHeadNode$1(orgRoot, new EmptyLeaf$1(), array, array.length, pathElem);
    }
};
/**
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.buildLeafElements = function (leafList, paths) {
    var leafArray = new Array();
    var onlyArrayPaths = paths.keepOnlyArrayPaths(); // For performance, since we will loop soon
    for (var i = 0; i < leafList.length; i++) {
        var pathsRelevantForThisLeaf = onlyArrayPaths.getTailIfFirstElementIsArrayOfThisIndexFromList(i);
        var leaf = leafList[i];
        var binaryTreeElement = this.handleLeaf(leaf, pathsRelevantForThisLeaf);
        leafArray.push(binaryTreeElement);
    }
    return leafArray;
};
/**
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.buildFromDictionary = function (dict, paths) {
    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
    // Needs to be sorted, or else the order is undefined
    var keys = Object.keys(dict).sort();
    if (keys.length == 0) {
        return new DictHeadNode$1(new EmptyLeaf$1(), new EmptyLeaf$1(), dict, keys.length, 0, pathElem);
    }
    // 1. Build first (leaf) layer
    var leafArray = this.buildLeafElementFromDict(keys, dict, paths);
    // 2. Build all higher layers
    var result = this.buildHigherLayer(1, leafArray);
    // 3. Fix and return the root node
    var orgRoot = result[0];
    if (orgRoot instanceof Node$1) {
        return new DictHeadNode$1(orgRoot.left, orgRoot.right, dict, keys.length, pathElem);
    }
    else {
        throw new Error("Should not find element of this type here: " + typeof orgRoot);
    }
};
/**
 * @param {PathSet} paths
 */
BinaryTreeFactory$1.prototype.buildLeafElementFromDict = function (keys, dict, paths) {
    var leafArray = new Array();
    var onlyDictPaths = paths.keepOnlyDictPaths(); // For performance, since we will loop soon
    for (var i = 0; i < keys.length; i++) {
        // The key cannot not be proved, so NO_PATHS
        var key = keys[i];
        var keyElement = this.handleLeaf(key, NO_PATHS);
        leafArray.push(keyElement);
        var content = dict[key];
        var pathsRelevantForThisLeaf = onlyDictPaths.getTailIfFirstElementIsDictOfThisKeyFromList(key);
        var contentElement = this.handleLeaf(content, pathsRelevantForThisLeaf);
        leafArray.push(contentElement);
    }
    return leafArray;
};
var binarytreefactory = { BinaryTreeFactory: BinaryTreeFactory$1 };

var HASH_PREFIX_NODE = binarytree.HASH_PREFIX_NODE;
var HASH_PREFIX_NODE_ARRAY = binarytree.HASH_PREFIX_NODE_ARRAY;
var HASH_PREFIX_NODE_DICT = binarytree.HASH_PREFIX_NODE_DICT;
/**
 *
 */
function MerkleProofElement() { }
/**
 *
 * @param {Buffer} prefix
 * @param {MerkleProofElement} left
 * @param {MerkleProofElement} right
 */
function ProofNode$1(prefix, left, right) {
    this.prefix = prefix;
    this.left = left;
    this.right = right;
}
ProofNode$1.prototype = Object.create(MerkleProofElement.prototype);
ProofNode$1.prototype.constructor = ProofNode$1;
/**
 *
 * @param {MerkleProofElement} left
 * @param {MerkleProofElement} right
 */
function ProofNodeSimple$1(left, right) {
    ProofNode$1.call(this, HASH_PREFIX_NODE, left, right);
}
ProofNodeSimple$1.prototype = Object.create(ProofNode$1.prototype);
ProofNodeSimple$1.prototype.constructor = ProofNodeSimple$1;
/**
 *
 * @param {*} content
 * @param {SearchablePathElement} pathElem
 */
function ProofValueLeaf$2(content, pathElem) {
    this.content = content;
    this.pathElem = pathElem;
}
ProofValueLeaf$2.prototype = Object.create(MerkleProofElement.prototype);
ProofValueLeaf$2.prototype.constructor = ProofValueLeaf$2;
/**
 *
 * @param {Buffer} merkleHash
 */
function ProofHashedLeaf$2(merkleHash) {
    this.merkleHash = merkleHash;
}
ProofHashedLeaf$2.prototype = Object.create(MerkleProofElement.prototype);
ProofHashedLeaf$2.prototype.constructor = ProofHashedLeaf$2;
/**
 * @param {ProofHashedLeaf} other
 */
ProofHashedLeaf$2.prototype.equals = function (other) {
    if (other instanceof ProofHashedLeaf$2) {
        return this.merkleHash.equals(other.merkleHash);
    }
    else {
        return false;
    }
};
/**
 *
 * @param {MerkleProofElement} left
 * @param {MerkleProofElement} right
 * @param {SearchablePathElement} pathElem
 */
function ProofNodeArrayHead$1(left, right, pathElem = null) {
    ProofNode$1.call(this, HASH_PREFIX_NODE_ARRAY, left, right);
    this.pathElem = pathElem;
}
ProofNodeArrayHead$1.prototype = Object.create(ProofNode$1.prototype);
ProofNodeArrayHead$1.prototype.constructor = ProofNodeArrayHead$1;
/**
 *
 * @param {MerkleProofElement} left
 * @param {MerkleProofElement} right
 * @param {SearchablePathElement} pathElem
 */
function ProofNodeDictHead$1(left, right, pathElem = null) {
    ProofNode$1.call(this, HASH_PREFIX_NODE_DICT, left, right);
    this.pathElem = pathElem;
}
ProofNodeDictHead$1.prototype = Object.create(ProofNode$1.prototype);
ProofNodeDictHead$1.prototype.constructor = ProofNodeDictHead$1;
/**
 *
 * @param {MerkleProofElement} root
 */
function MerkleProofTree$1(root) {
    this.root = root;
}
MerkleProofTree$1.prototype.maxLevel = function () {
    return this.maxLevelInternal(this.root);
};
/**
 * @param {MerkleProofElement} node
 */
MerkleProofTree$1.prototype.maxLevelInternal = function (node) {
    if (node instanceof ProofValueLeaf$2) {
        return 1;
    }
    else if (node instanceof ProofHashedLeaf$2) {
        return 1;
    }
    else if (node instanceof ProofNode$1) {
        return Math.max(this.maxLevelInternal(node.left), this.maxLevelInternal(node.right)) + 1;
    }
    else {
        throw new Error("Should be able to handle node type: " + typeof node);
    }
};
var merkleprooftree = { ProofNode: ProofNode$1, ProofNodeSimple: ProofNodeSimple$1, ProofHashedLeaf: ProofHashedLeaf$2, ProofValueLeaf: ProofValueLeaf$2,
    ProofNodeArrayHead: ProofNodeArrayHead$1, ProofNodeDictHead: ProofNodeDictHead$1, MerkleProofElement, MerkleProofTree: MerkleProofTree$1 };

const { Buffer: Buffer$1 } = require$$0$1;
var Node = binarytree.Node;
var Leaf = binarytree.Leaf;
var EmptyLeaf = binarytree.EmptyLeaf;
var ProofHashedLeaf$1 = merkleprooftree.ProofHashedLeaf;
var ProofValueLeaf$1 = merkleprooftree.ProofValueLeaf;
var MerkleProofTree = merkleprooftree.MerkleProofTree;
var ProofNodeArrayHead = merkleprooftree.ProofNodeArrayHead;
var ProofNodeDictHead = merkleprooftree.ProofNodeDictHead;
var PathLeafElement = path.PathLeafElement;
var SubTreeRootNode = binarytree.SubTreeRootNode;
var ArrayHeadNode = binarytree.ArrayHeadNode;
var DictHeadNode = binarytree.DictHeadNode;
var ProofNodeSimple = merkleprooftree.ProofNodeSimple;
const EMPTY_HASH = new Buffer$1.alloc(32);
/**
 *
 */
function MerkleProofTreeFactory$1() { }
/**
 * @param {BinaryTree} orginalTree
 */
MerkleProofTreeFactory$1.prototype.buildFromBinaryTree = function (orginalTree, calculator) {
    var rootElem = this.buildFromBinaryTreeInternal(orginalTree.root, calculator);
    return new MerkleProofTree(rootElem);
};
/**
 * @param {BinaryTreeElement} elem
 * @param {*} calculator
 */
MerkleProofTreeFactory$1.prototype.buildFromBinaryTreeInternal = function (elem, calculator) {
    if (elem instanceof EmptyLeaf) {
        return new ProofHashedLeaf$1(EMPTY_HASH);
    }
    else if (elem instanceof Leaf) {
        var pathElem = elem.pathElem;
        if (pathElem != null) {
            if (pathElem instanceof PathLeafElement) {
                return new ProofValueLeaf$1(elem.content, pathElem.previous);
            }
            else {
                throw new Error("The path and structure don't match. We are at a leaf, but path elem is not a leaf: " + pathElem);
            }
        }
        else {
            // make a hash
            var hash = calculator.calculateLeafHash(elem.content);
            return new ProofHashedLeaf$1(hash);
        }
    }
    else if (elem instanceof SubTreeRootNode) {
        var pathElem = elem.pathElem;
        if (pathElem != null) {
            if (pathElem instanceof PathLeafElement) {
                // Don't convert it
                return new ProofValueLeaf$1(elem.content, pathElem.previous);
            }
            else {
                return this.convertNode(elem, calculator);
            }
        }
        else {
            return this.convertNode(elem, calculator);
        }
    }
    else if (elem instanceof Node) {
        return this.convertNode(elem, calculator);
    }
    else {
        throw new Error("Cannot handle " + elem);
    }
};
/**
 * @param {Node} node
 */
MerkleProofTreeFactory$1.prototype.convertNode = function (node, calculator) {
    var left = this.buildFromBinaryTreeInternal(node.left, calculator);
    var right = this.buildFromBinaryTreeInternal(node.right, calculator);
    if (left instanceof ProofHashedLeaf$1 && right instanceof ProofHashedLeaf$1) {
        var addedHash = calculator.calculateNodeHash(node.getPrefixByte(), left.merkleHash, right.merkleHash);
        return new ProofHashedLeaf$1(addedHash);
    }
    else {
        return this.buildNodeOfCorrectType(node, left, right);
    }
};
/**
 * @param {ArrayHeadNode} node
 */
MerkleProofTreeFactory$1.prototype.extractSearchablePathElement = function (node) {
    var pathElem = node.pathElem;
    if (pathElem != null) {
        return pathElem.previous;
    }
    else {
        return null;
    }
};
/**
 * @param {Node} node
 * @param {MerkleProofElement} left
 * @param {MerkleProofElement} right
 */
MerkleProofTreeFactory$1.prototype.buildNodeOfCorrectType = function (node, left, right) {
    if (node instanceof ArrayHeadNode) {
        return new ProofNodeArrayHead(left, right, this.extractSearchablePathElement(node));
    }
    else if (node instanceof DictHeadNode) {
        return new ProofNodeDictHead(left, right, this.extractSearchablePathElement(node));
    }
    else if (node instanceof Node) {
        return new ProofNodeSimple(left, right);
    }
    else {
        throw new Error("Should have taken care of this node type: " + node);
    }
};
var merkleprooftreefactory = { MerkleProofTreeFactory: MerkleProofTreeFactory$1 };

/**
 *
 * @param {Buffer} merkleHash
 */
function MerkleHashSummary$1(merkleHash) {
    this.merkleHash = merkleHash;
}
/**
 * @param {MerkleHashSummary} other
 */
MerkleHashSummary$1.prototype.equals = function (other) {
    if (this === other)
        return true;
    if (typeof this != typeof other)
        return false;
    if (this.merkleHash.compare(other.merkleHash) === 0) {
        return true;
    }
    return false;
};
var merklehashcarrier = { MerkleHashSummary: MerkleHashSummary$1 };

var ProofHashedLeaf = merkleprooftree.ProofHashedLeaf;
var ProofValueLeaf = merkleprooftree.ProofValueLeaf;
var ProofNode = merkleprooftree.ProofNode;
var MerkleHashSummary = merklehashcarrier.MerkleHashSummary;
/**
 *
 * @param {BinaryTreeFactory} treeFactory
 * @param {MerkleProofTreeFactory} proofFactory
 */
function MerkleHashSummaryFactory$1(treeFactory, proofFactory) {
    this.treeFactory = treeFactory;
    this.proofFactory = proofFactory;
}
/**
 * @param {any} value
 * @param {MerkleHashCalculator} calculator
 */
MerkleHashSummaryFactory$1.prototype.calculateMerkleRoot = function (value, calculator) {
    var binaryTree = this.treeFactory.build(value);
    var proofTree = this.proofFactory.buildFromBinaryTree(binaryTree, calculator);
    return this.calculateMerkleRootOfTree(proofTree, calculator);
};
/**
 * @param {MerkleProofTree} value
 * @param {MerkleHashCalculator} calculator
 */
MerkleHashSummaryFactory$1.prototype.calculateMerkleTreeRoot = function (tree, calculator) {
    return this.calculateMerkleRootOfTree(tree, calculator);
};
/**
 * @param {MerkleProofTree} proofTree
 * @param {MerkleHashCalculator} calculator
 */
MerkleHashSummaryFactory$1.prototype.calculateMerkleRootOfTree = function (proofTree, calculator) {
    var calculatedSummary = this.calculateMerkleRootInternal(proofTree.root, calculator);
    return new MerkleHashSummary(calculatedSummary);
};
/**
 * @param {MerkleProofElement} currentElement
 * @param {MerkleHashCalculator} calculator
 */
MerkleHashSummaryFactory$1.prototype.calculateMerkleRootInternal = function (currentElement, calculator) {
    if (currentElement instanceof ProofHashedLeaf) {
        return currentElement.merkleHash;
    }
    else if (currentElement instanceof ProofValueLeaf) {
        var value = currentElement.content;
        if (calculator.isContainerProofValueLeaf(value)) {
            // We have a container value to prove, so need to convert the value to a binary tree, and THEN hash it
            var merkleProofTree = this.buildProofTree(value, calculator);
            return this.calculateMerkleRootInternal(merkleProofTree.root, calculator);
        }
        else {
            // This is a primitive value, just hash it
            return calculator.calculateLeafHash(value);
        }
    }
    else if (currentElement instanceof ProofNode) {
        var left = this.calculateMerkleRootInternal(currentElement.left, calculator);
        var right = this.calculateMerkleRootInternal(currentElement.right, calculator);
        return calculator.calculateNodeHash(currentElement.prefix, left, right);
    }
    else {
        throw new Error("Should have handled this type? " + typeof currentElement);
    }
};
/**
 * @param {any} value
 * @param {MerkleHashCalculator} calculator
 */
MerkleHashSummaryFactory$1.prototype.buildProofTree = function (value, calculator) {
    var root = this.treeFactory.build(value);
    return this.proofFactory.buildFromBinaryTree(root, calculator);
};
var merklehashsummaryfactory = { MerkleHashSummaryFactory: MerkleHashSummaryFactory$1 };

var MerkleHashSummaryFactory = merklehashsummaryfactory.MerkleHashSummaryFactory;
var BinaryTreeFactory = binarytreefactory.BinaryTreeFactory;
var MerkleProofTreeFactory = merkleprooftreefactory.MerkleProofTreeFactory;
var treeFactory = new BinaryTreeFactory();
var proofFactory = new MerkleProofTreeFactory();
/**
 * Calculates the merkle root hash of the structure.
 *
 * @param {any} value
 * @param {MerkleHashCalculator} calculator describes the method we use for hashing and serialization
 * @return the merkle root hash (32 bytes) of the data structure.
 */
function merkleHash(value, calculator) {
    return merkleHashSummary(value, calculator).merkleHash;
}
/**
 *
 * @param {MerkleProofTree} tree
 * @param {MerkleHashCalculator} calculator
 */
function merkleTreeHash(tree, calculator) {
    return merkleProofHashSummary(tree, calculator).merkleHash;
}
/**
 * Calculates the merkle root hash of the structure
 *
 * @param {any} value
 * @param {MerkleHashCalculator} calculator describes the method we use for hashing and serialization
 * @return the merkle root hash summary
 */
function merkleHashSummary(value, calculator) {
    var summaryFactory = new MerkleHashSummaryFactory(treeFactory, proofFactory);
    return summaryFactory.calculateMerkleRoot(value, calculator);
}
/**
 *
 * @param {MerkleProofTree} tree
 * @param {MerkleHashCalculator} calculator
 */
function merkleProofHashSummary(tree, calculator) {
    var summaryFactory = new MerkleHashSummaryFactory(treeFactory, proofFactory);
    return summaryFactory.calculateMerkleTreeRoot(tree, calculator);
}
/**
 *
 * @param {any} value
 * @param {PathSet} pathSet
 * @param {MerkleHashCalculator} calculator
 */
function generateProof(value, pathSet, calculator) {
    var binaryTree = treeFactory.buildWithPath(value, pathSet);
    return proofFactory.buildFromBinaryTree(binaryTree, calculator);
}
var merkleproof = { merkleHash, merkleTreeHash, merkleHashSummary, generateProof };

const theMerkleHashCalculator = new merklehashcalculator.MerkleHashCalculator(new merklehashcalculator.CryptoSystem());
const gtvHash = (obj) => {
    return merkleproof.merkleHashSummary(obj, theMerkleHashCalculator).merkleHash;
};
const encode$1 = encodeValue;
const decode$1 = decodeValue;

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	decode: decode$1,
	encode: encode$1,
	gtvHash: gtvHash
});

const encode = encodeValueGtx;
const decode = decodeValueGtx;

var __awaiter$c = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function emptyGtx(blockchainRid) {
    return { blockchainRid, operations: [], signers: [] };
}
/**
 * Adds a function call to a GTX. Creates a new GTX if none specified.
 * This function will throw Error if gtx is already signed
 * @param opName the name of the function to call
 * @param args the array of arguments of the function call. If no args, this must be an empty array
 * @param gtx the function call will be added to this gtx
 * @returns the gtx
 * @throws if gtx is null or if gtx is already signed
 */
function addTransactionToGtx(opName, args, gtx) {
    if (gtx == null) {
        throw new MissingGtxException();
    }
    if (gtx.signatures) {
        throw new AlreadySignedTransactionException("function");
    }
    gtx.operations.push({ opName: opName, args: args });
    return gtx;
}
function addSignerToGtx(signer, gtx) {
    if (gtx.signatures) {
        throw new AlreadySignedTransactionException("signer");
    }
    gtx.signers.push(signer);
}
/**
 * Serializes the gtx to get tx hash
 * @param gtx the gtx to serialize
 */
function getDigest(gtx) {
    return gtvHash(gtxToRawGtx(gtx));
}
/**
 * Serializes the gtx for signing
 * @param gtx the gtx to serialize
 */
function getDigestToSign(gtx) {
    return gtvHash(gtxToRawGtxBody(gtx));
}
function getDigestToSignFromRawGtxBody(gtxBody) {
    return gtvHash(gtxBody);
}
function gtxToRawGtxBody(gtx) {
    return [
        gtx.blockchainRid,
        gtx.operations.map((op) => [op.opName, op.args]),
        gtx.signers,
    ];
}
function gtxToRawGtx(gtx) {
    var _a;
    return [
        [
            gtx.blockchainRid,
            gtx.operations.map((op) => [op.opName, op.args]),
            gtx.signers,
        ],
        (_a = gtx.signatures) !== null && _a !== void 0 ? _a : [],
    ];
}
function sign(gtx, privOrSigProv, pubKey) {
    return __awaiter$c(this, void 0, void 0, function* () {
        if (privOrSigProv instanceof Buffer) {
            const digestToSign = getDigestToSign(gtx);
            const signature = signDigest(digestToSign, privOrSigProv);
            return addSignature(pubKey || makeKeyPair(privOrSigProv).pubKey, signature, gtx);
        }
        else {
            // Removes signatures and extract the rawgtxBody
            const rawGtxBody = gtxToRawGtxBody(gtx);
            const signature = yield privOrSigProv.sign(rawGtxBody);
            return addSignature(privOrSigProv.pubKey, signature, gtx);
        }
    });
}
function signRawTransaction(_keyPair, _rawTransaction) {
    throw Error("TODO");
    //TODO
    //const gtx = module.exports.deserialize(rawTransaction);
    //module.exports.sign(keyPair.privKey, keyPair.pubKey, gtx);
    // return module.exports.serialize(gtx)
}
/**
 * Adds a signature to the gtx
 */
function addSignature(pubKeyBuffer, signatureBuffer, gtx) {
    if (!gtx.signatures) {
        gtx.signatures = Array(gtx.signers.length);
    }
    const signerIndex = gtx.signers.findIndex((signer) => pubKeyBuffer.equals(signer));
    if (signerIndex === -1) {
        throw new MissingSignerException();
    }
    gtx.signatures[signerIndex] = signatureBuffer;
    return gtx;
}
function serialize(gtx) {
    if (!gtx.signatures) {
        // TODO
        // The gtx is not signed, but we must include
        // the signatures attribute, so let's add that.
        gtx.signatures = [];
    }
    return encode([gtxToRawGtxBody(gtx), gtx.signatures]);
}
function deserialize(gtxBytes) {
    const deserializedTx = decode(gtxBytes);
    const body = deserializedTx[0];
    const gtvTxBody = {
        blockchainRid: body[0],
        operations: body[1].map((operation) => ({
            opName: operation[0],
            args: operation[1],
        })),
        signers: body[2],
    };
    const signatures = deserializedTx[1];
    return {
        blockchainRid: gtvTxBody.blockchainRid,
        operations: gtvTxBody.operations,
        signers: gtvTxBody.signers,
        signatures,
    };
}
function checkGTXSignatures(txHash, gtx) {
    var _a;
    for (const i in gtx.signers) {
        const signValid = checkDigestSignature(txHash, gtx.signers[i], (_a = gtx.signatures) === null || _a === void 0 ? void 0 : _a[i]);
        if (!signValid)
            return signValid;
    }
    return true;
}
function checkExistingGTXSignatures(txHash, gtx) {
    var _a;
    for (const i in gtx.signers) {
        if ((_a = gtx.signatures) === null || _a === void 0 ? void 0 : _a[i]) {
            const signValid = checkDigestSignature(txHash, gtx.signers[i], gtx.signatures[i]);
            if (!signValid)
                return signValid;
        }
    }
    return true;
}
function newSignatureProvider(keyPair) {
    let pub, priv;
    if (keyPair) {
        priv = ensureBuffer(keyPair.privKey);
        pub = keyPair.pubKey ? ensureBuffer(keyPair.pubKey) : createPublicKey(priv);
    }
    else {
        ({ privKey: priv, pubKey: pub } = makeKeyPair());
    }
    return {
        pubKey: pub,
        sign: (gtx) => __awaiter$c(this, void 0, void 0, function* () {
            const signature = getDigestToSignFromRawGtxBody(gtx);
            return signDigest(signature, priv);
        }),
    };
}
function rawGtvToGtx(gtv) {
    if (Array.isArray(gtv) && gtv.length !== 2) {
        throw new Error("Gtv must be an array of size 2");
    }
    const gtvArray = gtv;
    if (!Array.isArray(gtvArray[0])) {
        throw new Error("First element must be an array");
    }
    if (!Array.isArray(gtvArray[1])) {
        throw new Error("Second element must be an array");
    }
    gtvArray[1].forEach((element) => {
        if (!Buffer.isBuffer(element)) {
            throw new Error("Element must be a buffer");
        }
    });
    const gtxBody = rawGtvToGtxBody(gtvArray[0]);
    return Object.assign(Object.assign({}, gtxBody), { signatures: gtvArray[1] });
}
function rawGtvToGtxBody(gtv) {
    if (Array.isArray(gtv) && gtv.length !== 3) {
        throw new Error("Gtv must be an array of size 3");
    }
    const array = gtv;
    if (!Buffer.isBuffer(array[0])) {
        throw new Error("First element must be a byte array");
    }
    if (!Array.isArray(array[1])) {
        throw new Error("Second element must be an array");
    }
    if (!Array.isArray(array[2])) {
        throw new Error("Third element must be an array");
    }
    array[2].forEach((element) => {
        if (!Buffer.isBuffer(element)) {
            throw new Error("Element must be a buffer");
        }
    });
    return {
        blockchainRid: array[0],
        operations: array[1].map((element) => rawGtvToRellOp(element)),
        signers: array[2],
    };
}
function rawGtvToRellOp(gtv) {
    if (Array.isArray(gtv) && gtv.length !== 2) {
        throw new Error("Gtv must be an array of size 2");
    }
    const array = gtv;
    if (typeof array[0] !== "string") {
        throw new Error("First element must be a string");
    }
    if (!Array.isArray(array[1])) {
        throw new Error("Second element must be an array");
    }
    return { opName: array[0], args: array[1] };
}

var gtx = /*#__PURE__*/Object.freeze({
	__proto__: null,
	addSignature: addSignature,
	addSignerToGtx: addSignerToGtx,
	addTransactionToGtx: addTransactionToGtx,
	checkExistingGTXSignatures: checkExistingGTXSignatures,
	checkGTXSignatures: checkGTXSignatures,
	deserialize: deserialize,
	emptyGtx: emptyGtx,
	getDigest: getDigest,
	getDigestToSign: getDigestToSign,
	getDigestToSignFromRawGtxBody: getDigestToSignFromRawGtxBody,
	gtxToRawGtx: gtxToRawGtx,
	gtxToRawGtxBody: gtxToRawGtxBody,
	newSignatureProvider: newSignatureProvider,
	rawGtvToGtx: rawGtvToGtx,
	serialize: serialize,
	sign: sign,
	signRawTransaction: signRawTransaction
});

var _a$1;
var MsgType;
(function (MsgType) {
    MsgType["Debug"] = "DEBUG";
    MsgType["Info"] = "INFO";
    MsgType["Error"] = "ERROR";
    MsgType["Warning"] = "WARNING";
})(MsgType || (MsgType = {}));
var LogColor;
(function (LogColor) {
    LogColor["Red"] = "\u001B[91m";
    LogColor["Green"] = "\u001B[92m";
    LogColor["Blue"] = "\u001B[36m";
    LogColor["Yellow"] = "\u001B[93m";
    LogColor["StopColor"] = "\u001B[0m";
})(LogColor || (LogColor = {}));
var LogLevel;
(function (LogLevel) {
    LogLevel["Debug"] = "DEBUG";
    LogLevel["Info"] = "INFO";
    LogLevel["Error"] = "ERROR";
    LogLevel["Warning"] = "WARNING";
    LogLevel["Disabled"] = "DISABLED";
})(LogLevel || (LogLevel = {}));
const logLevelMap = {
    [LogLevel.Warning]: 1,
    [LogLevel.Info]: 2,
    [LogLevel.Debug]: 3,
    [LogLevel.Error]: 0,
    [LogLevel.Disabled]: -1,
};
const DEFAULT_LOG_LEVEL = logLevelMap[LogLevel.Warning];
let logLevel = typeof process === "undefined"
    ? DEFAULT_LOG_LEVEL
    : (_a$1 = logLevelMap[process.env.LOG_LEVEL]) !== null && _a$1 !== void 0 ? _a$1 : DEFAULT_LOG_LEVEL;
function setLogLevel(level) {
    if (typeof level === "number") {
        console.warn("Passing a number is deprecated, please use LogLevel enum instead");
        logLevel = level;
        return;
    }
    logLevel = logLevelMap[level];
}
function getLogLevel() {
    return logLevel;
}
function debug(message, moduleName) {
    if (logLevel >= 3) {
        emitLogMessage({
            message,
            moduleName,
            msgType: MsgType.Debug,
            color: LogColor.Blue,
        });
    }
}
function info(message, moduleName) {
    if (logLevel >= 2) {
        emitLogMessage({
            message,
            moduleName,
            msgType: MsgType.Info,
            color: LogColor.Green,
        });
    }
}
function error(message, moduleName) {
    if (logLevel != -1) {
        emitLogMessage({
            message,
            moduleName,
            msgType: MsgType.Error,
            color: LogColor.Red,
        });
    }
}
function warning(message, moduleName) {
    if (logLevel >= 1) {
        emitLogMessage({
            message,
            moduleName,
            msgType: MsgType.Warning,
            color: LogColor.Yellow,
        });
    }
}
function emitLogMessage({ msgType, message, color, moduleName, }) {
    const time = getTimestamp();
    const moduleNameMessage = moduleName ? `[${moduleName}]` : "";
    console.log(`[${time}] ${color}${msgType}:${LogColor.StopColor} ${moduleNameMessage} ${message}`);
}
function getTimestamp() {
    const pad = (n, s = 2) => `${new Array(s).fill(0)}${n}`.slice(-s);
    const date = new Date();
    return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}:${pad(date.getMilliseconds(), 3)}`;
}
function logger(moduleName) {
    return {
        debug: (message) => debug(message, moduleName),
        info,
        error,
        warning,
        setLogLevel,
        disable: () => setLogLevel(logLevelMap[LogLevel.Disabled]),
    };
}

var logger$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get LogLevel () { return LogLevel; },
	debug: debug,
	error: error,
	getLogLevel: getLogLevel,
	info: info,
	logger: logger,
	setLogLevel: setLogLevel,
	warning: warning
});

var __awaiter$b = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createClient$1(restApiClient, blockchainRid, functionNames) {
    functionNames.push("message");
    function transaction(gtx$1) {
        return {
            gtx: gtx$1,
            sign: function (privOrSigProv, pubKey) {
                return __awaiter$b(this, void 0, void 0, function* () {
                    debug(`signing transaction with ${privOrSigProv instanceof require$$0$1.Buffer
                        ? `privkey: ${privOrSigProv.toString("hex")}`
                        : `signature provider [pubKey: ${privOrSigProv.pubKey}]`}`);
                    if (privOrSigProv instanceof require$$0$1.Buffer) {
                        yield sign(this.gtx, privOrSigProv, pubKey);
                    }
                    else {
                        yield sign(this.gtx, privOrSigProv);
                    }
                });
            },
            getTxRID: function () {
                return this.getDigestToSign();
            },
            getDigestToSign: function () {
                return getDigestToSign(this.gtx);
            },
            addSignature: function (pubKey, signature) {
                addSignature(pubKey, signature, this.gtx);
            },
            // raw call
            addOperation: function (name, ...args) {
                addTransactionToGtx(name, args, this.gtx);
            },
            postAndWaitConfirmation() {
                return restApiClient.postAndWaitConfirmation(serialize(this.gtx), this.getTxRID());
            },
            send: function (callback) {
                const gtxBytes = serialize(this.gtx);
                restApiClient.postTransaction(gtxBytes, callback);
                this.gtx = null;
                this.gtxBytes = gtxBytes;
            },
            encode: function () {
                return serialize(this.gtx);
            },
        };
    }
    function addFunctions(req) {
        functionNames.forEach((functionName) => {
            req[functionName] = function (...args) {
                addTransactionToGtx(functionName, args, this.gtx);
            };
        });
    }
    const client = {
        newTransaction: function (signers) {
            signers = removeDuplicateSigners(signers);
            const newGtx = emptyGtx(require$$0$1.Buffer.from(blockchainRid, "hex"));
            signers.forEach((signer) => addSignerToGtx(signer, newGtx));
            const req = transaction(newGtx);
            addFunctions(req);
            return req;
        },
        transactionFromRawTransaction: function (rawTransaction) {
            const gtx$1 = deserialize(rawTransaction);
            debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
            const req = transaction(gtx$1);
            addFunctions(req);
            return req;
        },
        query: function (nameOrObject, queryArguments) {
            if (typeof nameOrObject === "string") {
                return restApiClient.query(nameOrObject, queryArguments);
            }
            else {
                return restApiClient.query(nameOrObject);
            }
        },
    };
    return client;
}

var gtxclient = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createClient: createClient$1
});

var ResponseStatus;
(function (ResponseStatus) {
    ResponseStatus["Confirmed"] = "confirmed";
    ResponseStatus["Rejected"] = "rejected";
    ResponseStatus["Unknown"] = "unknown";
    ResponseStatus["Waiting"] = "waiting";
})(ResponseStatus || (ResponseStatus = {}));

class TxRejectedError extends Error {
    constructor(rejectReason) {
        super(`Transaction was rejected, ${rejectReason}`);
        this.name = "TxRejectedError";
        this.fullReason = rejectReason;
        const result = matchRellErrorString(rejectReason);
        this.shortReason = result.shortReason;
        this.rellLine = result.rellLine;
        this.operation = result.operation;
    }
}
class UnexpectedStatusError extends CustomError {
    constructor(status, error) {
        let errorMessage = `Unexpected status code from server. Code: ${status}.`;
        if (status === null) {
            super(errorMessage, 500); // default status code
        }
        else {
            if (error) {
                errorMessage += ` Message: ${error}.`;
            }
            super(errorMessage, status);
        }
    }
}
class LostMessageError extends Error {
    constructor() {
        super(`Server lost our message`);
    }
}
class UnexpectedResponseError extends Error {
    constructor() {
        super(`got unexpected response from server`);
    }
}
class InvalidTxRidException extends CustomError {
    constructor(txRID) {
        super(`expected length 32 of txRID, but got ${txRID && txRID.length}`, 400);
    }
}
class SerializedTransactionFormatException extends CustomError {
    constructor() {
        super(`messageHash is not a Buffer`, 400);
    }
}
class GetBridFromChainException extends Error {
    constructor(chainId, reason) {
        super(`Error resolving BRID for chainId ${chainId}, reason: ${reason}`);
    }
}
class EmptyListOfUrlsException extends CustomError {
    constructor() {
        super(`Failed to initialize rest client with empty list of urls`, 400);
    }
}
class InvalidBlockchainRIDException extends CustomError {
    constructor() {
        super(`Failed to initialize rest client with blockchain RID that is not 32 bytes`, 400);
    }
}

var Method;
(function (Method) {
    Method["GET"] = "get";
    Method["POST"] = "post";
})(Method || (Method = {}));

var __awaiter$a = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function handleRequest(method, path, endpoint, postObject) {
    return __awaiter$a(this, void 0, void 0, function* () {
        if (method == Method.GET) {
            return yield get(path, endpoint);
        }
        else {
            return yield post(path, endpoint, postObject);
        }
    });
}
/**
 * Sends request to get data from a given API endpoint.
 * @param path API endpoint of Rell backend
 * @param endpoint
 */
function get(path, endpoint) {
    return __awaiter$a(this, void 0, void 0, function* () {
        debug(`GET URL ${new URL(path, endpoint).href}`);
        try {
            const response = yield fetch(new URL(path, endpoint).href);
            const contentType = response.headers.get("Content-Type");
            let rspBody;
            if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
                rspBody = yield response.json();
            }
            else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/plain")) {
                rspBody = yield response.text();
            }
            return {
                error: null,
                statusCode: response.status,
                rspBody,
            };
        }
        catch (error$1) {
            error(error$1.message);
            return { error: error$1, statusCode: null, rspBody: null };
        }
    });
}
/**
 * Sends request to post data to a given API endpoint.
 * @param path API endpoint of Rell backend
 * @param endpoint
 * @param requestBody request body
 */
function post(path, endpoint, requestBody) {
    return __awaiter$a(this, void 0, void 0, function* () {
        debug(`POST URL ${new URL(path, endpoint).href}`);
        debug(`POST body ${JSON.stringify(requestBody)}`);
        if (require$$0$1.Buffer.isBuffer(requestBody)) {
            try {
                const requestOptions = {
                    method: "post",
                    body: requestBody,
                    headers: {
                        Accept: "application/octet-stream",
                        "Content-Type": "application/octet-stream",
                    },
                };
                const response = yield fetch(new URL(path, endpoint).href, requestOptions);
                return {
                    error: null,
                    statusCode: response.status,
                    rspBody: decodeValue(require$$0$1.Buffer.from(yield response.arrayBuffer())),
                };
            }
            catch (error) {
                return { error, statusCode: null, rspBody: null };
            }
        }
        else {
            try {
                const response = yield fetch(new URL(path, endpoint).href, {
                    method: "post",
                    body: JSON.stringify(requestBody),
                });
                return {
                    error: null,
                    statusCode: response.status,
                    rspBody: yield response.json(),
                };
            }
            catch (error) {
                return { error, statusCode: null, rspBody: null };
            }
        }
    });
}

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const hasClientError = (statusCode) => statusCode >= 400 && statusCode < 500;
const hasServerError = (statusCode) => statusCode >= 500 && statusCode < 600;
function abortOnError({ method, path, config, postObject, }) {
    return __awaiter$9(this, void 0, void 0, function* () {
        return yield retryRequest({
            method,
            path,
            config,
            postObject,
            validateStatusCode: (statuscode) => !hasServerError(statuscode),
        });
    });
}
function tryNextOnError({ method, path, config, postObject, }) {
    return __awaiter$9(this, void 0, void 0, function* () {
        return yield retryRequest({
            method,
            path,
            config,
            postObject,
            validateStatusCode: (statusCode) => !hasClientError(statusCode) && !hasServerError(statusCode),
        });
    });
}
function singleEndpoint({ method, path, config, postObject, }) {
    return __awaiter$9(this, void 0, void 0, function* () {
        let statusCode, rspBody, error;
        for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
            const endpoint = nextEndpoint(config.endpointPool);
            ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
            const isError = statusCode
                ? hasServerError(statusCode) || hasClientError(statusCode)
                : false;
            if (!isError && !error) {
                return { error, statusCode, rspBody };
            }
            info(`${method} request failed on ${config.endpointPool[0]}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
            yield sleep(config.attemptInterval);
        }
        // TS issue. Variable 'error' is used before being assigned.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return { error, statusCode, rspBody };
    });
}
function retryRequest({ method, path, config, postObject, validateStatusCode, }) {
    return __awaiter$9(this, void 0, void 0, function* () {
        let statusCode;
        let rspBody;
        let error;
        const reachableEndpoints = filterReachableEndpoint(config.endpointPool);
        if (reachableEndpoints.length < bftMajority(config.endpointPool.length)) {
            setEndpointAsReachable(config.endpointPool);
        }
        for (const endpoint of shuffle(config.endpointPool)) {
            if (isReachable(endpoint)) {
                for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
                    ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
                    const isStatusCodeValid = statusCode
                        ? validateStatusCode(statusCode)
                        : false;
                    const isServerError = statusCode ? hasServerError(statusCode) : false;
                    if (isStatusCodeValid && !error) {
                        return { error, statusCode, rspBody };
                    }
                    if (isServerError) {
                        setUnavailable(endpoint, config.unreachableDuration);
                    }
                    info(`${method} request failed on ${endpoint}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
                    yield sleep(config.attemptInterval);
                }
            }
        }
        // TS issue. Variable 'error' is used before being assigned.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return { error, statusCode, rspBody };
    });
}

class MissingPubKeyError extends CustomError {
    constructor() {
        super(`No public key was provided`, 400);
    }
}
class MissingBlockchainIdentifierError extends CustomError {
    constructor() {
        super(`No blockchain identifier was provided. Include either a blockchainRid (string) or a blockchainIid (number).`, 400);
    }
}
class MissingNodeUrlError extends CustomError {
    constructor() {
        super(`No node url or directory node url was provided. Include either a nodeUrl (string) or a directory node url (number).`, 400);
    }
}
class BlockchainUrlUndefinedException extends CustomError {
    constructor(brid) {
        const idType = typeof brid === "string" ? "BRID" : "IID";
        super(`Cannot find nodes hosting the blockchain with ${idType} ${brid}`, 400);
    }
}
class DirectoryNodeUrlPoolException extends CustomError {
    constructor() {
        super(`No directory node url was provided`, 400);
    }
}
class InvalidTransactionFormatException extends CustomError {
    constructor() {
        super(`The transaction is not in the right format`, 400);
    }
}
class GetTransactionRidException extends CustomError {
    constructor(error) {
        super(`"Error occurred while getting transaction RID:", ${error}`, 400);
    }
}

/*
This file is part of web3.js.

web3.js is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

web3.js is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
class Web3EventEmitter {
    constructor() {
        this._emitter = new events.EventEmitter();
    }
    on(eventName, fn) {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this._emitter.on(eventName, fn);
    }
    once(eventName, fn) {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this._emitter.once(eventName, fn);
    }
    off(eventName, fn) {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this._emitter.off(eventName, fn);
    }
    emit(eventName, params) {
        this._emitter.emit(eventName, params);
    }
    listenerCount(eventName) {
        return this._emitter.listenerCount(eventName);
    }
    listeners(eventName) {
        return this._emitter.listeners(eventName);
    }
    eventNames() {
        return this._emitter.eventNames();
    }
    removeAllListeners() {
        this._emitter.removeAllListeners();
    }
    setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
        this._emitter.setMaxListeners(maxListenersWarningThreshold);
    }
    getMaxListeners() {
        return this._emitter.getMaxListeners();
    }
}

/*
This file is part of web3.js.

web3.js is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

web3.js is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
class Web3PromiEvent extends Web3EventEmitter {
    constructor(executor) {
        super();
        // public tag to treat object as promise by different libs
        // eslint-disable-next-line @typescript-eslint/prefer-as-const
        this[_a] = "Promise";
        this._promise = new Promise(executor);
    }
    then(onfulfilled, onrejected) {
        return __awaiter$8(this, void 0, void 0, function* () {
            return this._promise.then(onfulfilled, onrejected);
        });
    }
    catch(onrejected) {
        return __awaiter$8(this, void 0, void 0, function* () {
            return this._promise.catch(onrejected);
        });
    }
    finally(onfinally) {
        return __awaiter$8(this, void 0, void 0, function* () {
            return this._promise.finally(onfinally);
        });
    }
    on(eventName, fn) {
        super.on(eventName, fn);
        return this;
    }
    once(eventName, fn) {
        super.once(eventName, fn);
        return this;
    }
}
_a = Symbol.toStringTag;

exports.FailoverStrategy = void 0;
(function (FailoverStrategy) {
    FailoverStrategy["AbortOnError"] = "abortOnError";
    FailoverStrategy["TryNextOnError"] = "tryNextOnError";
    FailoverStrategy["SingleEndpoint"] = "singleEndpoint";
})(exports.FailoverStrategy || (exports.FailoverStrategy = {}));
exports.ResponseStatus = void 0;
(function (ResponseStatus) {
    ResponseStatus["Confirmed"] = "confirmed";
    ResponseStatus["Rejected"] = "rejected";
    ResponseStatus["Unknown"] = "unknown";
    ResponseStatus["Waiting"] = "waiting";
})(exports.ResponseStatus || (exports.ResponseStatus = {}));

const WRONG_STRING_LENGTH = "wrong string length";
const BlockIdentifierSchema = zod.z.union([
    zod.z
        .string()
        .refine((val) => /^[0-9a-fA-F]{64}$/.test(val), WRONG_STRING_LENGTH),
    zod.z.number(),
]);
const isBlockIdentifierValid = (blockIdentifier, options) => {
    const ctx = BlockIdentifierSchema.safeParse(blockIdentifier);
    const { success } = ctx;
    const hasError = "error" in ctx;
    const { throwOnError = false } = options || {};
    if (!hasError) {
        return { success };
    }
    const { error } = ctx;
    const isInvalidInputType = error.issues.some(({ code }) => code === "invalid_union");
    const isInvalidStringLength = error.issues.some(({ message }) => message === WRONG_STRING_LENGTH);
    const message = (() => {
        if (isInvalidInputType) {
            return `Invalid "blockIdentifier" type. Expected string or number, but received ${typeof blockIdentifier}.`;
        }
        if (isInvalidStringLength) {
            return "Parameter 'blockIdentifier' does not have the correct format (64-character hexadecimal string).";
        }
        return error.issues.map((issue) => issue.message).join(", ");
    })();
    if (throwOnError) {
        throw new Error(message);
    }
    return {
        success,
        error,
        message: error.issues.map((issue) => issue.message).join(", "),
    };
};

const IdentifierSchema = zod.z.union([
    zod.z.object({
        blockchainRid: zod.z.undefined(),
        blockchainIid: zod.z.number(),
    }),
    zod.z.object({
        blockchainRid: zod.z.string(),
        blockchainIid: zod.z.undefined(),
    }),
]);
const NodeUrlSchema = zod.z.union([
    zod.z.object({
        nodeUrlPool: zod.z.union([zod.z.string(), zod.z.array(zod.z.string())]),
        directoryNodeUrlPool: zod.z.undefined(),
    }),
    zod.z.object({
        nodeUrlPool: zod.z.undefined(),
        directoryNodeUrlPool: zod.z.union([zod.z.string(), zod.z.array(zod.z.string())]),
    }),
]);
const RestNetworkSettingsSchema = zod.z.object({
    statusPollingInterval: zod.z.number().optional(),
    statusPollingCount: zod.z.number().optional(),
    failOverConfig: zod.z
        .object({
        strategy: zod.z.nativeEnum(exports.FailoverStrategy).optional(),
        attemptsPerEndpoint: zod.z.number().optional(),
        attemptInterval: zod.z.number().optional(),
        unreachableDuration: zod.z.number().optional(),
    })
        .optional(),
});
const validateBlockChainIdentifier = (networkSettings, options) => {
    const { throwOnError = false } = options || {};
    const identifierValidationContext = IdentifierSchema.safeParse(networkSettings);
    if ("error" in identifierValidationContext) {
        const missingBlockchainIdentifierError = new MissingBlockchainIdentifierError();
        if (throwOnError) {
            throw missingBlockchainIdentifierError;
        }
        return {
            success: identifierValidationContext.success,
            error: identifierValidationContext.error,
            message: missingBlockchainIdentifierError.message,
        };
    }
    return { success: true };
};
const validateNodeUrl = (networkSettings, options) => {
    const { throwOnError = false } = options || {};
    const nodeUrlValidationContext = NodeUrlSchema.safeParse(networkSettings);
    if ("error" in nodeUrlValidationContext) {
        const missingNodeUrlError = new MissingNodeUrlError();
        if (throwOnError) {
            throw missingNodeUrlError;
        }
        return {
            success: nodeUrlValidationContext.success,
            error: nodeUrlValidationContext.error,
            message: missingNodeUrlError.message,
        };
    }
    return { success: true };
};
const validateRestNetworkSettings = (networkSettings, options) => {
    const { throwOnError = false } = options || {};
    const restNetworkSettingsValidationContext = RestNetworkSettingsSchema.safeParse(networkSettings);
    if ("error" in restNetworkSettingsValidationContext) {
        const { error: { issues }, } = restNetworkSettingsValidationContext;
        const errorMessage = issues
            .map(({ message, path }) => `${path[0]}: ${message}`)
            .join(", ");
        if (throwOnError) {
            throw new Error(errorMessage);
        }
        return {
            success: restNetworkSettingsValidationContext.success,
            error: restNetworkSettingsValidationContext.error,
            message: errorMessage,
        };
    }
    return { success: true };
};
const isNetworkSettingValid = (networkSettings, options) => {
    const identifierValidationContext = validateBlockChainIdentifier(networkSettings, options);
    if ("error" in identifierValidationContext) {
        return identifierValidationContext;
    }
    const nodeUrlValidationContext = validateNodeUrl(networkSettings, options);
    if ("error" in nodeUrlValidationContext) {
        return nodeUrlValidationContext;
    }
    const restNetworkSettingsValidationContext = validateRestNetworkSettings(networkSettings, options);
    if ("error" in restNetworkSettingsValidationContext) {
        return restNetworkSettingsValidationContext;
    }
    return { success: true };
};

const BufferSchema = zod.z.union([
    zod.z.instanceof(Uint8Array),
    zod.z.instanceof(Buffer),
]);

const KeyPairSchema = zod.z.object({
    privKey: BufferSchema,
    pubKey: BufferSchema,
});
const SignatureProviderSchema = zod.z.object({
    pubKey: BufferSchema,
    sign: zod.z.function().args(BufferSchema).returns(zod.z.promise(BufferSchema)),
});
const SignMethodSchema = zod.z.union([
    KeyPairSchema,
    SignatureProviderSchema,
]);
const isSignMethodValid = (signMethod, options) => {
    const signMethodValidationCtx = SignMethodSchema.safeParse(signMethod);
    const { throwOnError = false } = options || {};
    const hasError = "error" in signMethodValidationCtx;
    if (!hasError) {
        return { success: true };
    }
    const message = "Invalid sign method";
    if (throwOnError) {
        throw new Error(message);
    }
    return {
        success: false,
        error: signMethodValidationCtx.error,
        message,
    };
};

const TxRidSchema = BufferSchema.refine((x) => x.length === 32, "Rid must be 32 bytes long");
const isTxRidValid = (rid, options) => {
    const TxRidValidationContext = TxRidSchema.safeParse(rid);
    const { throwOnError = false } = options || {};
    const hasError = "error" in TxRidValidationContext;
    if (!hasError) {
        return { success: true };
    }
    const validationError = new InvalidTxRidException(rid);
    if (throwOnError) {
        throw validationError;
    }
    return {
        success: false,
        error: TxRidValidationContext.error,
        message: validationError.message,
    };
};

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createClient(settings) {
    return __awaiter$7(this, void 0, void 0, function* () {
        isNetworkSettingValid(settings, { throwOnError: true });
        return {
            config: yield getClientConfigFromSettings(settings),
            query(nameOrQueryObject, args, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    let _name, _args;
                    if (typeof nameOrQueryObject === "string") {
                        _name = nameOrQueryObject;
                        _args = args;
                    }
                    else {
                        _name = nameOrQueryObject === null || nameOrQueryObject === void 0 ? void 0 : nameOrQueryObject.name;
                        _args = nameOrQueryObject === null || nameOrQueryObject === void 0 ? void 0 : nameOrQueryObject.args;
                    }
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `query_gtv/${this.config.blockchainRid}`, this.config, encodeValue(toQueryObjectGTV(_name, _args)));
                    return new Promise((resolve, reject) => {
                        handlePostResponse(error, statusCode, rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            signTransaction(transaction, signMethod, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    debug(`Signing transaction with ${!isKeyPair(signMethod) ? "signature provider containing " : ""}pubKey: ${toString(signMethod.pubKey)}`);
                    const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
                    try {
                        const signedTx = yield (isKeyPair(signMethod)
                            ? sign(gtx$1, signMethod.privKey, signMethod.pubKey)
                            : sign(gtx$1, signMethod));
                        const gtxBytes = getSerializedGTX(signedTx);
                        if (typeof callback === "function") {
                            callback(null, gtxBytes);
                        }
                        return gtxBytes;
                    }
                    catch (error) {
                        if (typeof callback === "function") {
                            callback(error, null);
                        }
                        throw new Error(error);
                    }
                });
            },
            sendTransaction(transaction, doStatusPolling = true, callback = undefined) {
                const promiEvent = new Web3PromiEvent((resolve, reject) => __awaiter$7(this, void 0, void 0, function* () {
                    var _a;
                    try {
                        const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
                        if (gtx$1.signers.length !== ((_a = gtx$1.signatures) === null || _a === void 0 ? void 0 : _a.length)) {
                            reject(new NumberOfSignersAndSignaturesException());
                        }
                        const gtxBytes = getSerializedGTX(gtx$1);
                        const transactionObject = {
                            tx: gtxBytes.toString("hex"),
                        };
                        const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `tx/${this.config.blockchainRid}`, this.config, transactionObject);
                        const transactionRid = getDigestToSign(gtx$1);
                        try {
                            yield handlePostResponsePromisified(error, statusCode, rspBody);
                            if (typeof callback === "function") {
                                callback(null, {
                                    status: exports.ResponseStatus.Waiting,
                                    statusCode,
                                    transactionRid: transactionRid,
                                });
                            }
                        }
                        catch (_error) {
                            if (typeof callback === "function") {
                                callback(_error, null);
                            }
                            return reject(_error);
                        }
                        const transactionReceipt = {
                            status: exports.ResponseStatus.Waiting,
                            statusCode: statusCode,
                            transactionRid: transactionRid,
                        };
                        promiEvent.emit("sent", transactionReceipt);
                        if (doStatusPolling === false) {
                            return resolve(transactionReceipt);
                        }
                        const awaitConfirmation = (txRID) => __awaiter$7(this, void 0, void 0, function* () {
                            var _b;
                            let lastKnownResult;
                            for (let i = 0; i < this.config.statusPollCount; i++) {
                                lastKnownResult = yield this.getTransactionStatus(txRID);
                                if (lastKnownResult.status === exports.ResponseStatus.Confirmed) {
                                    return exports.ResponseStatus.Confirmed;
                                }
                                else if (lastKnownResult.status === exports.ResponseStatus.Rejected) {
                                    throw new TxRejectedError((_b = lastKnownResult.rejectReason) !== null && _b !== void 0 ? _b : "");
                                }
                                yield sleep(this.config.statusPollInterval);
                            }
                            // TS issue. This could be fixed by inplementing new retry strategy
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            //@ts-expect-error
                            return lastKnownResult.status;
                        });
                        const confirmationStatus = yield awaitConfirmation(getDigestToSign(gtx$1));
                        resolve({
                            status: confirmationStatus,
                            statusCode: statusCode,
                            transactionRid: transactionRid,
                        });
                    }
                    catch (error) {
                        reject(error);
                    }
                }));
                return promiEvent;
            },
            signAndSendUniqueTransaction(transactionOrOperation, signMethod, doStatusPolling = true, callback = undefined) {
                isSignMethodValid(signMethod, { throwOnError: true });
                const promiEvent = new Web3PromiEvent((resolve, reject) => {
                    const transaction = "name" in transactionOrOperation
                        ? {
                            operations: [transactionOrOperation],
                            signers: [signMethod.pubKey],
                        }
                        : transactionOrOperation;
                    const hasNop = transaction.operations.some((operation) => {
                        return operation.name === "nop";
                    });
                    const transactionWithNop = hasNop
                        ? transaction
                        : this.addNop(transaction);
                    this.signTransaction(transactionWithNop, signMethod)
                        .then((signedTx) => {
                        const sendTransactionPromiEvent = this.sendTransaction(signedTx, doStatusPolling, callback);
                        sendTransactionPromiEvent.on("sent", (receipt) => {
                            promiEvent.emit("sent", receipt);
                        });
                        resolve(sendTransactionPromiEvent);
                    })
                        .catch((error) => {
                        reject(error);
                    });
                });
                return promiEvent;
            },
            getTransaction(transactionRid, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    try {
                        isTxRidValid(transactionRid, { throwOnError: true });
                    }
                    catch (error) {
                        callback === null || callback === void 0 ? void 0 : callback(error, null);
                        throw error;
                    }
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${transactionRid.toString("hex")}`, this.config);
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 ? toBuffer(rspBody.tx) : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getTransactionStatus(transactionRid, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    try {
                        isTxRidValid(transactionRid, { throwOnError: true });
                    }
                    catch (error) {
                        callback === null || callback === void 0 ? void 0 : callback(error, null);
                        throw error;
                    }
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${transactionRid.toString("hex")}/status`, this.config);
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            addNop(transaction) {
                const _transaction = cloneDeep(transaction);
                const noOperation = {
                    name: "nop",
                    args: [crypto.randomBytes(32)],
                };
                _transaction.operations = [..._transaction.operations, noOperation];
                return _transaction;
            },
            getTransactionRid(transaction) {
                try {
                    const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
                    return getDigestToSign(gtx$1);
                }
                catch (e) {
                    throw new GetTransactionRidException(e);
                }
            },
            getTransactionsInfo(limit = 25, beforeTime, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    const beforeTimeQueryParam = beforeTime
                        ? `&before-time=${beforeTime.getTime()}`
                        : "";
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}?limit=${limit}${beforeTimeQueryParam}`, this.config);
                    const body = statusCode === 200
                        ? rspBody === null || rspBody === void 0 ? void 0 : rspBody.map(formatTransactionInfoResponse)
                        : rspBody;
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, body, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getTransactionInfo(transactionRid, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    try {
                        isTxRidValid(transactionRid, { throwOnError: true });
                    }
                    catch (error) {
                        callback === null || callback === void 0 ? void 0 : callback(error, null);
                        throw error;
                    }
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}/${toString(transactionRid)}`, this.config);
                    const body = statusCode === 200 && rspBody
                        ? formatTransactionInfoResponse(rspBody)
                        : rspBody;
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, body, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getTransactionCount(callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}/count`, this.config);
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 ? rspBody.transactionsCount : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getBlockInfo(blockIdentifier, txs = false, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    isBlockIdentifierValid(blockIdentifier, { throwOnError: true });
                    const queryString = typeof blockIdentifier === "string"
                        ? blockIdentifier
                        : `height/${blockIdentifier}`;
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}/${queryString}?txs=${txs}`, this.config);
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody !== null && rspBody
                            ? formatBlockInfoResponse(rspBody)
                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getLatestBlock(txs = false, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    const shouldIncludeFullTransaction = txs ? `&txs=${txs}` : "";
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}?limit=1${shouldIncludeFullTransaction}`, this.config);
                    const indexOfLatestBlock = 0;
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody !== null && rspBody
                            ? formatBlockInfoResponse(rspBody[indexOfLatestBlock])
                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            getBlocksInfo(limit = 25, beforeTime, beforeHeight, txs, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    let filteringQueryParam = "";
                    if (beforeTime) {
                        filteringQueryParam = `&before-time=${beforeTime.getTime()}`;
                    }
                    else if (beforeHeight) {
                        filteringQueryParam = `&before-height=${beforeHeight}`;
                    }
                    const shouldIncludeFullTransaction = txs ? `&txs=${txs}` : "";
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}?limit=${limit}${filteringQueryParam}${shouldIncludeFullTransaction}`, this.config);
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody
                            ? rspBody.map(formatBlockInfoResponse)
                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
            encodeTransaction(transaction) {
                const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
                return serialize(gtx$1);
            },
            decodeTransactionToGtx(encodedTransaction) {
                const gtx$1 = deserialize(encodedTransaction);
                debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
                return gtx$1;
            },
            getClientNodeUrlPool() {
                return this.config.endpointPool.map((endpoint) => endpoint.url);
            },
            /**
             * Retrieves a confirmation proof for a transaction with the specified sha256
             * hash.
             * @param txRid A buffer of 32 bytes
             * @param callback parameters (error, responseObjectProof) if first
             * parameter is not null, an error occurred.
             * If first parameter is null, then the second parameter is an object
             * like the following:
             *
             * {hash: messageHashBuffer,
             *  blockHeader: blockHeaderBuffer,
             *  signatures: [{pubKey: pubKeyBuffer, signature: sigBuffer}, ...],
             *  merklePath: [{side: <0|1>, hash: <hash buffer level n-1>},
             *               ...
             *               {side: <0|1>, hash: <hash buffer level 1>}]}
             *
             * If no such transaction RID exists, the callback will be called with (null, null).
             *
             * The proof object can be validated using
             * postchain-common.util.validateMerklePath(proof.merklePath, proof.hash,
             * proof.blockHeader.slice(32, 64))
             *
             * The signatures must be validated agains some know trusted source for valid signers
             * at this specific block height.
             */
            getConfirmationProof: function (txRid, callback) {
                return __awaiter$7(this, void 0, void 0, function* () {
                    try {
                        isTxRidValid(txRid, { throwOnError: true });
                    }
                    catch (error) {
                        callback === null || callback === void 0 ? void 0 : callback(error, null);
                        throw error;
                    }
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${txRid.toString("hex")}/confirmationProof`, this.config);
                    const confirmationProof = {
                        merkleProofTree: "",
                        txIndex: 0,
                    };
                    if (statusCode === 200) {
                        try {
                            const decodedProof = decodeValue(toBuffer(rspBody.proof));
                            confirmationProof.txIndex = decodedProof.txIndex;
                            confirmationProof.hash = decodedProof.hash;
                            confirmationProof.blockHeader = decodedProof.blockHeader;
                            confirmationProof.witness = decodedProof.witness;
                            confirmationProof.merkleProofTree = decodedProof.merkleProofTree;
                        }
                        catch (decodeError) {
                            if (callback) {
                                callback(decodeError, null);
                            }
                            throw decodeError;
                        }
                    }
                    return new Promise((resolve, reject) => {
                        handleGetResponse(error, statusCode, statusCode === 200 ? confirmationProof : rspBody, callbackPromiseBuilder(reject, resolve, callback));
                    });
                });
            },
        };
    });
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getClientConfigFromSettings(settings) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter$6(this, void 0, void 0, function* () {
        const nodeUrlPoolToUse = yield getNodeUrlsFromSettings(settings);
        if (nodeUrlPoolToUse.length === 0) {
            const id = (_b = (_a = settings.blockchainRid) !== null && _a !== void 0 ? _a : settings.blockchainIid) !== null && _b !== void 0 ? _b : "Unknown";
            throw new BlockchainUrlUndefinedException(id);
        }
        const endpointPool = createEndpointObjects(nodeUrlPoolToUse);
        const blockchainRidToUse = yield (() => __awaiter$6(this, void 0, void 0, function* () {
            if (settings.blockchainRid) {
                return settings.blockchainRid;
            }
            if (settings.blockchainIid !== undefined) {
                return yield getBlockchainRidFromIid(endpointPool, settings.blockchainIid);
            }
            throw new MissingBlockchainIdentifierError();
        }))();
        return {
            endpointPool,
            blockchainRid: blockchainRidToUse,
            statusPollInterval: settings.statusPollInterval || 500,
            statusPollCount: settings.statusPollCount || 20,
            failoverStrategy: ((_c = settings.failOverConfig) === null || _c === void 0 ? void 0 : _c.strategy) || defaultFailoverConfig.strategy,
            attemptsPerEndpoint: ((_d = settings.failOverConfig) === null || _d === void 0 ? void 0 : _d.attemptsPerEndpoint) ||
                defaultFailoverConfig.attemptsPerEndpoint,
            attemptInterval: ((_e = settings.failOverConfig) === null || _e === void 0 ? void 0 : _e.attemptInterval) ||
                defaultFailoverConfig.attemptInterval,
            unreachableDuration: ((_f = settings.failOverConfig) === null || _f === void 0 ? void 0 : _f.unreachableDuration) ||
                defaultFailoverConfig.unreachableDuration,
        };
    });
}
function nodeDiscovery(directoryEndpointPool, failOverConfig, blockchainRid, blockchainIid) {
    return __awaiter$6(this, void 0, void 0, function* () {
        if (directoryEndpointPool.length === 0) {
            throw new DirectoryNodeUrlPoolException();
        }
        if (!blockchainRid && blockchainIid === undefined) {
            throw new MissingBlockchainIdentifierError();
        }
        const directoryIid = 0;
        const directoryBRID = yield getBlockchainRidFromIid(directoryEndpointPool, directoryIid, failOverConfig);
        const blockchainRidToUse = yield (() => __awaiter$6(this, void 0, void 0, function* () {
            if (blockchainRid) {
                return blockchainRid;
            }
            if (blockchainIid !== undefined) {
                return yield getBlockchainRidFromIid(directoryEndpointPool, blockchainIid, failOverConfig);
            }
            throw new MissingBlockchainIdentifierError();
        }))();
        const queryObject = {
            name: "cm_get_blockchain_api_urls",
            args: { blockchain_rid: toBuffer(blockchainRidToUse) },
        };
        const D1Client = yield createClient({
            nodeUrlPool: getUrlsFromEndpoints(directoryEndpointPool),
            blockchainRid: directoryBRID,
        });
        const baseUrls = yield D1Client.query(queryObject);
        return baseUrls;
    });
}
function convertToRellOperation(operations) {
    return operations.map((operation) => {
        var _a;
        return {
            opName: operation.name,
            args: (_a = operation.args) !== null && _a !== void 0 ? _a : [],
        };
    });
}
function getSerializedGTX(gtx$1) {
    const gtxBytes = serialize(gtx$1);
    if (!require$$0$1.Buffer.isBuffer(gtxBytes)) {
        throw new SerializedTransactionFormatException();
    }
    return gtxBytes;
}
function getGTXFromBufferOrTransactionOrOperation(transaction, blockchainRid) {
    if (require$$0$1.Buffer.isBuffer(transaction)) {
        return deserialize(transaction);
    }
    else if ("operations" in transaction) {
        return {
            blockchainRid: toBuffer(blockchainRid),
            operations: convertToRellOperation(transaction.operations),
            signers: transaction.signers,
            signatures: [],
        };
    }
    else if ("name" in transaction) {
        return {
            blockchainRid: toBuffer(blockchainRid),
            operations: convertToRellOperation([transaction]),
            signers: [],
            signatures: [],
        };
    }
    else {
        throw new InvalidTransactionFormatException();
    }
}
const callbackPromiseBuilder = (reject, resolve, callback) => {
    return (error, result) => {
        if (error) {
            if (typeof callback === "function") {
                callback(error, null);
            }
            reject(error);
        }
        else {
            if (typeof callback === "function") {
                callback(null, result);
            }
            resolve(result);
        }
    };
};
const handlePostResponsePromisified = (error, statusCode, rspBody) => {
    return new Promise((resolve, reject) => {
        handlePostResponse(error, statusCode, rspBody, (_error) => {
            if (_error) {
                reject(_error);
            }
            else {
                resolve();
            }
        });
    });
};
function ensureArray(input) {
    if (typeof input === "string") {
        return [input];
    }
    return input;
}
const formatTransactionInfoResponse = (transactionInfoResponse) => {
    return {
        blockRid: toBuffer(transactionInfoResponse.blockRID),
        blockHeight: transactionInfoResponse.blockHeight,
        blockHeader: toBuffer(transactionInfoResponse.blockHeader),
        witness: toBuffer(transactionInfoResponse.witness),
        timestamp: transactionInfoResponse.timestamp,
        txRid: toBuffer(transactionInfoResponse.txRID),
        txHash: toBuffer(transactionInfoResponse.txHash),
        txData: toBuffer(transactionInfoResponse.txData),
    };
};
const formatBlockInfoResponse = (blockInfoResponse) => {
    return {
        rid: toBuffer(blockInfoResponse.rid),
        prevBlockRid: toBuffer(blockInfoResponse.prevBlockRID),
        header: toBuffer(blockInfoResponse.header),
        transactions: blockInfoResponse.transactions.map(formatTransaction),
        height: blockInfoResponse.height,
        witness: toBuffer(blockInfoResponse.witness),
        witnesses: blockInfoResponse.witnesses.map((witness) => {
            return toBuffer(witness);
        }),
        timestamp: blockInfoResponse.timestamp,
    };
};
const formatTransaction = (transaction) => {
    const formattedTransaction = {
        rid: toBuffer(transaction.rid),
        hash: toBuffer(transaction.hash),
    };
    if (transaction.data !== undefined) {
        formattedTransaction.data = toBuffer(transaction.data);
    }
    return formattedTransaction;
};
const isKeyPair = (keypair) => {
    return (typeof keypair === "object" &&
        keypair !== null &&
        "privKey" in keypair &&
        "pubKey" in keypair &&
        keypair.privKey instanceof require$$0$1.Buffer &&
        keypair.pubKey instanceof require$$0$1.Buffer);
};
function getNodeUrlsFromSettings(settings) {
    return __awaiter$6(this, void 0, void 0, function* () {
        if (settings.directoryNodeUrlPool) {
            // If directoryNodeUrlPool is provided, use nodeDiscovery
            return yield nodeDiscovery(createEndpointObjects(ensureArray(settings.directoryNodeUrlPool)), settings.failOverConfig, settings.blockchainRid, settings.blockchainIid);
        }
        else if (typeof settings.nodeUrlPool === "string") {
            // If nodeUrlPool is a string, convert it to an array
            return [settings.nodeUrlPool];
        }
        else if (Array.isArray(settings.nodeUrlPool)) {
            // If nodeUrlPool is already an array, use it as-is
            return settings.nodeUrlPool;
        }
        else {
            // Default to an empty array if no valid configuration is provided
            return [];
        }
    });
}
const defaultFailoverConfig = {
    strategy: exports.FailoverStrategy.AbortOnError,
    attemptsPerEndpoint: 3,
    attemptInterval: 500,
    unreachableDuration: 30000,
};
const createEndpointObjects = (endpointPoolUrls) => {
    const endpoints = endpointPoolUrls.map((endpointUrl) => {
        return { url: endpointUrl, whenAvailable: 0 };
    });
    return endpoints;
};
const getUrlsFromEndpoints = (endpointPool) => {
    return endpointPool.map((endpoint) => endpoint.url);
};

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getBlockchainRidFromIid(endpointPool, chainId, failOverConfig = defaultFailoverConfig) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const config = {
            endpointPool,
            statusPollInterval: 500,
            statusPollCount: 20,
            failoverStrategy: failOverConfig.strategy || defaultFailoverConfig.strategy,
            attemptsPerEndpoint: failOverConfig.attemptsPerEndpoint ||
                defaultFailoverConfig.attemptsPerEndpoint,
            attemptInterval: failOverConfig.attemptInterval || defaultFailoverConfig.attemptInterval,
            unreachableDuration: failOverConfig.unreachableDuration ||
                defaultFailoverConfig.unreachableDuration,
        };
        const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `/brid/iid_${chainId}`, config);
        if (error) {
            throw new GetBridFromChainException(chainId, error.message);
        }
        else if (statusCode !== 200) {
            throw new GetBridFromChainException(chainId, rspBody);
        }
        return rspBody;
    });
}
function requestWithRetry(method, path, config, postObject) {
    return __awaiter$5(this, void 0, void 0, function* () {
        switch (config.failoverStrategy) {
            case exports.FailoverStrategy.AbortOnError:
                return yield abortOnError({ method, path, config, postObject });
            case exports.FailoverStrategy.TryNextOnError:
                return yield tryNextOnError({ method, path, config, postObject });
            case exports.FailoverStrategy.SingleEndpoint:
                return yield singleEndpoint({ method, path, config, postObject });
        }
    });
}
function nextEndpoint(endpointPool) {
    return endpointPool[Math.floor(Math.random() * endpointPool.length)];
}
const shuffle = (array) => {
    const shuffledArray = [...array];
    for (let i = shuffledArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
    }
    return shuffledArray;
};
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
function convertToPrintable(responseObject) {
    if (typeof responseObject === "bigint") {
        return `${responseObject}n`;
    }
    else if (typeof responseObject === "object") {
        return JSON.stringify(responseObject, (key, value) => typeof value === "bigint" ? `${value}n` : value);
    }
    else {
        return responseObject;
    }
}
function filterReachableEndpoint(endpointPool) {
    return endpointPool.filter((endpoint) => isReachable(endpoint));
}
function isReachable(endpoint) {
    return new Date().getTime() > endpoint.whenAvailable;
}
const bftMajority = (n) => n - (n - 1) / 3;
const setEndpointAsReachable = (endpointPool) => {
    endpointPool.forEach((endpoint) => {
        endpoint.whenAvailable = 0;
    });
};
const setUnavailable = (endpoint, unreachableDuration) => {
    endpoint.whenAvailable = new Date().getTime() + unreachableDuration;
};

var restclientutil = /*#__PURE__*/Object.freeze({
	__proto__: null,
	bftMajority: bftMajority,
	convertToPrintable: convertToPrintable,
	filterReachableEndpoint: filterReachableEndpoint,
	getBlockchainRidFromIid: getBlockchainRidFromIid,
	isReachable: isReachable,
	nextEndpoint: nextEndpoint,
	requestWithRetry: requestWithRetry,
	setEndpointAsReachable: setEndpointAsReachable,
	setUnavailable: setUnavailable,
	shuffle: shuffle,
	sleep: sleep
});

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createRestClient(endpointPool, blockchainRid, maxSockets = 10, pollingInterval = 500, failOverConfig, unreachableDuration = 5000) {
    validateInput(endpointPool, failOverConfig !== null && failOverConfig !== void 0 ? failOverConfig : {});
    return {
        config: {
            endpointPool: createEndpointObjects(endpointPool),
            pool: { maxSockets },
            pollingInterval,
            failoverStrategy: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.strategy) || exports.FailoverStrategy.AbortOnError,
            attemptsPerEndpoint: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptsPerEndpoint) || 3,
            attemptInterval: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptInterval) || 500,
            unreachableDuration: unreachableDuration,
        },
        getTransaction: function (txRID, callback) {
            return __awaiter$4(this, void 0, void 0, function* () {
                if (!isTxRidValid(txRID)) {
                    callback(new InvalidTxRidException(txRID), null);
                }
                else {
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${blockchainRid}/${txRID.toString("hex")}`, this.config);
                    handleGetResponse(error, statusCode, statusCode === 200 ? toBuffer(rspBody.tx) : rspBody, callback);
                }
            });
        },
        postTransaction: function (serializedTransaction, callback) {
            return __awaiter$4(this, void 0, void 0, function* () {
                if (!require$$0$1.Buffer.isBuffer(serializedTransaction)) {
                    throw new SerializedTransactionFormatException();
                }
                const transactionObject = {
                    tx: serializedTransaction.toString("hex"),
                };
                const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `tx/${blockchainRid}`, this.config, transactionObject);
                handlePostResponse(error, statusCode, rspBody, callback);
            });
        },
        status: function (txRID, callback) {
            return __awaiter$4(this, void 0, void 0, function* () {
                if (!isTxRidValid(txRID)) {
                    callback(new InvalidTxRidException(txRID), null);
                }
                else {
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${blockchainRid}/${txRID.toString("hex")}/status`, this.config);
                    handleGetResponse(error, statusCode, rspBody, callback);
                }
            });
        },
        query: function (nameOrQueryObject, queryArguments) {
            return __awaiter$4(this, void 0, void 0, function* () {
                // eslint-disable-next-line no-async-promise-executor
                return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
                    const callback = (error, result) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(result);
                        }
                    };
                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `query_gtv/${blockchainRid}`, this.config, encodeValue(toQueryObjectGTV(nameOrQueryObject, queryArguments)));
                    handlePostResponse(error, statusCode, rspBody, callback);
                }));
            });
        },
        waitConfirmation(txRID) {
            return new Promise((resolve, reject) => {
                this.status(txRID, (error$1, result) => {
                    if (error$1) {
                        reject(error$1);
                    }
                    else {
                        const status = result.status;
                        switch (status) {
                            case ResponseStatus.Confirmed:
                                resolve(null);
                                break;
                            case ResponseStatus.Rejected:
                                reject(new TxRejectedError(result.rejectReason));
                                break;
                            case ResponseStatus.Unknown:
                                reject(new LostMessageError());
                                break;
                            case ResponseStatus.Waiting:
                                setTimeout(() => this.waitConfirmation(txRID).then(resolve, reject), this.config.pollingInterval);
                                break;
                            default:
                                error(status);
                                reject(new UnexpectedResponseError());
                        }
                    }
                });
            });
        },
        postAndWaitConfirmation(serializedTransaction, txRID, validate) {
            if (validate === true) {
                return Promise.reject("Automatic validation is not yet implemented");
            }
            return new Promise((resolve, reject) => {
                this.postTransaction(serializedTransaction, (error) => {
                    if (error)
                        reject(error);
                    else {
                        setTimeout(() => this.waitConfirmation(txRID).then(resolve, reject), 1011);
                    }
                });
            });
        },
        getEndpointPool() {
            return getUrlsFromEndpoints(this.config.endpointPool);
        },
    };
}
function validateInput(endpointPool, failOverConfig) {
    if (!endpointPool.length) {
        throw new EmptyListOfUrlsException();
    }
    if ((failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptsPerEndpoint) &&
        failOverConfig.attemptsPerEndpoint < 1) {
        debug("Attempts can not be 0 or below, setting it to 1");
        failOverConfig.attemptsPerEndpoint = 1;
    }
}
/**
 * @param error response error
 * @param statusCode response status code
 * @param responseObject the responsebody from the server
 * @param callback the callback function to propagate the error and response back to the caller
 */
function handleGetResponse(error$1, statusCode, responseObject, callback) {
    try {
        const responseObjectPrintable = convertToPrintable(responseObject);
        debug(`error: ${error$1}, status code: ${statusCode}, response body: ${responseObjectPrintable}`);
        if (error$1) {
            callback(error$1, null);
        }
        else if (statusCode !== 200) {
            callback(new UnexpectedStatusError(statusCode !== null && statusCode !== void 0 ? statusCode : 400, responseObjectPrintable), null);
        }
        else {
            callback(null, responseObject);
        }
    }
    catch (error$1) {
        error(`restclient.handleGetResponse(): Failed to call the callback function. ${error$1}`);
    }
}
/**
 * @param error response error
 * @param statusCode response status code
 * @param responseObject the responsebody from the server
 * @param callback the callback function to propagate the error and response back to the caller
 */
function handlePostResponse(error$1, statusCode, responseObject, callback) {
    const responseObjectPrintable = convertToPrintable(responseObject);
    debug(`error: ${error$1}, status code: ${statusCode}, response body: ${responseObjectPrintable}`);
    try {
        if (error$1) {
            error(`In restclient post(). ${error$1}`);
            callback(error$1, null);
        }
        else if (statusCode != 200) {
            let errorMessage = `Unexpected status code from server. Code: ${statusCode}.`;
            if (responseObjectPrintable) {
                errorMessage += ` Message: ${responseObjectPrintable}.`;
            }
            error(errorMessage);
            callback(new UnexpectedStatusError(statusCode !== null && statusCode !== void 0 ? statusCode : 400, responseObjectPrintable), responseObject);
        }
        else {
            info(`Calling responseCallback with responseObject: ${responseObjectPrintable}`);
            callback(null, responseObject);
        }
    }
    catch (error$1) {
        error(`restclient.handlePostResponse(): Failed to call callback function ${error$1}`);
    }
}

var restclient = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createRestClient: createRestClient,
	handleGetResponse: handleGetResponse,
	handlePostResponse: handlePostResponse
});

var internalNodePrefix = require$$0$1.Buffer.alloc(1, 0);
var leafPrefix = require$$0$1.Buffer.alloc(1, 1);
var nonExistingNodeHash = require$$0$1.Buffer.alloc(32);
function calculateRoot(hashes, depth, leafDepth) {
    var numTransactions = hashes.length;
    if (numTransactions === 0) {
        return require$$0$1.Buffer.alloc(32);
    }
    if (depth === undefined) {
        depth = 0;
    }
    if (!leafDepth) {
        leafDepth = Math.ceil(Math.log2(numTransactions));
    }
    if (depth === leafDepth) {
        return hashes[0];
    }
    var maxLeavesPerChild = Math.pow(2, leafDepth - depth - 1);
    var prefix = depth === leafDepth - 1 ? leafPrefix : internalNodePrefix;
    if (numTransactions <= maxLeavesPerChild) {
        var left = calculateRoot(hashes, depth + 1, leafDepth);
        return hashConcat([prefix, left, nonExistingNodeHash]);
    }
    var left = calculateRoot(hashes.slice(0, maxLeavesPerChild), depth + 1, leafDepth);
    var right = calculateRoot(hashes.slice(maxLeavesPerChild), depth + 1, leafDepth);
    return hashConcat([prefix, left, prefix, right]);
}
function internalMerklePath(hashes, targetIndex, depth, leafDepth) {
    var numTransactions = hashes.length;
    if (depth === leafDepth) {
        return [];
    }
    var maxLeavesPerChild = Math.pow(2, leafDepth - depth - 1);
    if (numTransactions <= maxLeavesPerChild) {
        var path = internalMerklePath(hashes, targetIndex, depth + 1, leafDepth);
        path.push({ side: 1, hash: nonExistingNodeHash });
        return path;
    }
    if (targetIndex < maxLeavesPerChild) {
        var path = internalMerklePath(hashes.slice(0, maxLeavesPerChild), targetIndex, depth + 1, leafDepth);
        var right = calculateRoot(hashes.slice(maxLeavesPerChild), depth + 1, leafDepth);
        path.push({ side: 1, hash: right });
    }
    else {
        var left = calculateRoot(hashes.slice(0, maxLeavesPerChild), depth + 1, leafDepth);
        var path = internalMerklePath(hashes.slice(maxLeavesPerChild), targetIndex - maxLeavesPerChild, depth + 1, leafDepth);
        path.push({ side: 0, hash: left });
    }
    return path;
}
/*
 * a path looks like this:
 * {merklePath: [{side: <0|1>, hash: <hash buffer depth n-1>},
 *               {side: <0|1>, hash: <hash buffer depth n-2>},
 *               ...
 *               {side: <0|1>, hash: <hash buffer depth 1>}]}
 */
function merklePath(hashes, target) {
    if (!hashes || hashes.length == 0) {
        throw new Error("Cannot make merkle path from empty transaction set");
    }
    var index = -1;
    for (var i = 0; i < hashes.length; i++) {
        if (hashes[i].equals(target)) {
            index = i;
            break;
        }
    }
    if (index === -1) {
        throw new Error("Target is not in list of hashes");
    }
    var leafDepth = Math.ceil(Math.log2(hashes.length));
    var path = internalMerklePath(hashes, index, 0, leafDepth);
    return path;
}
/**
 *
 * @param path The merkle path to validate.
 * Format [{side: <0|1>, hash: <hash buffer depth n-1>},
 *         {side: <0|1>, hash: <hash buffer depth n-2>},
 *         ...,
 *         {side: <0|1>, hash: <hash buffer depth 1>}]

 * @param target the leaf hash that the path proves belongs in the merkleRoot
 * @param merkleRoot The merkle root that supposedly contains the target via the supplied path.
 * The merkle root is typically taken from a block header.
 */
function validateMerklePath(path, target, merkleRoot) {
    let currentHash = target;
    for (let i = 0; i < path.length; i++) {
        const item = path[i];
        const prefix = (i === 0) ? require$$0$1.Buffer.from([1]) : require$$0$1.Buffer.from([0]);
        if (item.side === 0) {
            currentHash = hashConcat([prefix, item.hash, prefix, currentHash]);
        }
        else {
            if (item.hash.equals(nonExistingNodeHash)) {
                currentHash = hashConcat([prefix, currentHash, nonExistingNodeHash]);
            }
            else {
                currentHash = hashConcat([prefix, currentHash, prefix, item.hash]);
            }
        }
    }
    return merkleRoot.equals(currentHash);
}

var merkleHelper = /*#__PURE__*/Object.freeze({
	__proto__: null,
	calculateRoot: calculateRoot,
	merklePath: merklePath,
	validateMerklePath: validateMerklePath
});

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * @deprecated Use the function createClient instead.
 * Provides postchain clients that can be used to communicate with dapps within the chromia network
 * @param chain0BRID brid of chain0
 * @param rest rest client configured to node running chain0
 */
function chromiaClientProvider(chain0BRID, rest) {
    const chain0Client = createClient$1(rest, chain0BRID, []);
    return {
        blockchainConnection: function (dappBRID) {
            return __awaiter$3(this, void 0, void 0, function* () {
                const queryObject = {
                    type: "cm_get_blockchain_api_urls",
                    blockchain_rid: dappBRID,
                };
                const baseUrls = yield chain0Client.query(queryObject);
                if (!baseUrls.length) {
                    throw new BlockchainUrlUndefinedException(dappBRID);
                }
                return createRestClient(baseUrls, dappBRID);
            });
        },
    };
}

var chromiaClientProvider$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	chromiaClientProvider: chromiaClientProvider
});

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function createStubClient() {
    return __awaiter$2(this, void 0, void 0, function* () {
        return {
            config: {
                endpointPool: [],
                blockchainRid: "0000000000000000000000000000000000000000000000000000000000000000",
                statusPollInterval: 5000,
                statusPollCount: 5,
                failoverStrategy: exports.FailoverStrategy.AbortOnError,
                attemptsPerEndpoint: 3,
                attemptInterval: 5000,
                unreachableDuration: 30000,
            },
            query() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("query rejected");
                });
            },
            signTransaction() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("signTransaction rejected");
                });
            },
            sendTransaction() {
                return new Web3PromiEvent((_resolve, reject) => reject("sendTransaction rejected"));
            },
            signAndSendUniqueTransaction() {
                return new Web3PromiEvent((_resolve, reject) => reject("signAndSendUniqueTransaction rejected"));
            },
            getTransaction() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getTransaction rejected");
                });
            },
            getTransactionStatus() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getTransactionStatus rejected");
                });
            },
            addNop() {
                throw new Error("addNop error");
            },
            getTransactionRid() {
                throw new Error("getTransactionRid error");
            },
            getTransactionsInfo() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getTransactionsInfo rejected");
                });
            },
            getTransactionInfo() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getTransactionInfo rejected");
                });
            },
            getTransactionCount() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getTransactionCount rejected");
                });
            },
            getBlockInfo() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getBlockInfo rejected");
                });
            },
            getLatestBlock() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getLatestBlock rejected");
                });
            },
            getBlocksInfo() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getBlocksInfo rejected");
                });
            },
            encodeTransaction() {
                throw new Error("encodeTransaction error");
            },
            decodeTransactionToGtx() {
                throw new Error("decodeTransactionToGtx error");
            },
            getClientNodeUrlPool() {
                return [];
            },
            getConfirmationProof() {
                return __awaiter$2(this, void 0, void 0, function* () {
                    return Promise.reject("getConfirmationProof rejected");
                });
            },
        };
    });
}

class MissingTransactionProof extends Error {
    constructor(proofHash, fetchedTxHash) {
        super(`Unable to verify source transaction proof,transaction hash in proof ${toString(proofHash)} does not match hash from fetched transaction ${toString(fetchedTxHash)}`);
    }
}
class DifferentNumberOfSignersException extends Error {
    constructor(length, comparableLength) {
        super(`Transaction signatures amount ${length} do not match expected amount of signers ${comparableLength}`);
    }
}
class SignatureException extends Error {
    constructor(signer) {
        super(`Expected signer ${toString(signer)} has not signed source transaction`);
    }
}
class ProofRidException extends Error {
    constructor() {
        super("Unable to verify source transaction proof, got a different transaction from query than we asked for");
    }
}
class SystemChainException extends Error {
    constructor(errorMessage) {
        super(`Query to system chain failed with error: ${errorMessage}`);
    }
}
class ConfirmationProofException extends Error {
    constructor(transactionRid) {
        super(`Unable to fetch confirmation proof for transaction RID: ${toString(transactionRid)}.`);
    }
}
class BlockAnchoringException extends Error {
    constructor() {
        super(`Block is not present in cluster anchoring chain`);
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getClusterOfBlockchain(client, blockchainRid) {
    return __awaiter$1(this, void 0, void 0, function* () {
        try {
            const clusterName = yield client.query({
                name: "cm_get_blockchain_cluster",
                args: { brid: blockchainRid },
            });
            return clusterName;
        }
        catch (error) {
            throw new SystemChainException(error.message);
        }
    });
}
function getClusterInfo(client, name) {
    return __awaiter$1(this, void 0, void 0, function* () {
        try {
            const clusterInfo = yield client.query({
                name: "cm_get_cluster_info",
                args: { name },
            });
            return clusterInfo;
        }
        catch (error) {
            throw new SystemChainException(error.message);
        }
    });
}
function getAnchoringTransactionForBlockRid(client, blockchainRid, blockRid) {
    return __awaiter$1(this, void 0, void 0, function* () {
        try {
            const anchoringTxForBlockRid = yield client.query({
                name: "get_anchoring_transaction_for_block_rid",
                args: { blockchain_rid: blockchainRid, block_rid: blockRid },
            });
            return convertToAnchoringTransaction(anchoringTxForBlockRid);
        }
        catch (error) {
            throw new SystemChainException(error.message);
        }
    });
}
function convertToAnchoringTransaction(responseTx) {
    const { tx_rid, tx_data, tx_op_index } = responseTx;
    return {
        txRid: tx_rid,
        txData: tx_data,
        txOpIndex: tx_op_index,
    };
}
function calculateBlockRID(decodedTxProof) {
    const sourceBlockHeader = decodedTxProof.blockHeader;
    if (!sourceBlockHeader) {
        throw new Error("Failed to get blockHeader from confirmation proof");
    }
    const decodeSourceBlockRid = decodeValue(sourceBlockHeader);
    return gtvHash(decodeSourceBlockRid);
}
// fetch tx from txRID and verifies with secp256k1.ecdsaVerify that txRID and signer creates signatures that are on the blockchain transaction
function fetchAndVerifyTransaction(sourceClient, txToProveRID, proofHash, txToProveSigners) {
    var _a, _b, _c;
    return __awaiter$1(this, void 0, void 0, function* () {
        const rawTx = yield sourceClient.getTransaction(txToProveRID);
        const txGtv = decodeValue(rawTx);
        const fetchedTxHash = gtvHash(txGtv);
        if (Buffer.compare(fetchedTxHash, proofHash)) {
            // We received another hash for tx RID than what was included in proof
            // Possibly rouge or faulty node(s). Anyway, we need to give up.
            throw new MissingTransactionProof(proofHash, fetchedTxHash);
        }
        const fetchedTx = rawGtvToGtx(txGtv);
        if (txToProveSigners.length != ((_a = fetchedTx.signatures) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new DifferentNumberOfSignersException((_c = (_b = fetchedTx.signatures) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, txToProveSigners.length);
        }
        const txRID = getDigestToSign(fetchedTx);
        if (Buffer.compare(txRID, txToProveRID)) {
            throw new ProofRidException();
        }
        for (const signer of txToProveSigners) {
            let hasSignature = false;
            for (const signature of fetchedTx.signatures) {
                // verify that txRID (hash of gtxBody) signed by signers equals the signatures from network
                if (checkDigestSignature(txRID, signer, signature)) {
                    hasSignature = true;
                    break;
                }
            }
            if (!hasSignature)
                throw new SignatureException(signer);
        }
        return { verifiedTx: fetchedTx, verifiedTxHash: fetchedTxHash };
    });
}
function composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, anchoringTx, anchoringProof, isNetwork = true) {
    let operationArgs;
    operationArgs = {
        sourceBlockchainRid: toBuffer(sourceBlockchainRid),
        transactionHash: verifiedTxHash,
        transactionProof: encodeValue(txProof),
    };
    if (isNetwork) {
        operationArgs = Object.assign(Object.assign({}, operationArgs), { transactionData: anchoringTx === null || anchoringTx === void 0 ? void 0 : anchoringTx.txData, transactionIndex: anchoringTx === null || anchoringTx === void 0 ? void 0 : anchoringTx.txOpIndex, anchoringProof: anchoringProof && encodeValue(anchoringProof) });
    }
    return {
        operations: [
            {
                name: "iccf_proof",
                args: Object.values(operationArgs),
            },
        ],
        signers: iccfTxSigners,
    };
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Creates an ICCF (Inter-Chain Communication Framework) proof transaction.
 * This function generates a proof that a specific transaction has occurred on the source blockchain
 * and constructs an ICCF proof transaction that can be posted to the target blockchain.
 *
 * @param {IClient} client - The client configured to communicate with the management chain.
 * @param {Buffer} txToProveRid - The RID of the transaction to be proven.
 * @param {Buffer} txToProveHash - The hash of the transaction to be proven.
 * @param {PubKey[]} txToProveSigners - An array of public keys representing signers of the transaction to be proven.
 * @param {string} sourceBlockchainRid - The RID of the source blockchain.
 * @param {string} targetBlockchainRid - The RID of the target blockchain.
 * @param {PubKey[]} iccfTxSigners - An array of public keys representing signers of the ICCF proof transaction (optional, default: []).
 * @param {boolean} forceIntraNetworkIccfOperation - Whether to force the ICCF operation to be performed within the same network (optional, default: false).
 * @returns {Promise<IccfProof>} A promise that resolves to an ICCF proof object containing the ICCF proof transaction.
 */
function createIccfProofTx(client, txToProveRid, txToProveHash, txToProveSigners, sourceBlockchainRid, targetBlockchainRid, iccfTxSigners = [], forceIntraNetworkIccfOperation = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const clientConfiguredToSource = yield createClient({
            directoryNodeUrlPool: getUrlsFromEndpoints(client.config.endpointPool),
            blockchainRid: sourceBlockchainRid,
        });
        const txProof = yield clientConfiguredToSource.getConfirmationProof(txToProveRid);
        if (!txProof || !txProof.hash) {
            throw new ConfirmationProofException(txToProveRid);
        }
        const proofHash = txProof.hash;
        const { verifiedTx, verifiedTxHash } = !txToProveHash.equals(proofHash)
            ? yield fetchAndVerifyTransaction(clientConfiguredToSource, txToProveRid, proofHash, txToProveSigners)
            : { verifiedTx: null, verifiedTxHash: txToProveHash };
        const sourceCluster = yield getClusterOfBlockchain(client, toBuffer(sourceBlockchainRid));
        const targetCluster = yield getClusterOfBlockchain(client, toBuffer(targetBlockchainRid));
        if (!forceIntraNetworkIccfOperation && sourceCluster === targetCluster) {
            // intra-cluster
            const intraClusterProofTx = composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, undefined, undefined, false);
            return { iccfTx: intraClusterProofTx };
        }
        else {
            // intra-network
            const anchoringClient = yield getAnchoringClient(client, sourceBlockchainRid, sourceCluster);
            const anchoringTx = yield getBlockAnchoringTransaction(clientConfiguredToSource, anchoringClient, undefined, txProof);
            const anchoringProof = yield anchoringClient.getConfirmationProof(anchoringTx.txRid);
            const intraNetworkProofTx = composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, anchoringTx, anchoringProof);
            return { iccfTx: intraNetworkProofTx, verifiedTx };
        }
    });
}
/**
 * Checks whether a given transaction is included in the cluster anchoring chain and returns the
 * block anchoring transaction. If `txProof` is not provided, it fetches the confirmation proof
 * using the `sourceClient`.
 *
 * @param sourceClient - A client configured to the blockchain where the trasnaction were made.
 * @param anchoringClient - The client responsible for querying the anchoring blockchain.
 * @param txRid - The transaction RID to check for anchoring.
 * @param txProof - (Optional) The transaction proof for the specified `txRid`.
 * @returns A Promise that resolves to the anchored transaction response object.
 */
function getBlockAnchoringTransaction(sourceClient, anchoringClient, txRid, txProof) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!txRid && !txProof) {
            throw Error("Missing a txRid or TxProof");
        }
        const confirmationProof = txProof !== null && txProof !== void 0 ? txProof : (txRid && (yield sourceClient.getConfirmationProof(txRid)));
        if (!confirmationProof) {
            throw Error("Confirmation proof not found");
        }
        const blockRid = calculateBlockRID(confirmationProof);
        const blockchainRid = sourceClient.config.blockchainRid;
        const anchoringTxResponse = yield getAnchoringTransactionForBlockRid(anchoringClient, toBuffer(blockchainRid), blockRid);
        if (!anchoringTxResponse) {
            throw new BlockAnchoringException();
        }
        return anchoringTxResponse;
    });
}
/**
 * Checks whether a given transaction is included in the anchoring blockchain.
 *
 * @param sourceClient - A client configured to the blockchain where the trasnaction were made.
 * @param anchoringClient - The client responsible for querying the anchoring blockchain.
 * @param txRid - The transaction RID to check for anchoring.
 * @param txProof - (Optional) The transaction proof for the specified `txRid`.
 * @returns A Promise that resolves to `true` if the transaction is anchored, `false` otherwise.
 */
function isBlockAnchored(sourceClient, anchoringClient, txRid, txProof) {
    return __awaiter(this, void 0, void 0, function* () {
        return !!(yield getBlockAnchoringTransaction(sourceClient, anchoringClient, txRid, txProof));
    });
}
/**
 * Gets a client configured for the cluster anchoring blockchain of a cluster. Takes a specific
 * cluster name or blockchain RID to determine the cluster.
 * @param client - The client configured to communicate with the management chain.
 * @param dappBlockchainRid - (Optional) The RID of a blockchain which anchoring wants to be checked.
 * @param cluster - (Optional) The cluster of interest.
 * @returns A Promise that resolves to the client configured to a cluster anchoring chain.
 */
function getAnchoringClient(client, dappBlockchainRid, cluster) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!dappBlockchainRid && !cluster) {
            throw Error("Missing a dapp blockchainRid or cluster name");
        }
        const sourceCluster = cluster !== null && cluster !== void 0 ? cluster : (dappBlockchainRid &&
            (yield getClusterOfBlockchain(client, toBuffer(dappBlockchainRid))));
        if (!sourceCluster) {
            throw Error("No cluster could be found");
        }
        const sourceClusterInfo = yield getClusterInfo(client, sourceCluster);
        if (!sourceClusterInfo || !sourceClusterInfo.anchoring_chain) {
            throw Error("Cluster info could not be found");
        }
        const clientConfiguredToAnchoringchain = yield createClient({
            directoryNodeUrlPool: getUrlsFromEndpoints(client.config.endpointPool),
            blockchainRid: toString(sourceClusterInfo.anchoring_chain),
        });
        return clientConfiguredToAnchoringchain;
    });
}

/**
 * Calculates and returns the transaction RID, i.e., the merkle root hash of the transaction.
 * @param transaction The transaction in format of RawGtxBody
 *
 */
const calculateTransactionRid = (transaction) => {
    try {
        return getDigestToSignFromRawGtxBody(transaction);
    }
    catch (e) {
        throw new GetTransactionRidException(e);
    }
};

/**
 *
 * Encodes the gtx using ASN.1.
 * @returns the gtx encoded
 */
const encodeTransaction = (gtx$1) => {
    return serialize(gtx$1);
};

/**
 * Decodes the transaction using ASN.1.
 * @returns the transaction decoded in GTX format
 */
const decodeTransactionToGtx = (encodedTransaction) => {
    const gtx$1 = deserialize(encodedTransaction);
    debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
    return gtx$1;
};

exports.AlreadySignedTransactionException = AlreadySignedTransactionException;
exports.BlockAnchoringException = BlockAnchoringException;
exports.BlockchainUrlUndefinedException = BlockchainUrlUndefinedException;
exports.ConfirmationProofException = ConfirmationProofException;
exports.CustomError = CustomError;
exports.DifferentNumberOfSignersException = DifferentNumberOfSignersException;
exports.DirectoryNodeUrlPoolException = DirectoryNodeUrlPoolException;
exports.EmptyListOfUrlsException = EmptyListOfUrlsException;
exports.GetBridFromChainException = GetBridFromChainException;
exports.GetTransactionRidException = GetTransactionRidException;
exports.InvalidBlockchainRIDException = InvalidBlockchainRIDException;
exports.InvalidTransactionFormatException = InvalidTransactionFormatException;
exports.InvalidTxRidException = InvalidTxRidException;
exports.LostMessageError = LostMessageError;
exports.MissingBlockchainIdentifierError = MissingBlockchainIdentifierError;
exports.MissingGtxException = MissingGtxException;
exports.MissingNodeUrlError = MissingNodeUrlError;
exports.MissingPrivKeyArgumentException = MissingPrivKeyArgumentException;
exports.MissingPubKeyError = MissingPubKeyError;
exports.MissingSignerException = MissingSignerException;
exports.MissingTransactionProof = MissingTransactionProof;
exports.NumberOfSignersAndSignaturesException = NumberOfSignersAndSignaturesException;
exports.PrivKeyFormatException = PrivKeyFormatException;
exports.ProofRidException = ProofRidException;
exports.SerializedTransactionFormatException = SerializedTransactionFormatException;
exports.SignatureException = SignatureException;
exports.SystemChainException = SystemChainException;
exports.TxRejectedError = TxRejectedError;
exports.UnexpectedArgumentTypeError = UnexpectedArgumentTypeError;
exports.UnexpectedResponseError = UnexpectedResponseError;
exports.UnexpectedStatusError = UnexpectedStatusError;
exports.Web3PromiEvent = Web3PromiEvent;
exports.calculateTransactionRid = calculateTransactionRid;
exports.chromiaClient = chromiaClientProvider$1;
exports.convertToRellOperation = convertToRellOperation;
exports.createClient = createClient;
exports.createIccfProofTx = createIccfProofTx;
exports.createStubClient = createStubClient;
exports.decodeTransactionToGtx = decodeTransactionToGtx;
exports.encodeTransaction = encodeTransaction;
exports.encryption = encryption$1;
exports.formatter = formatter;
exports.getAnchoringClient = getAnchoringClient;
exports.getBlockAnchoringTransaction = getBlockAnchoringTransaction;
exports.getDigestToSignFromRawGtxBody = getDigestToSignFromRawGtxBody;
exports.gtv = index;
exports.gtx = gtx;
exports.gtxClient = gtxclient;
exports.isBlockAnchored = isBlockAnchored;
exports.logger = logger$1;
exports.merkle = merkleHelper;
exports.newSignatureProvider = newSignatureProvider;
exports.restClient = restclient;
exports.restClientutil = restclientutil;
//# sourceMappingURL=index.js.map
