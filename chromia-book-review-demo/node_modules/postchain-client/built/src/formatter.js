var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Buffer } from "buffer";
export function pgBytes(buffer) {
    if (!Buffer.isBuffer(buffer)) {
        throw new PgBytesInputException(buffer);
    }
    return `\\x${buffer.toString("hex")}`;
}
/**
 * Converts hex string to Buffer
 * @param key: string
 * @returns {Buffer}
 */
export function toBuffer(key) {
    return Buffer.from(key, "hex");
}
/**
 * Converts Buffer to hex string
 * @param buffer: Buffer
 * @returns {string}
 */
export function toString(buffer) {
    return buffer.toString("hex").toUpperCase();
}
export function toQueryObjectGTV(nameOrObject, queryArguments) {
    let name;
    if (typeof nameOrObject === "string") {
        name = nameOrObject;
        return [name, Object.assign({}, queryArguments)];
    }
    else {
        const objectCopy = Object.assign({}, nameOrObject);
        const { type } = objectCopy, restProps = __rest(objectCopy, ["type"]);
        return [type, restProps];
    }
}
export class PgBytesInputException extends Error {
    constructor(buffer) {
        super(`util.pgBytes expects a buffer, but got ${typeof buffer}`);
    }
}
export function ensureBuffer(value) {
    if (value instanceof Buffer) {
        return value;
    }
    else {
        return toBuffer(value);
    }
}
export function checkGtvType(value) {
    try {
        if (value == null) {
            return true;
        }
        if (Buffer.isBuffer(value)) {
            return true;
        }
        if (typeof value === "string") {
            return true;
        }
        if (typeof value === "number") {
            if (!Number.isInteger(value)) {
                throw Error("User error: Only integers are supported");
            }
            return true;
        }
        if (typeof value === "bigint") {
            return true;
        }
        if (value.constructor === Array) {
            value.map((item) => checkGtvType(item));
            return true;
        }
        if (typeof value === "object") {
            Object.keys(value).map(function (key) {
                checkGtvType(value[key]);
            });
            return true;
        }
    }
    catch (error) {
        throw new Error(`Failed to check type: ${error}`);
    }
    return false;
}
export function rawGtxToGtx(rawGtx) {
    const rawGtxBody = rawGtx[0];
    const signatures = rawGtx[1];
    const gtxBody = {
        blockchainRid: rawGtxBody[0],
        operations: rawGtxBody[1].map((operation) => ({
            opName: operation[0],
            args: operation[1],
        })),
        signers: rawGtxBody[2],
    };
    return {
        blockchainRid: gtxBody.blockchainRid,
        operations: gtxBody.operations,
        signers: gtxBody.signers,
        signatures,
    };
}
export function rawGtxToRawGtxBody(rawGtx) {
    return rawGtx[0];
}
export function checkGtxType(value) {
    try {
        rawGtxToGtx(value);
        return true;
    }
    catch (error) {
        return false;
    }
}
export function removeDuplicateSigners(signers) {
    const signersAsString = [];
    signers.forEach((item) => {
        const itemAsString = item.toString("hex");
        if (!signersAsString.includes(itemAsString)) {
            signersAsString.push(itemAsString);
        }
    });
    const result = [];
    signersAsString.forEach((item) => {
        result.push(Buffer.from(item, "hex"));
    });
    return result;
}
export function matchRellErrorString(rellError) {
    const parsed = rellError.match(/\[([^\]]+)\]\sOperation\s'([^']+)'\sfailed:\s(.+)$/);
    if (!parsed)
        return {};
    const [rellLine, operation, shortReason] = parsed.slice(1);
    return { shortReason, rellLine, operation };
}
//# sourceMappingURL=formatter.js.map