var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { logger } from "../..";
import handleRequest from "./httpUtil";
import { bftMajority, filterReachableEndpoint, isReachable, nextEndpoint, setEndpointAsReachable, setUnavailable, shuffle, sleep, } from "./restclientutil";
const hasClientError = (statusCode) => statusCode >= 400 && statusCode < 500;
const hasServerError = (statusCode) => statusCode >= 500 && statusCode < 600;
export function abortOnError({ method, path, config, postObject, }) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield retryRequest({
            method,
            path,
            config,
            postObject,
            validateStatusCode: (statuscode) => !hasServerError(statuscode),
        });
    });
}
export function tryNextOnError({ method, path, config, postObject, }) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield retryRequest({
            method,
            path,
            config,
            postObject,
            validateStatusCode: (statusCode) => !hasClientError(statusCode) && !hasServerError(statusCode),
        });
    });
}
export function singleEndpoint({ method, path, config, postObject, }) {
    return __awaiter(this, void 0, void 0, function* () {
        let statusCode, rspBody, error;
        for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
            const endpoint = nextEndpoint(config.endpointPool);
            ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
            const isError = statusCode
                ? hasServerError(statusCode) || hasClientError(statusCode)
                : false;
            if (!isError && !error) {
                return { error, statusCode, rspBody };
            }
            logger.info(`${method} request failed on ${config.endpointPool[0]}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
            yield sleep(config.attemptInterval);
        }
        // TS issue. Variable 'error' is used before being assigned.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return { error, statusCode, rspBody };
    });
}
export function retryRequest({ method, path, config, postObject, validateStatusCode, }) {
    return __awaiter(this, void 0, void 0, function* () {
        let statusCode;
        let rspBody;
        let error;
        const reachableEndpoints = filterReachableEndpoint(config.endpointPool);
        if (reachableEndpoints.length < bftMajority(config.endpointPool.length)) {
            setEndpointAsReachable(config.endpointPool);
        }
        for (const endpoint of shuffle(config.endpointPool)) {
            if (isReachable(endpoint)) {
                for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
                    ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
                    const isStatusCodeValid = statusCode
                        ? validateStatusCode(statusCode)
                        : false;
                    const isServerError = statusCode ? hasServerError(statusCode) : false;
                    if (isStatusCodeValid && !error) {
                        return { error, statusCode, rspBody };
                    }
                    if (isServerError) {
                        setUnavailable(endpoint, config.unreachableDuration);
                    }
                    logger.info(`${method} request failed on ${endpoint}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
                    yield sleep(config.attemptInterval);
                }
            }
        }
        // TS issue. Variable 'error' is used before being assigned.
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        return { error, statusCode, rspBody };
    });
}
//# sourceMappingURL=failoverStrategies.js.map