var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { GetBridFromChainException } from "./errors";
import { abortOnError, singleEndpoint, tryNextOnError, } from "./failoverStrategies";
import { Method } from "./enums";
import { defaultFailoverConfig } from "../blockchainClient/utils";
import { FailoverStrategy } from "../blockchainClient/enums";
export function getBlockchainRidFromIid(endpointPool, chainId, failOverConfig = defaultFailoverConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = {
            endpointPool,
            statusPollInterval: 500,
            statusPollCount: 20,
            failoverStrategy: failOverConfig.strategy || defaultFailoverConfig.strategy,
            attemptsPerEndpoint: failOverConfig.attemptsPerEndpoint ||
                defaultFailoverConfig.attemptsPerEndpoint,
            attemptInterval: failOverConfig.attemptInterval || defaultFailoverConfig.attemptInterval,
            unreachableDuration: failOverConfig.unreachableDuration ||
                defaultFailoverConfig.unreachableDuration,
        };
        const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `/brid/iid_${chainId}`, config);
        if (error) {
            throw new GetBridFromChainException(chainId, error.message);
        }
        else if (statusCode !== 200) {
            throw new GetBridFromChainException(chainId, rspBody);
        }
        return rspBody;
    });
}
export function requestWithRetry(method, path, config, postObject) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (config.failoverStrategy) {
            case FailoverStrategy.AbortOnError:
                return yield abortOnError({ method, path, config, postObject });
            case FailoverStrategy.TryNextOnError:
                return yield tryNextOnError({ method, path, config, postObject });
            case FailoverStrategy.SingleEndpoint:
                return yield singleEndpoint({ method, path, config, postObject });
        }
    });
}
export function nextEndpoint(endpointPool) {
    return endpointPool[Math.floor(Math.random() * endpointPool.length)];
}
export const shuffle = (array) => {
    const shuffledArray = [...array];
    for (let i = shuffledArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
    }
    return shuffledArray;
};
export const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
export function convertToPrintable(responseObject) {
    if (typeof responseObject === "bigint") {
        return `${responseObject}n`;
    }
    else if (typeof responseObject === "object") {
        return JSON.stringify(responseObject, (key, value) => typeof value === "bigint" ? `${value}n` : value);
    }
    else {
        return responseObject;
    }
}
export function filterReachableEndpoint(endpointPool) {
    return endpointPool.filter((endpoint) => isReachable(endpoint));
}
export function isReachable(endpoint) {
    return new Date().getTime() > endpoint.whenAvailable;
}
export const bftMajority = (n) => n - (n - 1) / 3;
export const setEndpointAsReachable = (endpointPool) => {
    endpointPool.forEach((endpoint) => {
        endpoint.whenAvailable = 0;
    });
};
export const setUnavailable = (endpoint, unreachableDuration) => {
    endpoint.whenAvailable = new Date().getTime() + unreachableDuration;
};
//# sourceMappingURL=restclientutil.js.map