/**
 *
 * @param {Array} pathElements
 */
export function Path(pathElements: any[]): void;
export class Path {
    /**
     *
     * @param {Array} pathElements
     */
    constructor(pathElements: any[]);
    pathElements: any[];
    /**
     *
     */
    getCurrentPathElement(): any;
    /**
     *
     */
    size(): number;
    /**
     *
     */
    tail(): Path;
    debugString(): string;
    /**
     * @param {Path} other
     */
    equals(other: Path): boolean;
}
export function PathElement(previous: any): void;
export class PathElement {
    constructor(previous: any);
    previous: any;
    getSearchKey(): void;
}
export function PathLeafElement(previous: any): void;
export class PathLeafElement {
    constructor(previous: any);
    equals(other: any): boolean;
}
/**
 *
 * @param {SearchablePathElement} previous
 * @param {number} index
 */
export function ArrayPathElement(previous: SearchablePathElement, index: number): void;
export class ArrayPathElement {
    /**
     *
     * @param {SearchablePathElement} previous
     * @param {number} index
     */
    constructor(previous: SearchablePathElement, index: number);
    index: number;
    getSearchKey(): number;
    /**
     * @param {ArrayPathElement} other
     */
    equals(other: ArrayPathElement): boolean;
}
export function SearchablePathElement(previous: any): void;
export class SearchablePathElement {
    constructor(previous: any);
    getSearchKey(): void;
}
/**
 *
 * @param {SearchablePathElement} previous
 * @param {string} key
 */
export function DictPathElement(previous: SearchablePathElement, key: string): void;
export class DictPathElement {
    /**
     *
     * @param {SearchablePathElement} previous
     * @param {string} key
     */
    constructor(previous: SearchablePathElement, key: string);
    key: string;
    getSearchKey(): string;
    /**
     * @param {DictPathElement} other
     */
    equals(other: DictPathElement): boolean;
}
/**
 *
 * @param {Array} paths
 */
export function PathSet(paths: any[]): void;
export class PathSet {
    /**
     *
     * @param {Array} paths
     */
    constructor(paths: any[]);
    paths: any[];
    /**
     *
     */
    isEmpty(): boolean;
    /**
     *
     */
    getPathLeafOrElseAnyCurrentPathElement(): null;
    /**
     * Yeah, this might be a completely un-needed check (but it MIGHT save us later on if we forget this rule).
     * What we are looking for here is an impossible state where two paths in the same set don't have the same parent.
     * (Since we usually only have one path in a path set, this check should be cheap)
     *
     * @param {Path} currPath
     * @param {PathElement} currElem
     * @param {Path} prevPath
     * @param {PathElement} prevElem
     */
    errorCheckUnequalParent(currPath: Path, currElem: PathElement, prevPath: Path, prevElem: PathElement): {
        path: Path;
        elem: PathElement;
    };
    /**
     *
     */
    keepOnlyArrayPaths(): PathSet;
    /**
     *
     */
    keepOnlyDictPaths(): PathSet;
    /**
     *
     */
    getTailIfFirstElementIsArrayOfThisIndexFromList(index: any): PathSet;
    /**
     *
     */
    getTailIfFirstElementIsDictOfThisKeyFromList(key: any): PathSet;
    /**
     *
     */
    getTailFromList(searchKey: any, filterFunc: any): PathSet;
}
/**
 * @param {number} index
 * @param {Path} path
 */
export function getTailIfFirstElementIsArrayOfThisIndex(index: number, path: Path): Path | null;
/**
 *
 * @param {Array} arr
 */
export function buildPathFromArray(arr: any[]): Path;
