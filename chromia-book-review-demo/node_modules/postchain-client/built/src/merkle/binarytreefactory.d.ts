/**
 * The factory does the conversion between list of elements and tree of elements.
 *
 * Note: The idea is that you should sub class for each type of element you want to build.
 */
export function BinaryTreeFactory(): void;
export class BinaryTreeFactory {
    /**
     * Transforms the incoming leaf into an [BinaryTreeElement]
     * The idea with this function is that it can be recursive (if the leaf in turn is complex object with sub objects).
     *
     * Note: If we don't have a path here we can try to find the leaf in the cache.
     *
     * @param leaf the raw data we should wrap in a leaf
     * @param paths a collection of proof paths that might point to this leaf
     * @return the resulting [BinaryTreeElement] the leaf got converted to
     */
    handleLeaf(leaf: any, paths: any, isRoot?: boolean): Leaf | ArrayHeadNode | DictHeadNode;
    /**
     *
     */
    getEmptyPathSet(): PathSet;
    /**
     * At this point we should have looked in cache.
     *
     * @param leaf we should turn into a tree element
     * @param {PathSet} paths
     * @return the tree element we created.
     */
    innerHandleLeaf(leaf: any, paths: PathSet): Leaf | ArrayHeadNode | DictHeadNode;
    /**
     * Just like [handleLeaf] but we know that this leaf should not be a complex type, but something we can
     * immediately wrap
     *
     * @param leaf
     * @param {PathSet} paths
     */
    handlePrimitiveLeaf(leaf: any, paths: PathSet): Leaf;
    /**
     * Calls itself until the return value only holds 1 element
     *
     * Note: This method can only create standard [Node] that fills up the area between the "top" and the leaves.
     *        These "in-between" nodes cannot be "path leaf" or have any interesting properties.
     *
     * @param layer What layer we aim calculate
     * @param inList The args of nodes we should build from
     * @return All [BinaryTreeElement] nodes of the next layer
     */
    buildHigherLayer(layer: any, inList: any): any;
    build(data: any): BinaryTree;
    /**
     * @param {PathSet} paths
     */
    buildWithPath(data: any, paths: PathSet): BinaryTree;
    /**
     * @param {Array} array
     * @param {PathSet} paths
     */
    buildFromArray(array: any[], paths: PathSet): ArrayHeadNode;
    /**
     *
     */
    buildFromOneLeaf(array: any, orgRoot: any, pathElem: any): ArrayHeadNode;
    /**
     * @param {PathSet} paths
     */
    buildLeafElements(leafList: any, paths: PathSet): any[];
    /**
     * @param {PathSet} paths
     */
    buildFromDictionary(dict: any, paths: PathSet): DictHeadNode;
    /**
     * @param {PathSet} paths
     */
    buildLeafElementFromDict(keys: any, dict: any, paths: PathSet): any[];
}
import Leaf_1 = require("./binarytree");
import Leaf = Leaf_1.Leaf;
import ArrayHeadNode_1 = require("./binarytree");
import ArrayHeadNode = ArrayHeadNode_1.ArrayHeadNode;
import DictHeadNode_1 = require("./binarytree");
import DictHeadNode = DictHeadNode_1.DictHeadNode;
import PathSet_1 = require("./path");
import PathSet = PathSet_1.PathSet;
import BinaryTree_1 = require("./binarytree");
import BinaryTree = BinaryTree_1.BinaryTree;
