(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('buffer'), require('events'), require('string_decoder')) :
	typeof define === 'function' && define.amd ? define(['exports', 'buffer', 'events', 'string_decoder'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["Postchain client"] = {}, global.require$$0$3, global.require$$0$4, global.require$$2$1));
})(this, (function (exports, require$$0$3, require$$0$4, require$$2$1) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
					var args = [null];
					args.push.apply(args, arguments);
					var Ctor = Function.bind.apply(f, args);
					return new Ctor();
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	// eslint-disable-next-line @typescript-eslint/no-var-requires
	const asn$1 = require("@chromia/asn1/lib/asn1");
	const ASNDictPair = asn$1.define("DictPair", function () {
	    this.seq().obj(this.key("name").utf8str(), this.key("value").use(rawGTV));
	});
	const rawGTV = asn$1.define("GtvValue", function () {
	    this.choice({
	        null: this.explicit(0).null_(),
	        byteArray: this.explicit(1).octstr(),
	        string: this.explicit(2).utf8str(),
	        integer: this.explicit(3).int(),
	        dict: this.explicit(4).seqof(ASNDictPair),
	        array: this.explicit(5).seqof(rawGTV),
	        bigInteger: this.explicit(6).int(),
	    });
	});
	asn$1.define("Buffer", function () {
	    this.octstr();
	});

	var bn$2 = {exports: {}};

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _nodeResolve_empty
	});

	var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	bn$2.exports;

	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = require$$0$2.Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & ~0x1fff) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, commonjsGlobal); 
	} (bn$2));

	var bnExports$2 = bn$2.exports;

	class CustomError extends Error {
	    constructor(message, status) {
	        super(message);
	        this.name = this.constructor.name;
	        this.status = status;
	    }
	}

	class UnexpectedArgumentTypeError extends CustomError {
	    constructor(typedArg) {
	        super(`Cannot parse typedArg ${JSON.stringify(typedArg)}. Unknown type ${typedArg.type}`, 400);
	    }
	}
	class MissingGtxException extends CustomError {
	    constructor() {
	        super(`Missing instance of gtx protocol (used for communicating with postchain) to add operation to`, 400);
	    }
	}
	class AlreadySignedTransactionException extends CustomError {
	    constructor(operation) {
	        super(`Cannot add ${operation} calls to an already signed gtx`, 400);
	    }
	}
	class NumberOfSignersAndSignaturesException extends CustomError {
	    constructor() {
	        super(`Not matching number of signers and signatures`, 400);
	    }
	}
	class MissingSignerException extends CustomError {
	    constructor() {
	        super(`No such signer, remember to add signer to transaction before adding a signature`, 400);
	    }
	}

	var __rest = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	function pgBytes(buffer) {
	    if (!require$$0$3.Buffer.isBuffer(buffer)) {
	        throw new PgBytesInputException(buffer);
	    }
	    return `\\x${buffer.toString("hex")}`;
	}
	/**
	 * Converts hex string to Buffer
	 * @param key: string
	 * @returns {Buffer}
	 */
	function toBuffer$3(key) {
	    return require$$0$3.Buffer.from(key, "hex");
	}
	/**
	 * Converts Buffer to hex string
	 * @param buffer: Buffer
	 * @returns {string}
	 */
	function toString(buffer) {
	    return buffer.toString("hex").toUpperCase();
	}
	function toQueryObjectGTV(nameOrObject, queryArguments) {
	    let name;
	    if (typeof nameOrObject === "string") {
	        name = nameOrObject;
	        return [name, Object.assign({}, queryArguments)];
	    }
	    else {
	        const objectCopy = Object.assign({}, nameOrObject);
	        const { type } = objectCopy, restProps = __rest(objectCopy, ["type"]);
	        return [type, restProps];
	    }
	}
	class PgBytesInputException extends Error {
	    constructor(buffer) {
	        super(`util.pgBytes expects a buffer, but got ${typeof buffer}`);
	    }
	}
	function ensureBuffer(value) {
	    if (value instanceof require$$0$3.Buffer) {
	        return value;
	    }
	    else {
	        return toBuffer$3(value);
	    }
	}
	function checkGtvType(value) {
	    try {
	        if (value == null) {
	            return true;
	        }
	        if (require$$0$3.Buffer.isBuffer(value)) {
	            return true;
	        }
	        if (typeof value === "string") {
	            return true;
	        }
	        if (typeof value === "number") {
	            if (!Number.isInteger(value)) {
	                throw Error("User error: Only integers are supported");
	            }
	            return true;
	        }
	        if (typeof value === "bigint") {
	            return true;
	        }
	        if (value.constructor === Array) {
	            value.map((item) => checkGtvType(item));
	            return true;
	        }
	        if (typeof value === "object") {
	            Object.keys(value).map(function (key) {
	                checkGtvType(value[key]);
	            });
	            return true;
	        }
	    }
	    catch (error) {
	        throw new Error(`Failed to check type: ${error}`);
	    }
	    return false;
	}
	function rawGtxToGtx(rawGtx) {
	    const rawGtxBody = rawGtx[0];
	    const signatures = rawGtx[1];
	    const gtxBody = {
	        blockchainRid: rawGtxBody[0],
	        operations: rawGtxBody[1].map((operation) => ({
	            opName: operation[0],
	            args: operation[1],
	        })),
	        signers: rawGtxBody[2],
	    };
	    return {
	        blockchainRid: gtxBody.blockchainRid,
	        operations: gtxBody.operations,
	        signers: gtxBody.signers,
	        signatures,
	    };
	}
	function rawGtxToRawGtxBody(rawGtx) {
	    return rawGtx[0];
	}
	function checkGtxType(value) {
	    try {
	        rawGtxToGtx(value);
	        return true;
	    }
	    catch (error) {
	        return false;
	    }
	}
	function removeDuplicateSigners(signers) {
	    const signersAsString = [];
	    signers.forEach((item) => {
	        const itemAsString = item.toString("hex");
	        if (!signersAsString.includes(itemAsString)) {
	            signersAsString.push(itemAsString);
	        }
	    });
	    const result = [];
	    signersAsString.forEach((item) => {
	        result.push(require$$0$3.Buffer.from(item, "hex"));
	    });
	    return result;
	}
	function matchRellErrorString(rellError) {
	    const parsed = rellError.match(/\[([^\]]+)\]\sOperation\s'([^']+)'\sfailed:\s(.+)$/);
	    if (!parsed)
	        return {};
	    const [rellLine, operation, shortReason] = parsed.slice(1);
	    return { shortReason, rellLine, operation };
	}

	var formatter = /*#__PURE__*/Object.freeze({
		__proto__: null,
		PgBytesInputException: PgBytesInputException,
		checkGtvType: checkGtvType,
		checkGtxType: checkGtxType,
		ensureBuffer: ensureBuffer,
		matchRellErrorString: matchRellErrorString,
		pgBytes: pgBytes,
		rawGtxToGtx: rawGtxToGtx,
		rawGtxToRawGtxBody: rawGtxToRawGtxBody,
		removeDuplicateSigners: removeDuplicateSigners,
		toBuffer: toBuffer$3,
		toQueryObjectGTV: toQueryObjectGTV,
		toString: toString
	});

	function encodeValue(rawGtv) {
	    return rawGTV.encode(createTypedArg(rawGtv));
	}
	function encodeValueGtx(rawGtx) {
	    return encodeValue(rawGtx);
	}
	function decodeValue(bytes) {
	    //TODO add a try catch to catch asn1 errors to be more readable error
	    const obj = rawGTV.decode(bytes);
	    return parseValue(obj);
	}
	function decodeValueGtx(bytes) {
	    const decodedValue = decodeValue(bytes);
	    if (!checkGtxType(decodedValue)) {
	        throw new Error(`Unexpected type of value: ${decodedValue}, expected decoded value to be of type RawGtx`);
	    }
	    return decodedValue;
	}
	function parseValue(typedArg) {
	    var _a, _b;
	    if (typedArg.type === "null") {
	        return null;
	    }
	    else if (typedArg.type === "byteArray") {
	        return typedArg.value;
	    }
	    else if (typedArg.type === "string") {
	        return typedArg.value;
	    }
	    else if (typedArg.type === "integer") {
	        return Number(typedArg.value);
	    }
	    else if (typedArg.type === "array") {
	        const arrayValue = typedArg.value;
	        return arrayValue.map((item) => parseValue(item));
	    }
	    else if (typedArg.type === "bigInteger") {
	        return BigInt((_b = (_a = typedArg.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "");
	    }
	    else if (typedArg.type === "dict") {
	        const arrayValue = typedArg.value;
	        const result = {};
	        arrayValue.forEach((pair) => {
	            result[pair.name] = parseValue(pair.value);
	        });
	        return result;
	    }
	    else {
	        throw new UnexpectedArgumentTypeError(typedArg);
	    }
	}
	function createTypedArg(value) {
	    try {
	        if (value == null) {
	            return { type: "null", value: null };
	        }
	        if (require$$0$3.Buffer.isBuffer(value)) {
	            return { type: "byteArray", value: value };
	        }
	        if (typeof value === "boolean") {
	            return { type: "integer", value: value ? 1 : 0 };
	        }
	        if (typeof value === "string") {
	            return { type: "string", value: value };
	        }
	        if (typeof value === "number") {
	            if (!Number.isInteger(value)) {
	                throw Error("User error: Only integers are supported");
	            }
	            return { type: "integer", value: new bnExports$2.BN(value) };
	        }
	        if (typeof value === "bigint") {
	            return { type: "bigInteger", value: new bnExports$2.BN(value.toString()) };
	        }
	        if (value.constructor === Array) {
	            return {
	                type: "array",
	                value: value.map((item) => createTypedArg(item)),
	            };
	        }
	        if (typeof value === "object") {
	            let valueAsDictPair = value;
	            if (isDictPairWithStringKey(valueAsDictPair)) {
	                valueAsDictPair = sortDictPairByKey(valueAsDictPair);
	            }
	            return {
	                type: "dict",
	                value: Object.keys(valueAsDictPair).map(function (key) {
	                    return { name: key, value: createTypedArg(valueAsDictPair[key]) };
	                }),
	            };
	        }
	    }
	    catch (error) {
	        const message = value ? value.toString() : "RawGtv";
	        throw new Error(`Failed to encode ${message}: ${error}`);
	    }
	    throw new Error(`value ${value} have unsupported type: ${typeof value}`);
	}
	function isDictPairWithStringKey(obj) {
	    for (const key in obj) {
	        if (typeof key !== "string") {
	            return false;
	        }
	    }
	    return true;
	}
	function sortDictPairByKey(dict) {
	    const sortedArray = Object.entries(dict).sort(([keyA], [keyB]) => {
	        if (keyA < keyB) {
	            return -1;
	        }
	        if (keyA > keyB) {
	            return 1;
	        }
	        return 0;
	    });
	    const sortedDict = {};
	    for (const [key, value] of sortedArray) {
	        sortedDict[key] = value;
	    }
	    return sortedDict;
	}

	var serialization$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createTypedArg: createTypedArg,
		decodeValue: decodeValue,
		decodeValueGtx: decodeValueGtx,
		encodeValue: encodeValue,
		encodeValueGtx: encodeValueGtx,
		parseValue: parseValue
	});

	var require$$1$2 = /*@__PURE__*/getAugmentedNamespace(serialization$1);

	var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(formatter);

	var util$2 = require$$0$1;
	function PathElement(previous) {
	    this.previous = previous;
	}
	PathElement.prototype.getSearchKey = function () { };
	function PathLeafElement$3(previous) {
	    PathElement.call(this, previous);
	}
	PathLeafElement$3.prototype = Object.create(PathElement.prototype);
	PathLeafElement$3.prototype.constructor = PathLeafElement$3;
	PathLeafElement$3.prototype.equals = function (other) {
	    if (this === other)
	        return true;
	    if (typeof this !== typeof other)
	        return false;
	    return true;
	};
	function SearchablePathElement(previous) {
	    PathElement.call(this, previous);
	}
	SearchablePathElement.prototype = Object.create(PathElement.prototype);
	SearchablePathElement.prototype.constructor = SearchablePathElement;
	SearchablePathElement.prototype.getSearchKey = function () { };
	/**
	 *
	 * @param {SearchablePathElement} previous
	 * @param {number} index
	 */
	function ArrayPathElement(previous, index) {
	    SearchablePathElement.call(this, previous);
	    this.index = index;
	}
	ArrayPathElement.prototype = Object.create(SearchablePathElement.prototype);
	ArrayPathElement.prototype.constructor = ArrayPathElement;
	ArrayPathElement.prototype.getSearchKey = function () {
	    return this.index;
	};
	/**
	 * @param {ArrayPathElement} other
	 */
	ArrayPathElement.prototype.equals = function (other) {
	    if (this === other)
	        return true;
	    if (typeof this !== typeof other)
	        return false;
	    if (this.index != other.index)
	        return false;
	    return true;
	};
	/**
	 *
	 * @param {SearchablePathElement} previous
	 * @param {string} key
	 */
	function DictPathElement(previous, key) {
	    SearchablePathElement.call(this, previous);
	    this.key = key;
	}
	DictPathElement.prototype = Object.create(SearchablePathElement.prototype);
	DictPathElement.prototype.constructor = DictPathElement;
	DictPathElement.prototype.getSearchKey = function () {
	    return this.key;
	};
	/**
	 * @param {DictPathElement} other
	 */
	DictPathElement.prototype.equals = function (other) {
	    if (this === other)
	        return true;
	    if (typeof this !== typeof other)
	        return false;
	    if (this.key != other.key)
	        return false;
	    return true;
	};
	/**
	 *
	 * @param {Array} pathElements
	 */
	function Path(pathElements) {
	    this.pathElements = pathElements;
	}
	/**
	 *
	 */
	Path.prototype.getCurrentPathElement = function () {
	    return this.pathElements[0];
	};
	/**
	 *
	 */
	Path.prototype.size = function () {
	    return this.pathElements.length;
	};
	/**
	 *
	 */
	Path.prototype.tail = function () {
	    if (this.pathElements.length == 0) {
	        throw new Error("Impossible to tail this array");
	    }
	    else {
	        var tail = this.pathElements.slice(1);
	        return new Path(tail);
	    }
	};
	Path.prototype.debugString = function () {
	    var sb = "";
	    this.pathElements.forEach(elem => {
	        if (elem instanceof SearchablePathElement) {
	            sb = sb + "-> " + elem.getSearchKey();
	        }
	        else if (elem instanceof PathLeafElement$3) {
	            sb = sb + "-> Leaf";
	        }
	    });
	    return sb;
	};
	/**
	 * @param {Path} other
	 */
	Path.prototype.equals = function (other) {
	    if (this === other)
	        return true;
	    if (typeof this != typeof other)
	        return false;
	    return this.pathElements == other.pathElements;
	};
	/**
	 * @param {number} index
	 * @param {Path} path
	 */
	var getTailIfFirstElementIsArrayOfThisIndex = function (index, path) {
	    return getTail(index, path);
	};
	/**
	 *
	 * @param {string} key
	 * @param {Path} path
	 */
	var getTailIfFirstElementIsDictOfThisKey = function (key, path) {
	    return getTail(key, path);
	};
	/**
	 *
	 * @param {string|number} searchKey
	 * @param {Path} path
	 */
	var getTail = function (searchKey, path) {
	    if (searchKey === null) {
	        throw new Error("Have to provide a search key");
	    }
	    try {
	        var firstElement = path.pathElements[0];
	        if (firstElement instanceof SearchablePathElement) {
	            if (firstElement.getSearchKey() == searchKey) {
	                return path.tail();
	            }
	        }
	    }
	    catch (err) {
	        util$2.logError("Why are we dropping first element of an empty path? " + err);
	        return null;
	    }
	    return null;
	};
	/**
	 *
	 * @param {Array} paths
	 */
	function PathSet$1(paths) {
	    this.paths = paths;
	}
	/**
	 *
	 */
	PathSet$1.prototype.isEmpty = function () {
	    return this.paths.length == 0;
	};
	/**
	 *
	 */
	PathSet$1.prototype.getPathLeafOrElseAnyCurrentPathElement = function () {
	    var leafElem = null;
	    var currElem = null;
	    var prev = {
	        "path": null,
	        "elem": null,
	    };
	    this.paths.forEach(path => {
	        currElem = path.getCurrentPathElement();
	        if (currElem instanceof PathLeafElement$3) {
	            leafElem = currElem;
	        }
	        prev = this.errorCheckUnequalParent(path, currElem, prev.path, prev.elem);
	    });
	    if (leafElem != null) {
	        return leafElem;
	    }
	    else {
	        return currElem; // It doesn't matter which one we return (Next step we will get the "previous" from this one)
	    }
	};
	/**
	 * Yeah, this might be a completely un-needed check (but it MIGHT save us later on if we forget this rule).
	 * What we are looking for here is an impossible state where two paths in the same set don't have the same parent.
	 * (Since we usually only have one path in a path set, this check should be cheap)
	 *
	 * @param {Path} currPath
	 * @param {PathElement} currElem
	 * @param {Path} prevPath
	 * @param {PathElement} prevElem
	 */
	PathSet$1.prototype.errorCheckUnequalParent = function (currPath, currElem, prevPath, prevElem) {
	    if (prevElem != null) {
	        // weird: javascript cannot compare null == null then we have to compare each with null separately :(
	        if (currElem.previous == null && prevElem.previous == null) {
	            return {
	                "path": currPath,
	                "elem": currElem
	            };
	        }
	        else if ((currElem.previous == null && prevElem.previous != null) || (currElem.previous != null && prevElem.previous == null)) {
	            throw new Error("Something is wrong, these paths do not have the same parent. (" + currPath + ") (" + prevPath + ")");
	        }
	        else if (!currElem.previous.equals(prevElem.previous)) {
	            throw new Error("Something is wrong, these paths do not have the same parent. (" + currPath + ") (" + prevPath + ")");
	        }
	    }
	    return {
	        "path": currPath,
	        "elem": currElem
	    };
	};
	/**
	 *
	 */
	PathSet$1.prototype.keepOnlyArrayPaths = function () {
	    var filteredPaths = this.paths.filter(path => {
	        return path.pathElements[0] instanceof ArrayPathElement;
	    });
	    return new PathSet$1(filteredPaths);
	};
	/**
	 *
	 */
	PathSet$1.prototype.keepOnlyDictPaths = function () {
	    var filteredPaths = this.paths.filter(path => {
	        return path.pathElements[0] instanceof DictPathElement;
	    });
	    return new PathSet$1(filteredPaths);
	};
	/**
	 *
	 */
	PathSet$1.prototype.getTailIfFirstElementIsArrayOfThisIndexFromList = function (index) {
	    return this.getTailFromList(index, getTailIfFirstElementIsArrayOfThisIndex);
	};
	/**
	 *
	 */
	PathSet$1.prototype.getTailIfFirstElementIsDictOfThisKeyFromList = function (key) {
	    return this.getTailFromList(key, getTailIfFirstElementIsDictOfThisKey);
	};
	/**
	 *
	 */
	PathSet$1.prototype.getTailFromList = function (searchKey, filterFunc) {
	    var retPaths = new Array();
	    this.paths.forEach(path => {
	        var newPath = filterFunc(searchKey, path);
	        if (newPath != null) {
	            retPaths.push(newPath);
	        }
	    });
	    return new PathSet$1(retPaths);
	};
	/**
	 *
	 * @param {Array} arr
	 */
	var buildPathFromArray = function (arr) {
	    var pathElements = new Array();
	    var lastPathElem = null;
	    arr.forEach(item => {
	        var newElem = null;
	        if (typeof item === 'number') {
	            newElem = new ArrayPathElement(lastPathElem, item);
	        }
	        else if (typeof item === 'string') {
	            newElem = new DictPathElement(lastPathElem, item);
	        }
	        else {
	            throw new Error("A path structure must only consist of Ints and Strings, not " + item);
	        }
	        pathElements.push(newElem);
	        lastPathElem = newElem;
	    });
	    var lastOne = lastPathElem;
	    pathElements.push(new PathLeafElement$3(lastOne));
	    return new Path(pathElements);
	};
	var path = { Path, PathElement, PathLeafElement: PathLeafElement$3, ArrayPathElement, SearchablePathElement, DictPathElement, PathSet: PathSet$1,
	    getTailIfFirstElementIsArrayOfThisIndex, buildPathFromArray };

	var PathLeafElement$2 = path.PathLeafElement;
	const HASH_PREFIX_NODE$1 = 0;
	const HASH_PREFIX_LEAF$1 = 1;
	const HASH_PREFIX_NODE_ARRAY$1 = 7;
	const HASH_PREFIX_NODE_DICT$1 = 8;
	/**
	 *
	 */
	function BinaryTreeElement() {
	    this.pathElem = null;
	}
	BinaryTreeElement.prototype.isPath = function () {
	    return this.pathElem != null;
	};
	BinaryTreeElement.prototype.isPathLeaf = function () {
	    if (this.pathElem == null) {
	        return false;
	    }
	    if (this.pathElem instanceof PathLeafElement$2) {
	        return true;
	    }
	    else {
	        return false;
	    }
	};
	BinaryTreeElement.prototype.setPathElement = function (pathElem) {
	    this.pathElem = pathElem;
	};
	BinaryTreeElement.prototype.getPrefixByte = function () {
	    return HASH_PREFIX_NODE$1;
	};
	/**
	 *
	 * @param {BinaryTreeElement} left
	 * @param {BinaryTreeElement} right
	 */
	function Node$5(left, right) {
	    this.left = left;
	    this.right = right;
	}
	Node$5.prototype = Object.create(BinaryTreeElement.prototype);
	Node$5.prototype.constructor = Node$5;
	Node$5.prototype.getPrefixByte = function () {
	    return HASH_PREFIX_NODE$1;
	};
	/**
	 *
	 * @param {BinaryTreeElement} left
	 * @param {BinaryTreeElement} right
	 * @param {*} content
	 * @param {PathSet} pathElem
	 */
	function SubTreeRootNode$1(left, right, content, pathElem) {
	    Node$5.call(this, left, right);
	    this.content = content;
	    BinaryTreeElement.prototype.setPathElement.call(this, pathElem);
	}
	SubTreeRootNode$1.prototype = Object.create(Node$5.prototype);
	SubTreeRootNode$1.prototype.constructor = SubTreeRootNode$1;
	/**
	 *
	 * @param {*} content
	 * @param {PathElement} pathElem
	 */
	function Leaf$2(content, pathElem = null) {
	    this.content = content;
	    if (pathElem != null) {
	        if (pathElem instanceof PathLeafElement$2) {
	            BinaryTreeElement.prototype.setPathElement.call(this, pathElem);
	        }
	        else {
	            throw new Error("The path and object structure does not match! We are at a leaf, but the path expects a sub structure.");
	        }
	    }
	}
	Leaf$2.prototype = Object.create(BinaryTreeElement.prototype);
	Leaf$2.prototype.constructor = Leaf$2;
	Leaf$2.prototype.getPrefixByte = function () {
	    return HASH_PREFIX_LEAF$1;
	};
	function EmptyLeaf$2() { }
	EmptyLeaf$2.prototype = Object.create(BinaryTreeElement.prototype);
	EmptyLeaf$2.prototype.constructor = EmptyLeaf$2;
	/**
	 * Wrapper class for the root object.
	 * @param {BinaryTreeElement} root
	 */
	function BinaryTree$1(root) {
	    this.root = root;
	}
	BinaryTree$1.prototype.maxLevel = function () {
	    return this.maxLevelInternal(this.root);
	};
	BinaryTree$1.prototype.maxLevelInternal = function (node) {
	    if (node instanceof EmptyLeaf$2) {
	        return 0;
	    }
	    else if (node instanceof Leaf$2) {
	        return 1;
	    }
	    else if (node instanceof Node$5) {
	        return Math.max(this.maxLevelInternal(node.left), this.maxLevelInternal(node.right)) + 1;
	    }
	    else {
	        throw new Error("What is this type? " + typeof node);
	    }
	};
	/**
	 * Represents the top of a sub tree generated by a [Array]
	 *
	 * @param {*} left
	 * @param {*} right
	 * @param {*} content
	 * @param {*} size
	 * @param {PathElement} pathElem
	 */
	function ArrayHeadNode$2(left, right, content, size, pathElem = null) {
	    SubTreeRootNode$1.call(this, left, right, content, pathElem);
	    this.size = size;
	}
	ArrayHeadNode$2.prototype = Object.create(SubTreeRootNode$1.prototype);
	ArrayHeadNode$2.prototype.constructor = ArrayHeadNode$2;
	ArrayHeadNode$2.prototype.getPrefixByte = function () {
	    return HASH_PREFIX_NODE_ARRAY$1;
	};
	/**
	 * Represents the top a sub tree generated by a [Dictionary]
	 * @param {*} left
	 * @param {*} right
	 * @param {*} content
	 * @param {*} size
	 * @param {PathElement} pathElem
	 */
	function DictHeadNode$2(left, right, content, size, pathElem = null) {
	    SubTreeRootNode$1.call(this, left, right, content, pathElem);
	    this.size = size;
	}
	DictHeadNode$2.prototype = Object.create(SubTreeRootNode$1.prototype);
	DictHeadNode$2.prototype.constructor = DictHeadNode$2;
	DictHeadNode$2.prototype.getPrefixByte = function () {
	    return HASH_PREFIX_NODE_DICT$1;
	};
	var binarytree = { HASH_PREFIX_NODE: HASH_PREFIX_NODE$1, HASH_PREFIX_LEAF: HASH_PREFIX_LEAF$1, HASH_PREFIX_NODE_ARRAY: HASH_PREFIX_NODE_ARRAY$1, HASH_PREFIX_NODE_DICT: HASH_PREFIX_NODE_DICT$1,
	    Node: Node$5, Leaf: Leaf$2, EmptyLeaf: EmptyLeaf$2, SubTreeRootNode: SubTreeRootNode$1, BinaryTreeElement, BinaryTree: BinaryTree$1, ArrayHeadNode: ArrayHeadNode$2, DictHeadNode: DictHeadNode$2 };

	var cryptoBrowserify = {};

	var browser$b = {exports: {}};

	var safeBuffer$1 = {exports: {}};

	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$3;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer$1, safeBuffer$1.exports));

	var safeBufferExports = safeBuffer$1.exports;

	// limit of Crypto.getRandomValues()
	// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
	var MAX_BYTES = 65536;

	// Node supports requesting up to this number of bytes
	// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
	var MAX_UINT32 = 4294967295;

	function oldBrowser$1 () {
	  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
	}

	var Buffer$G = safeBufferExports.Buffer;
	var crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

	if (crypto$1 && crypto$1.getRandomValues) {
	  browser$b.exports = randomBytes$3;
	} else {
	  browser$b.exports = oldBrowser$1;
	}

	function randomBytes$3 (size, cb) {
	  // phantomjs needs to throw
	  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

	  var bytes = Buffer$G.allocUnsafe(size);

	  if (size > 0) {  // getRandomValues fails on IE if size == 0
	    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
	      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	      for (var generated = 0; generated < size; generated += MAX_BYTES) {
	        // buffer.slice automatically checks if the end is past the end of
	        // the buffer so we don't have to here
	        crypto$1.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
	      }
	    } else {
	      crypto$1.getRandomValues(bytes);
	    }
	  }

	  if (typeof cb === 'function') {
	    return process.nextTick(function () {
	      cb(null, bytes);
	    })
	  }

	  return bytes
	}

	var browserExports = browser$b.exports;

	var inherits_browser = {exports: {}};

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}

	var inherits_browserExports = inherits_browser.exports;

	var readableBrowser = {exports: {}};

	var streamBrowser = require$$0$4.EventEmitter;

	var buffer_list;
	var hasRequiredBuffer_list;

	function requireBuffer_list () {
		if (hasRequiredBuffer_list) return buffer_list;
		hasRequiredBuffer_list = 1;

		function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
		function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
		function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		var _require = require$$0$3,
		  Buffer = _require.Buffer;
		var _require2 = require$$0$2,
		  inspect = _require2.inspect;
		var custom = inspect && inspect.custom || 'inspect';
		function copyBuffer(src, target, offset) {
		  Buffer.prototype.copy.call(src, target, offset);
		}
		buffer_list = /*#__PURE__*/function () {
		  function BufferList() {
		    _classCallCheck(this, BufferList);
		    this.head = null;
		    this.tail = null;
		    this.length = 0;
		  }
		  _createClass(BufferList, [{
		    key: "push",
		    value: function push(v) {
		      var entry = {
		        data: v,
		        next: null
		      };
		      if (this.length > 0) this.tail.next = entry;else this.head = entry;
		      this.tail = entry;
		      ++this.length;
		    }
		  }, {
		    key: "unshift",
		    value: function unshift(v) {
		      var entry = {
		        data: v,
		        next: this.head
		      };
		      if (this.length === 0) this.tail = entry;
		      this.head = entry;
		      ++this.length;
		    }
		  }, {
		    key: "shift",
		    value: function shift() {
		      if (this.length === 0) return;
		      var ret = this.head.data;
		      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
		      --this.length;
		      return ret;
		    }
		  }, {
		    key: "clear",
		    value: function clear() {
		      this.head = this.tail = null;
		      this.length = 0;
		    }
		  }, {
		    key: "join",
		    value: function join(s) {
		      if (this.length === 0) return '';
		      var p = this.head;
		      var ret = '' + p.data;
		      while (p = p.next) ret += s + p.data;
		      return ret;
		    }
		  }, {
		    key: "concat",
		    value: function concat(n) {
		      if (this.length === 0) return Buffer.alloc(0);
		      var ret = Buffer.allocUnsafe(n >>> 0);
		      var p = this.head;
		      var i = 0;
		      while (p) {
		        copyBuffer(p.data, ret, i);
		        i += p.data.length;
		        p = p.next;
		      }
		      return ret;
		    }

		    // Consumes a specified amount of bytes or characters from the buffered data.
		  }, {
		    key: "consume",
		    value: function consume(n, hasStrings) {
		      var ret;
		      if (n < this.head.data.length) {
		        // `slice` is the same for buffers and strings.
		        ret = this.head.data.slice(0, n);
		        this.head.data = this.head.data.slice(n);
		      } else if (n === this.head.data.length) {
		        // First chunk is a perfect match.
		        ret = this.shift();
		      } else {
		        // Result spans more than one buffer.
		        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
		      }
		      return ret;
		    }
		  }, {
		    key: "first",
		    value: function first() {
		      return this.head.data;
		    }

		    // Consumes a specified amount of characters from the buffered data.
		  }, {
		    key: "_getString",
		    value: function _getString(n) {
		      var p = this.head;
		      var c = 1;
		      var ret = p.data;
		      n -= ret.length;
		      while (p = p.next) {
		        var str = p.data;
		        var nb = n > str.length ? str.length : n;
		        if (nb === str.length) ret += str;else ret += str.slice(0, n);
		        n -= nb;
		        if (n === 0) {
		          if (nb === str.length) {
		            ++c;
		            if (p.next) this.head = p.next;else this.head = this.tail = null;
		          } else {
		            this.head = p;
		            p.data = str.slice(nb);
		          }
		          break;
		        }
		        ++c;
		      }
		      this.length -= c;
		      return ret;
		    }

		    // Consumes a specified amount of bytes from the buffered data.
		  }, {
		    key: "_getBuffer",
		    value: function _getBuffer(n) {
		      var ret = Buffer.allocUnsafe(n);
		      var p = this.head;
		      var c = 1;
		      p.data.copy(ret);
		      n -= p.data.length;
		      while (p = p.next) {
		        var buf = p.data;
		        var nb = n > buf.length ? buf.length : n;
		        buf.copy(ret, ret.length - n, 0, nb);
		        n -= nb;
		        if (n === 0) {
		          if (nb === buf.length) {
		            ++c;
		            if (p.next) this.head = p.next;else this.head = this.tail = null;
		          } else {
		            this.head = p;
		            p.data = buf.slice(nb);
		          }
		          break;
		        }
		        ++c;
		      }
		      this.length -= c;
		      return ret;
		    }

		    // Make sure the linked list only shows the minimal necessary information.
		  }, {
		    key: custom,
		    value: function value(_, options) {
		      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
		        // Only inspect one level.
		        depth: 0,
		        // It should not recurse.
		        customInspect: false
		      }));
		    }
		  }]);
		  return BufferList;
		}();
		return buffer_list;
	}

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	var destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};

	var errorsBrowser = {};

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	var codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage(arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message;
	    } else {
	      return message(arg1, arg2, arg3);
	    }
	  }

	  var NodeError =
	  /*#__PURE__*/
	  function (_Base) {
	    _inheritsLoose(NodeError, _Base);

	    function NodeError(arg1, arg2, arg3) {
	      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
	    }

	    return NodeError;
	  }(Base);

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;
	  codes[code] = NodeError;
	} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    var len = expected.length;
	    expected = expected.map(function (i) {
	      return String(i);
	    });

	    if (len > 2) {
	      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
	    } else if (len === 2) {
	      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
	    } else {
	      return "of ".concat(thing, " ").concat(expected[0]);
	    }
	  } else {
	    return "of ".concat(thing, " ").concat(String(expected));
	  }
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


	function startsWith(str, search, pos) {
	  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }

	  return str.substring(this_len - search.length, this_len) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"';
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  var determiner;

	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  var msg;

	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  } else {
	    var type = includes(name, '.') ? 'property' : 'argument';
	    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  }

	  msg += ". Received type ".concat(typeof actual);
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented';
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg;
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
	errorsBrowser.codes = codes;

	var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	var state = {
	  getHighWaterMark: getHighWaterMark
	};

	var browser$a;
	var hasRequiredBrowser$3;

	function requireBrowser$3 () {
		if (hasRequiredBrowser$3) return browser$a;
		hasRequiredBrowser$3 = 1;
		/**
		 * Module exports.
		 */

		browser$a = deprecate;

		/**
		 * Mark that a method should not be used.
		 * Returns a modified function which warns once by default.
		 *
		 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
		 *
		 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
		 * will throw an Error when invoked.
		 *
		 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
		 * will invoke `console.trace()` instead of `console.error()`.
		 *
		 * @param {Function} fn - the function to deprecate
		 * @param {String} msg - the string to print to the console when `fn` is invoked
		 * @returns {Function} a new "deprecated" version of `fn`
		 * @api public
		 */

		function deprecate (fn, msg) {
		  if (config('noDeprecation')) {
		    return fn;
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (config('throwDeprecation')) {
		        throw new Error(msg);
		      } else if (config('traceDeprecation')) {
		        console.trace(msg);
		      } else {
		        console.warn(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		}

		/**
		 * Checks `localStorage` for boolean values for the given `name`.
		 *
		 * @param {String} name
		 * @returns {Boolean}
		 * @api private
		 */

		function config (name) {
		  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
		  try {
		    if (!commonjsGlobal.localStorage) return false;
		  } catch (_) {
		    return false;
		  }
		  var val = commonjsGlobal.localStorage[name];
		  if (null == val) return false;
		  return String(val).toLowerCase() === 'true';
		}
		return browser$a;
	}

	var _stream_writable;
	var hasRequired_stream_writable;

	function require_stream_writable () {
		if (hasRequired_stream_writable) return _stream_writable;
		hasRequired_stream_writable = 1;

		_stream_writable = Writable;

		// It seems a linked list but it is not
		// there will be only 2 of these for each stream
		function CorkedRequest(state) {
		  var _this = this;
		  this.next = null;
		  this.entry = null;
		  this.finish = function () {
		    onCorkedFinish(_this, state);
		  };
		}
		/* </replacement> */

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Writable.WritableState = WritableState;

		/*<replacement>*/
		var internalUtil = {
		  deprecate: requireBrowser$3()
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = streamBrowser;
		/*</replacement>*/

		var Buffer = require$$0$3.Buffer;
		var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}
		var destroyImpl = destroy_1;
		var _require = state,
		  getHighWaterMark = _require.getHighWaterMark;
		var _require$codes = errorsBrowser.codes,
		  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
		  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
		  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
		  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
		  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
		  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
		  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
		  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
		var errorOrDestroy = destroyImpl.errorOrDestroy;
		inherits_browserExports(Writable, Stream);
		function nop() {}
		function WritableState(options, stream, isDuplex) {
		  Duplex = Duplex || require_stream_duplex();
		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream,
		  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
		  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

		  // object stream flag to indicate whether or not this stream
		  // contains buffers or objects.
		  this.objectMode = !!options.objectMode;
		  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

		  // the point at which write() starts returning false
		  // Note: 0 is a valid value, means that we always return false if
		  // the entire buffer is not flushed immediately on write()
		  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

		  // if _final has been called
		  this.finalCalled = false;

		  // drain event flag.
		  this.needDrain = false;
		  // at the start of calling end()
		  this.ending = false;
		  // when end() has been called, and returned
		  this.ended = false;
		  // when 'finish' is emitted
		  this.finished = false;

		  // has it been destroyed
		  this.destroyed = false;

		  // should we decode strings into buffers before passing to _write?
		  // this is here so that some node-core streams can optimize string
		  // handling at a lower level.
		  var noDecode = options.decodeStrings === false;
		  this.decodeStrings = !noDecode;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // not an actual buffer we keep track of, but a measurement
		  // of how much we're waiting to get pushed to some underlying
		  // socket or file.
		  this.length = 0;

		  // a flag to see when we're in the middle of a write.
		  this.writing = false;

		  // when true all writes will be buffered until .uncork() call
		  this.corked = 0;

		  // a flag to be able to tell if the onwrite cb is called immediately,
		  // or on a later tick.  We set this to true at first, because any
		  // actions that shouldn't happen until "later" should generally also
		  // not happen before the first write call.
		  this.sync = true;

		  // a flag to know if we're processing previously buffered items, which
		  // may call the _write() callback in the same tick, so that we don't
		  // end up in an overlapped onwrite situation.
		  this.bufferProcessing = false;

		  // the callback that's passed to _write(chunk,cb)
		  this.onwrite = function (er) {
		    onwrite(stream, er);
		  };

		  // the callback that the user supplies to write(chunk,encoding,cb)
		  this.writecb = null;

		  // the amount that is being written when _write is called.
		  this.writelen = 0;
		  this.bufferedRequest = null;
		  this.lastBufferedRequest = null;

		  // number of pending user-supplied write callbacks
		  // this must be 0 before 'finish' can be emitted
		  this.pendingcb = 0;

		  // emit prefinish if the only thing we're waiting for is _write cbs
		  // This is relevant for synchronous Transform streams
		  this.prefinished = false;

		  // True if the error was already emitted and should not be thrown again
		  this.errorEmitted = false;

		  // Should close be emitted on destroy. Defaults to true.
		  this.emitClose = options.emitClose !== false;

		  // Should .destroy() be called after 'finish' (and potentially 'end')
		  this.autoDestroy = !!options.autoDestroy;

		  // count buffered requests
		  this.bufferedRequestCount = 0;

		  // allocate the first CorkedRequest, there is always
		  // one allocated and free to use, and we maintain at most two
		  this.corkedRequestsFree = new CorkedRequest(this);
		}
		WritableState.prototype.getBuffer = function getBuffer() {
		  var current = this.bufferedRequest;
		  var out = [];
		  while (current) {
		    out.push(current);
		    current = current.next;
		  }
		  return out;
		};
		(function () {
		  try {
		    Object.defineProperty(WritableState.prototype, 'buffer', {
		      get: internalUtil.deprecate(function writableStateBufferGetter() {
		        return this.getBuffer();
		      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
		    });
		  } catch (_) {}
		})();

		// Test _writableState for inheritance to account for Duplex streams,
		// whose prototype chain only points to Readable.
		var realHasInstance;
		if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
		  realHasInstance = Function.prototype[Symbol.hasInstance];
		  Object.defineProperty(Writable, Symbol.hasInstance, {
		    value: function value(object) {
		      if (realHasInstance.call(this, object)) return true;
		      if (this !== Writable) return false;
		      return object && object._writableState instanceof WritableState;
		    }
		  });
		} else {
		  realHasInstance = function realHasInstance(object) {
		    return object instanceof this;
		  };
		}
		function Writable(options) {
		  Duplex = Duplex || require_stream_duplex();

		  // Writable ctor is applied to Duplexes, too.
		  // `realHasInstance` is necessary because using plain `instanceof`
		  // would return false, as no `_writableState` property is attached.

		  // Trying to use the custom `instanceof` for Writable here will also break the
		  // Node.js LazyTransform implementation, which has a non-trivial getter for
		  // `_writableState` that would lead to infinite recursion.

		  // Checking for a Stream.Duplex instance is faster here instead of inside
		  // the WritableState constructor, at least with V8 6.5
		  var isDuplex = this instanceof Duplex;
		  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
		  this._writableState = new WritableState(options, this, isDuplex);

		  // legacy.
		  this.writable = true;
		  if (options) {
		    if (typeof options.write === 'function') this._write = options.write;
		    if (typeof options.writev === 'function') this._writev = options.writev;
		    if (typeof options.destroy === 'function') this._destroy = options.destroy;
		    if (typeof options.final === 'function') this._final = options.final;
		  }
		  Stream.call(this);
		}

		// Otherwise people can pipe Writable streams, which is just wrong.
		Writable.prototype.pipe = function () {
		  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
		};
		function writeAfterEnd(stream, cb) {
		  var er = new ERR_STREAM_WRITE_AFTER_END();
		  // TODO: defer error events consistently everywhere, not just the cb
		  errorOrDestroy(stream, er);
		  process.nextTick(cb, er);
		}

		// Checks that a user-supplied chunk is valid, especially for the particular
		// mode the stream is in. Currently this means that `null` is never accepted
		// and undefined/non-string values are only allowed in object mode.
		function validChunk(stream, state, chunk, cb) {
		  var er;
		  if (chunk === null) {
		    er = new ERR_STREAM_NULL_VALUES();
		  } else if (typeof chunk !== 'string' && !state.objectMode) {
		    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
		  }
		  if (er) {
		    errorOrDestroy(stream, er);
		    process.nextTick(cb, er);
		    return false;
		  }
		  return true;
		}
		Writable.prototype.write = function (chunk, encoding, cb) {
		  var state = this._writableState;
		  var ret = false;
		  var isBuf = !state.objectMode && _isUint8Array(chunk);
		  if (isBuf && !Buffer.isBuffer(chunk)) {
		    chunk = _uint8ArrayToBuffer(chunk);
		  }
		  if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }
		  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
		  if (typeof cb !== 'function') cb = nop;
		  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
		    state.pendingcb++;
		    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
		  }
		  return ret;
		};
		Writable.prototype.cork = function () {
		  this._writableState.corked++;
		};
		Writable.prototype.uncork = function () {
		  var state = this._writableState;
		  if (state.corked) {
		    state.corked--;
		    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		  }
		};
		Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		  // node::ParseEncoding() requires lower case.
		  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
		  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
		  this._writableState.defaultEncoding = encoding;
		  return this;
		};
		Object.defineProperty(Writable.prototype, 'writableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState && this._writableState.getBuffer();
		  }
		});
		function decodeChunk(state, chunk, encoding) {
		  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
		    chunk = Buffer.from(chunk, encoding);
		  }
		  return chunk;
		}
		Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.highWaterMark;
		  }
		});

		// if we're already writing something, then just put this
		// in the queue, and wait our turn.  Otherwise, call _write
		// If we return false, then we need a drain event, so set that flag.
		function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
		  if (!isBuf) {
		    var newChunk = decodeChunk(state, chunk, encoding);
		    if (chunk !== newChunk) {
		      isBuf = true;
		      encoding = 'buffer';
		      chunk = newChunk;
		    }
		  }
		  var len = state.objectMode ? 1 : chunk.length;
		  state.length += len;
		  var ret = state.length < state.highWaterMark;
		  // we must ensure that previous needDrain will not be reset to false.
		  if (!ret) state.needDrain = true;
		  if (state.writing || state.corked) {
		    var last = state.lastBufferedRequest;
		    state.lastBufferedRequest = {
		      chunk: chunk,
		      encoding: encoding,
		      isBuf: isBuf,
		      callback: cb,
		      next: null
		    };
		    if (last) {
		      last.next = state.lastBufferedRequest;
		    } else {
		      state.bufferedRequest = state.lastBufferedRequest;
		    }
		    state.bufferedRequestCount += 1;
		  } else {
		    doWrite(stream, state, false, len, chunk, encoding, cb);
		  }
		  return ret;
		}
		function doWrite(stream, state, writev, len, chunk, encoding, cb) {
		  state.writelen = len;
		  state.writecb = cb;
		  state.writing = true;
		  state.sync = true;
		  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
		  state.sync = false;
		}
		function onwriteError(stream, state, sync, er, cb) {
		  --state.pendingcb;
		  if (sync) {
		    // defer the callback if we are being called synchronously
		    // to avoid piling up things on the stack
		    process.nextTick(cb, er);
		    // this can emit finish, and it will always happen
		    // after error
		    process.nextTick(finishMaybe, stream, state);
		    stream._writableState.errorEmitted = true;
		    errorOrDestroy(stream, er);
		  } else {
		    // the caller expect this to happen before if
		    // it is async
		    cb(er);
		    stream._writableState.errorEmitted = true;
		    errorOrDestroy(stream, er);
		    // this can emit finish, but finish must
		    // always follow error
		    finishMaybe(stream, state);
		  }
		}
		function onwriteStateUpdate(state) {
		  state.writing = false;
		  state.writecb = null;
		  state.length -= state.writelen;
		  state.writelen = 0;
		}
		function onwrite(stream, er) {
		  var state = stream._writableState;
		  var sync = state.sync;
		  var cb = state.writecb;
		  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
		  onwriteStateUpdate(state);
		  if (er) onwriteError(stream, state, sync, er, cb);else {
		    // Check if we're actually ready to finish, but don't emit yet
		    var finished = needFinish(state) || stream.destroyed;
		    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
		      clearBuffer(stream, state);
		    }
		    if (sync) {
		      process.nextTick(afterWrite, stream, state, finished, cb);
		    } else {
		      afterWrite(stream, state, finished, cb);
		    }
		  }
		}
		function afterWrite(stream, state, finished, cb) {
		  if (!finished) onwriteDrain(stream, state);
		  state.pendingcb--;
		  cb();
		  finishMaybe(stream, state);
		}

		// Must force callback to be called on nextTick, so that we don't
		// emit 'drain' before the write() consumer gets the 'false' return
		// value, and has a chance to attach a 'drain' listener.
		function onwriteDrain(stream, state) {
		  if (state.length === 0 && state.needDrain) {
		    state.needDrain = false;
		    stream.emit('drain');
		  }
		}

		// if there's something in the buffer waiting, then process it
		function clearBuffer(stream, state) {
		  state.bufferProcessing = true;
		  var entry = state.bufferedRequest;
		  if (stream._writev && entry && entry.next) {
		    // Fast case, write everything using _writev()
		    var l = state.bufferedRequestCount;
		    var buffer = new Array(l);
		    var holder = state.corkedRequestsFree;
		    holder.entry = entry;
		    var count = 0;
		    var allBuffers = true;
		    while (entry) {
		      buffer[count] = entry;
		      if (!entry.isBuf) allBuffers = false;
		      entry = entry.next;
		      count += 1;
		    }
		    buffer.allBuffers = allBuffers;
		    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

		    // doWrite is almost always async, defer these to save a bit of time
		    // as the hot path ends with doWrite
		    state.pendingcb++;
		    state.lastBufferedRequest = null;
		    if (holder.next) {
		      state.corkedRequestsFree = holder.next;
		      holder.next = null;
		    } else {
		      state.corkedRequestsFree = new CorkedRequest(state);
		    }
		    state.bufferedRequestCount = 0;
		  } else {
		    // Slow case, write chunks one-by-one
		    while (entry) {
		      var chunk = entry.chunk;
		      var encoding = entry.encoding;
		      var cb = entry.callback;
		      var len = state.objectMode ? 1 : chunk.length;
		      doWrite(stream, state, false, len, chunk, encoding, cb);
		      entry = entry.next;
		      state.bufferedRequestCount--;
		      // if we didn't call the onwrite immediately, then
		      // it means that we need to wait until it does.
		      // also, that means that the chunk and cb are currently
		      // being processed, so move the buffer counter past them.
		      if (state.writing) {
		        break;
		      }
		    }
		    if (entry === null) state.lastBufferedRequest = null;
		  }
		  state.bufferedRequest = entry;
		  state.bufferProcessing = false;
		}
		Writable.prototype._write = function (chunk, encoding, cb) {
		  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
		};
		Writable.prototype._writev = null;
		Writable.prototype.end = function (chunk, encoding, cb) {
		  var state = this._writableState;
		  if (typeof chunk === 'function') {
		    cb = chunk;
		    chunk = null;
		    encoding = null;
		  } else if (typeof encoding === 'function') {
		    cb = encoding;
		    encoding = null;
		  }
		  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

		  // .end() fully uncorks
		  if (state.corked) {
		    state.corked = 1;
		    this.uncork();
		  }

		  // ignore unnecessary end() calls.
		  if (!state.ending) endWritable(this, state, cb);
		  return this;
		};
		Object.defineProperty(Writable.prototype, 'writableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.length;
		  }
		});
		function needFinish(state) {
		  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
		}
		function callFinal(stream, state) {
		  stream._final(function (err) {
		    state.pendingcb--;
		    if (err) {
		      errorOrDestroy(stream, err);
		    }
		    state.prefinished = true;
		    stream.emit('prefinish');
		    finishMaybe(stream, state);
		  });
		}
		function prefinish(stream, state) {
		  if (!state.prefinished && !state.finalCalled) {
		    if (typeof stream._final === 'function' && !state.destroyed) {
		      state.pendingcb++;
		      state.finalCalled = true;
		      process.nextTick(callFinal, stream, state);
		    } else {
		      state.prefinished = true;
		      stream.emit('prefinish');
		    }
		  }
		}
		function finishMaybe(stream, state) {
		  var need = needFinish(state);
		  if (need) {
		    prefinish(stream, state);
		    if (state.pendingcb === 0) {
		      state.finished = true;
		      stream.emit('finish');
		      if (state.autoDestroy) {
		        // In case of duplex streams we need a way to detect
		        // if the readable side is ready for autoDestroy as well
		        var rState = stream._readableState;
		        if (!rState || rState.autoDestroy && rState.endEmitted) {
		          stream.destroy();
		        }
		      }
		    }
		  }
		  return need;
		}
		function endWritable(stream, state, cb) {
		  state.ending = true;
		  finishMaybe(stream, state);
		  if (cb) {
		    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
		  }
		  state.ended = true;
		  stream.writable = false;
		}
		function onCorkedFinish(corkReq, state, err) {
		  var entry = corkReq.entry;
		  corkReq.entry = null;
		  while (entry) {
		    var cb = entry.callback;
		    state.pendingcb--;
		    cb(err);
		    entry = entry.next;
		  }

		  // reuse the free corkReq.
		  state.corkedRequestsFree.next = corkReq;
		}
		Object.defineProperty(Writable.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._writableState === undefined) {
		      return false;
		    }
		    return this._writableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._writableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._writableState.destroyed = value;
		  }
		});
		Writable.prototype.destroy = destroyImpl.destroy;
		Writable.prototype._undestroy = destroyImpl.undestroy;
		Writable.prototype._destroy = function (err, cb) {
		  cb(err);
		};
		return _stream_writable;
	}

	var _stream_duplex;
	var hasRequired_stream_duplex;

	function require_stream_duplex () {
		if (hasRequired_stream_duplex) return _stream_duplex;
		hasRequired_stream_duplex = 1;

		/*<replacement>*/
		var objectKeys = Object.keys || function (obj) {
		  var keys = [];
		  for (var key in obj) keys.push(key);
		  return keys;
		};
		/*</replacement>*/

		_stream_duplex = Duplex;
		var Readable = require_stream_readable();
		var Writable = require_stream_writable();
		inherits_browserExports(Duplex, Readable);
		{
		  // Allow the keys array to be GC'ed.
		  var keys = objectKeys(Writable.prototype);
		  for (var v = 0; v < keys.length; v++) {
		    var method = keys[v];
		    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
		  }
		}
		function Duplex(options) {
		  if (!(this instanceof Duplex)) return new Duplex(options);
		  Readable.call(this, options);
		  Writable.call(this, options);
		  this.allowHalfOpen = true;
		  if (options) {
		    if (options.readable === false) this.readable = false;
		    if (options.writable === false) this.writable = false;
		    if (options.allowHalfOpen === false) {
		      this.allowHalfOpen = false;
		      this.once('end', onend);
		    }
		  }
		}
		Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.highWaterMark;
		  }
		});
		Object.defineProperty(Duplex.prototype, 'writableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState && this._writableState.getBuffer();
		  }
		});
		Object.defineProperty(Duplex.prototype, 'writableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._writableState.length;
		  }
		});

		// the no-half-open enforcer
		function onend() {
		  // If the writable side ended, then we're ok.
		  if (this._writableState.ended) return;

		  // no more data can be written.
		  // But allow more writes to happen in this tick.
		  process.nextTick(onEndNT, this);
		}
		function onEndNT(self) {
		  self.end();
		}
		Object.defineProperty(Duplex.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed && this._writableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (this._readableState === undefined || this._writableState === undefined) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		    this._writableState.destroyed = value;
		  }
		});
		return _stream_duplex;
	}

	var string_decoder = {};

	var hasRequiredString_decoder;

	function requireString_decoder () {
		if (hasRequiredString_decoder) return string_decoder;
		hasRequiredString_decoder = 1;

		/*<replacement>*/

		var Buffer = safeBufferExports.Buffer;
		/*</replacement>*/

		var isEncoding = Buffer.isEncoding || function (encoding) {
		  encoding = '' + encoding;
		  switch (encoding && encoding.toLowerCase()) {
		    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
		      return true;
		    default:
		      return false;
		  }
		};

		function _normalizeEncoding(enc) {
		  if (!enc) return 'utf8';
		  var retried;
		  while (true) {
		    switch (enc) {
		      case 'utf8':
		      case 'utf-8':
		        return 'utf8';
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return 'utf16le';
		      case 'latin1':
		      case 'binary':
		        return 'latin1';
		      case 'base64':
		      case 'ascii':
		      case 'hex':
		        return enc;
		      default:
		        if (retried) return; // undefined
		        enc = ('' + enc).toLowerCase();
		        retried = true;
		    }
		  }
		}
		// Do not cache `Buffer.isEncoding` when checking encoding names as some
		// modules monkey-patch it to support additional encodings
		function normalizeEncoding(enc) {
		  var nenc = _normalizeEncoding(enc);
		  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
		  return nenc || enc;
		}

		// StringDecoder provides an interface for efficiently splitting a series of
		// buffers into a series of JS strings without breaking apart multi-byte
		// characters.
		string_decoder.StringDecoder = StringDecoder;
		function StringDecoder(encoding) {
		  this.encoding = normalizeEncoding(encoding);
		  var nb;
		  switch (this.encoding) {
		    case 'utf16le':
		      this.text = utf16Text;
		      this.end = utf16End;
		      nb = 4;
		      break;
		    case 'utf8':
		      this.fillLast = utf8FillLast;
		      nb = 4;
		      break;
		    case 'base64':
		      this.text = base64Text;
		      this.end = base64End;
		      nb = 3;
		      break;
		    default:
		      this.write = simpleWrite;
		      this.end = simpleEnd;
		      return;
		  }
		  this.lastNeed = 0;
		  this.lastTotal = 0;
		  this.lastChar = Buffer.allocUnsafe(nb);
		}

		StringDecoder.prototype.write = function (buf) {
		  if (buf.length === 0) return '';
		  var r;
		  var i;
		  if (this.lastNeed) {
		    r = this.fillLast(buf);
		    if (r === undefined) return '';
		    i = this.lastNeed;
		    this.lastNeed = 0;
		  } else {
		    i = 0;
		  }
		  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
		  return r || '';
		};

		StringDecoder.prototype.end = utf8End;

		// Returns only complete characters in a Buffer
		StringDecoder.prototype.text = utf8Text;

		// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
		StringDecoder.prototype.fillLast = function (buf) {
		  if (this.lastNeed <= buf.length) {
		    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
		    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		  }
		  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		  this.lastNeed -= buf.length;
		};

		// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
		// continuation byte. If an invalid byte is detected, -2 is returned.
		function utf8CheckByte(byte) {
		  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
		  return byte >> 6 === 0x02 ? -1 : -2;
		}

		// Checks at most 3 bytes at the end of a Buffer in order to detect an
		// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
		// needed to complete the UTF-8 character (if applicable) are returned.
		function utf8CheckIncomplete(self, buf, i) {
		  var j = buf.length - 1;
		  if (j < i) return 0;
		  var nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) self.lastNeed = nb - 1;
		    return nb;
		  }
		  if (--j < i || nb === -2) return 0;
		  nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) self.lastNeed = nb - 2;
		    return nb;
		  }
		  if (--j < i || nb === -2) return 0;
		  nb = utf8CheckByte(buf[j]);
		  if (nb >= 0) {
		    if (nb > 0) {
		      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
		    }
		    return nb;
		  }
		  return 0;
		}

		// Validates as many continuation bytes for a multi-byte UTF-8 character as
		// needed or are available. If we see a non-continuation byte where we expect
		// one, we "replace" the validated continuation bytes we've seen so far with
		// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
		// behavior. The continuation byte check is included three times in the case
		// where all of the continuation bytes for a character exist in the same buffer.
		// It is also done this way as a slight performance increase instead of using a
		// loop.
		function utf8CheckExtraBytes(self, buf, p) {
		  if ((buf[0] & 0xC0) !== 0x80) {
		    self.lastNeed = 0;
		    return '\ufffd';
		  }
		  if (self.lastNeed > 1 && buf.length > 1) {
		    if ((buf[1] & 0xC0) !== 0x80) {
		      self.lastNeed = 1;
		      return '\ufffd';
		    }
		    if (self.lastNeed > 2 && buf.length > 2) {
		      if ((buf[2] & 0xC0) !== 0x80) {
		        self.lastNeed = 2;
		        return '\ufffd';
		      }
		    }
		  }
		}

		// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
		function utf8FillLast(buf) {
		  var p = this.lastTotal - this.lastNeed;
		  var r = utf8CheckExtraBytes(this, buf);
		  if (r !== undefined) return r;
		  if (this.lastNeed <= buf.length) {
		    buf.copy(this.lastChar, p, 0, this.lastNeed);
		    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		  }
		  buf.copy(this.lastChar, p, 0, buf.length);
		  this.lastNeed -= buf.length;
		}

		// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
		// partial character, the character's bytes are buffered until the required
		// number of bytes are available.
		function utf8Text(buf, i) {
		  var total = utf8CheckIncomplete(this, buf, i);
		  if (!this.lastNeed) return buf.toString('utf8', i);
		  this.lastTotal = total;
		  var end = buf.length - (total - this.lastNeed);
		  buf.copy(this.lastChar, 0, end);
		  return buf.toString('utf8', i, end);
		}

		// For UTF-8, a replacement character is added when ending on a partial
		// character.
		function utf8End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) return r + '\ufffd';
		  return r;
		}

		// UTF-16LE typically needs two bytes per character, but even if we have an even
		// number of bytes available, we need to check if we end on a leading/high
		// surrogate. In that case, we need to wait for the next two bytes in order to
		// decode the last character properly.
		function utf16Text(buf, i) {
		  if ((buf.length - i) % 2 === 0) {
		    var r = buf.toString('utf16le', i);
		    if (r) {
		      var c = r.charCodeAt(r.length - 1);
		      if (c >= 0xD800 && c <= 0xDBFF) {
		        this.lastNeed = 2;
		        this.lastTotal = 4;
		        this.lastChar[0] = buf[buf.length - 2];
		        this.lastChar[1] = buf[buf.length - 1];
		        return r.slice(0, -1);
		      }
		    }
		    return r;
		  }
		  this.lastNeed = 1;
		  this.lastTotal = 2;
		  this.lastChar[0] = buf[buf.length - 1];
		  return buf.toString('utf16le', i, buf.length - 1);
		}

		// For UTF-16LE we do not explicitly append special replacement characters if we
		// end on a partial character, we simply let v8 handle that.
		function utf16End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) {
		    var end = this.lastTotal - this.lastNeed;
		    return r + this.lastChar.toString('utf16le', 0, end);
		  }
		  return r;
		}

		function base64Text(buf, i) {
		  var n = (buf.length - i) % 3;
		  if (n === 0) return buf.toString('base64', i);
		  this.lastNeed = 3 - n;
		  this.lastTotal = 3;
		  if (n === 1) {
		    this.lastChar[0] = buf[buf.length - 1];
		  } else {
		    this.lastChar[0] = buf[buf.length - 2];
		    this.lastChar[1] = buf[buf.length - 1];
		  }
		  return buf.toString('base64', i, buf.length - n);
		}

		function base64End(buf) {
		  var r = buf && buf.length ? this.write(buf) : '';
		  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
		  return r;
		}

		// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
		function simpleWrite(buf) {
		  return buf.toString(this.encoding);
		}

		function simpleEnd(buf) {
		  return buf && buf.length ? this.write(buf) : '';
		}
		return string_decoder;
	}

	var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
	function once$1(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop$1() {}
	function isRequest$1(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos$1(stream, opts, callback) {
	  if (typeof opts === 'function') return eos$1(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once$1(callback || noop$1);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest$1(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	var endOfStream = eos$1;

	var async_iterator;
	var hasRequiredAsync_iterator;

	function requireAsync_iterator () {
		if (hasRequiredAsync_iterator) return async_iterator;
		hasRequiredAsync_iterator = 1;

		var _Object$setPrototypeO;
		function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		var finished = endOfStream;
		var kLastResolve = Symbol('lastResolve');
		var kLastReject = Symbol('lastReject');
		var kError = Symbol('error');
		var kEnded = Symbol('ended');
		var kLastPromise = Symbol('lastPromise');
		var kHandlePromise = Symbol('handlePromise');
		var kStream = Symbol('stream');
		function createIterResult(value, done) {
		  return {
		    value: value,
		    done: done
		  };
		}
		function readAndResolve(iter) {
		  var resolve = iter[kLastResolve];
		  if (resolve !== null) {
		    var data = iter[kStream].read();
		    // we defer if data is null
		    // we can be expecting either 'end' or
		    // 'error'
		    if (data !== null) {
		      iter[kLastPromise] = null;
		      iter[kLastResolve] = null;
		      iter[kLastReject] = null;
		      resolve(createIterResult(data, false));
		    }
		  }
		}
		function onReadable(iter) {
		  // we wait for the next tick, because it might
		  // emit an error with process.nextTick
		  process.nextTick(readAndResolve, iter);
		}
		function wrapForNext(lastPromise, iter) {
		  return function (resolve, reject) {
		    lastPromise.then(function () {
		      if (iter[kEnded]) {
		        resolve(createIterResult(undefined, true));
		        return;
		      }
		      iter[kHandlePromise](resolve, reject);
		    }, reject);
		  };
		}
		var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
		var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
		  get stream() {
		    return this[kStream];
		  },
		  next: function next() {
		    var _this = this;
		    // if we have detected an error in the meanwhile
		    // reject straight away
		    var error = this[kError];
		    if (error !== null) {
		      return Promise.reject(error);
		    }
		    if (this[kEnded]) {
		      return Promise.resolve(createIterResult(undefined, true));
		    }
		    if (this[kStream].destroyed) {
		      // We need to defer via nextTick because if .destroy(err) is
		      // called, the error will be emitted via nextTick, and
		      // we cannot guarantee that there is no error lingering around
		      // waiting to be emitted.
		      return new Promise(function (resolve, reject) {
		        process.nextTick(function () {
		          if (_this[kError]) {
		            reject(_this[kError]);
		          } else {
		            resolve(createIterResult(undefined, true));
		          }
		        });
		      });
		    }

		    // if we have multiple next() calls
		    // we will wait for the previous Promise to finish
		    // this logic is optimized to support for await loops,
		    // where next() is only called once at a time
		    var lastPromise = this[kLastPromise];
		    var promise;
		    if (lastPromise) {
		      promise = new Promise(wrapForNext(lastPromise, this));
		    } else {
		      // fast path needed to support multiple this.push()
		      // without triggering the next() queue
		      var data = this[kStream].read();
		      if (data !== null) {
		        return Promise.resolve(createIterResult(data, false));
		      }
		      promise = new Promise(this[kHandlePromise]);
		    }
		    this[kLastPromise] = promise;
		    return promise;
		  }
		}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
		  return this;
		}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
		  var _this2 = this;
		  // destroy(err, cb) is a private API
		  // we can guarantee we have that here, because we control the
		  // Readable class this is attached to
		  return new Promise(function (resolve, reject) {
		    _this2[kStream].destroy(null, function (err) {
		      if (err) {
		        reject(err);
		        return;
		      }
		      resolve(createIterResult(undefined, true));
		    });
		  });
		}), _Object$setPrototypeO), AsyncIteratorPrototype);
		var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
		  var _Object$create;
		  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
		    value: stream,
		    writable: true
		  }), _defineProperty(_Object$create, kLastResolve, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kLastReject, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kError, {
		    value: null,
		    writable: true
		  }), _defineProperty(_Object$create, kEnded, {
		    value: stream._readableState.endEmitted,
		    writable: true
		  }), _defineProperty(_Object$create, kHandlePromise, {
		    value: function value(resolve, reject) {
		      var data = iterator[kStream].read();
		      if (data) {
		        iterator[kLastPromise] = null;
		        iterator[kLastResolve] = null;
		        iterator[kLastReject] = null;
		        resolve(createIterResult(data, false));
		      } else {
		        iterator[kLastResolve] = resolve;
		        iterator[kLastReject] = reject;
		      }
		    },
		    writable: true
		  }), _Object$create));
		  iterator[kLastPromise] = null;
		  finished(stream, function (err) {
		    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
		      var reject = iterator[kLastReject];
		      // reject if we are waiting for data in the Promise
		      // returned by next() and store the error
		      if (reject !== null) {
		        iterator[kLastPromise] = null;
		        iterator[kLastResolve] = null;
		        iterator[kLastReject] = null;
		        reject(err);
		      }
		      iterator[kError] = err;
		      return;
		    }
		    var resolve = iterator[kLastResolve];
		    if (resolve !== null) {
		      iterator[kLastPromise] = null;
		      iterator[kLastResolve] = null;
		      iterator[kLastReject] = null;
		      resolve(createIterResult(undefined, true));
		    }
		    iterator[kEnded] = true;
		  });
		  stream.on('readable', onReadable.bind(null, iterator));
		  return iterator;
		};
		async_iterator = createReadableStreamAsyncIterator;
		return async_iterator;
	}

	var fromBrowser;
	var hasRequiredFromBrowser;

	function requireFromBrowser () {
		if (hasRequiredFromBrowser) return fromBrowser;
		hasRequiredFromBrowser = 1;
		fromBrowser = function () {
		  throw new Error('Readable.from is not available in the browser')
		};
		return fromBrowser;
	}

	var _stream_readable;
	var hasRequired_stream_readable;

	function require_stream_readable () {
		if (hasRequired_stream_readable) return _stream_readable;
		hasRequired_stream_readable = 1;

		_stream_readable = Readable;

		/*<replacement>*/
		var Duplex;
		/*</replacement>*/

		Readable.ReadableState = ReadableState;

		/*<replacement>*/
		require$$0$4.EventEmitter;
		var EElistenerCount = function EElistenerCount(emitter, type) {
		  return emitter.listeners(type).length;
		};
		/*</replacement>*/

		/*<replacement>*/
		var Stream = streamBrowser;
		/*</replacement>*/

		var Buffer = require$$0$3.Buffer;
		var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
		function _uint8ArrayToBuffer(chunk) {
		  return Buffer.from(chunk);
		}
		function _isUint8Array(obj) {
		  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
		}

		/*<replacement>*/
		var debugUtil = require$$0$2;
		var debug;
		if (debugUtil && debugUtil.debuglog) {
		  debug = debugUtil.debuglog('stream');
		} else {
		  debug = function debug() {};
		}
		/*</replacement>*/

		var BufferList = requireBuffer_list();
		var destroyImpl = destroy_1;
		var _require = state,
		  getHighWaterMark = _require.getHighWaterMark;
		var _require$codes = errorsBrowser.codes,
		  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
		  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
		  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
		  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

		// Lazy loaded to improve the startup performance.
		var StringDecoder;
		var createReadableStreamAsyncIterator;
		var from;
		inherits_browserExports(Readable, Stream);
		var errorOrDestroy = destroyImpl.errorOrDestroy;
		var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
		function prependListener(emitter, event, fn) {
		  // Sadly this is not cacheable as some libraries bundle their own
		  // event emitter implementation with them.
		  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

		  // This is a hack to make sure that our error handler is attached before any
		  // userland ones.  NEVER DO THIS. This is here only because this code needs
		  // to continue to work with older versions of Node.js that do not include
		  // the prependListener() method. The goal is to eventually remove this hack.
		  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
		}
		function ReadableState(options, stream, isDuplex) {
		  Duplex = Duplex || require_stream_duplex();
		  options = options || {};

		  // Duplex streams are both readable and writable, but share
		  // the same options object.
		  // However, some cases require setting options to different
		  // values for the readable and the writable sides of the duplex stream.
		  // These options can be provided separately as readableXXX and writableXXX.
		  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

		  // object stream flag. Used to make read(n) ignore n and to
		  // make all the buffer merging and length checks go away
		  this.objectMode = !!options.objectMode;
		  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

		  // the point at which it stops calling _read() to fill the buffer
		  // Note: 0 is a valid value, means "don't call _read preemptively ever"
		  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

		  // A linked list is used to store data chunks instead of an array because the
		  // linked list can remove elements from the beginning faster than
		  // array.shift()
		  this.buffer = new BufferList();
		  this.length = 0;
		  this.pipes = null;
		  this.pipesCount = 0;
		  this.flowing = null;
		  this.ended = false;
		  this.endEmitted = false;
		  this.reading = false;

		  // a flag to be able to tell if the event 'readable'/'data' is emitted
		  // immediately, or on a later tick.  We set this to true at first, because
		  // any actions that shouldn't happen until "later" should generally also
		  // not happen before the first read call.
		  this.sync = true;

		  // whenever we return null, then we set a flag to say
		  // that we're awaiting a 'readable' event emission.
		  this.needReadable = false;
		  this.emittedReadable = false;
		  this.readableListening = false;
		  this.resumeScheduled = false;
		  this.paused = true;

		  // Should close be emitted on destroy. Defaults to true.
		  this.emitClose = options.emitClose !== false;

		  // Should .destroy() be called after 'end' (and potentially 'finish')
		  this.autoDestroy = !!options.autoDestroy;

		  // has it been destroyed
		  this.destroyed = false;

		  // Crypto is kind of old and crusty.  Historically, its default string
		  // encoding is 'binary' so we have to make this configurable.
		  // Everything else in the universe uses 'utf8', though.
		  this.defaultEncoding = options.defaultEncoding || 'utf8';

		  // the number of writers that are awaiting a drain event in .pipe()s
		  this.awaitDrain = 0;

		  // if true, a maybeReadMore has been scheduled
		  this.readingMore = false;
		  this.decoder = null;
		  this.encoding = null;
		  if (options.encoding) {
		    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
		    this.decoder = new StringDecoder(options.encoding);
		    this.encoding = options.encoding;
		  }
		}
		function Readable(options) {
		  Duplex = Duplex || require_stream_duplex();
		  if (!(this instanceof Readable)) return new Readable(options);

		  // Checking for a Stream.Duplex instance is faster here instead of inside
		  // the ReadableState constructor, at least with V8 6.5
		  var isDuplex = this instanceof Duplex;
		  this._readableState = new ReadableState(options, this, isDuplex);

		  // legacy
		  this.readable = true;
		  if (options) {
		    if (typeof options.read === 'function') this._read = options.read;
		    if (typeof options.destroy === 'function') this._destroy = options.destroy;
		  }
		  Stream.call(this);
		}
		Object.defineProperty(Readable.prototype, 'destroyed', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    if (this._readableState === undefined) {
		      return false;
		    }
		    return this._readableState.destroyed;
		  },
		  set: function set(value) {
		    // we ignore the value if the stream
		    // has not been initialized yet
		    if (!this._readableState) {
		      return;
		    }

		    // backward compatibility, the user is explicitly
		    // managing destroyed
		    this._readableState.destroyed = value;
		  }
		});
		Readable.prototype.destroy = destroyImpl.destroy;
		Readable.prototype._undestroy = destroyImpl.undestroy;
		Readable.prototype._destroy = function (err, cb) {
		  cb(err);
		};

		// Manually shove something into the read() buffer.
		// This returns true if the highWaterMark has not been hit yet,
		// similar to how Writable.write() returns true if you should
		// write() some more.
		Readable.prototype.push = function (chunk, encoding) {
		  var state = this._readableState;
		  var skipChunkCheck;
		  if (!state.objectMode) {
		    if (typeof chunk === 'string') {
		      encoding = encoding || state.defaultEncoding;
		      if (encoding !== state.encoding) {
		        chunk = Buffer.from(chunk, encoding);
		        encoding = '';
		      }
		      skipChunkCheck = true;
		    }
		  } else {
		    skipChunkCheck = true;
		  }
		  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
		};

		// Unshift should *always* be something directly out of read()
		Readable.prototype.unshift = function (chunk) {
		  return readableAddChunk(this, chunk, null, true, false);
		};
		function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
		  debug('readableAddChunk', chunk);
		  var state = stream._readableState;
		  if (chunk === null) {
		    state.reading = false;
		    onEofChunk(stream, state);
		  } else {
		    var er;
		    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
		    if (er) {
		      errorOrDestroy(stream, er);
		    } else if (state.objectMode || chunk && chunk.length > 0) {
		      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
		        chunk = _uint8ArrayToBuffer(chunk);
		      }
		      if (addToFront) {
		        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
		      } else if (state.ended) {
		        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
		      } else if (state.destroyed) {
		        return false;
		      } else {
		        state.reading = false;
		        if (state.decoder && !encoding) {
		          chunk = state.decoder.write(chunk);
		          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
		        } else {
		          addChunk(stream, state, chunk, false);
		        }
		      }
		    } else if (!addToFront) {
		      state.reading = false;
		      maybeReadMore(stream, state);
		    }
		  }

		  // We can push more data if we are below the highWaterMark.
		  // Also, if we have no data yet, we can stand some more bytes.
		  // This is to work around cases where hwm=0, such as the repl.
		  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
		}
		function addChunk(stream, state, chunk, addToFront) {
		  if (state.flowing && state.length === 0 && !state.sync) {
		    state.awaitDrain = 0;
		    stream.emit('data', chunk);
		  } else {
		    // update the buffer info.
		    state.length += state.objectMode ? 1 : chunk.length;
		    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
		    if (state.needReadable) emitReadable(stream);
		  }
		  maybeReadMore(stream, state);
		}
		function chunkInvalid(state, chunk) {
		  var er;
		  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
		    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
		  }
		  return er;
		}
		Readable.prototype.isPaused = function () {
		  return this._readableState.flowing === false;
		};

		// backwards compatibility.
		Readable.prototype.setEncoding = function (enc) {
		  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
		  var decoder = new StringDecoder(enc);
		  this._readableState.decoder = decoder;
		  // If setEncoding(null), decoder.encoding equals utf8
		  this._readableState.encoding = this._readableState.decoder.encoding;

		  // Iterate over current buffer to convert already stored Buffers:
		  var p = this._readableState.buffer.head;
		  var content = '';
		  while (p !== null) {
		    content += decoder.write(p.data);
		    p = p.next;
		  }
		  this._readableState.buffer.clear();
		  if (content !== '') this._readableState.buffer.push(content);
		  this._readableState.length = content.length;
		  return this;
		};

		// Don't raise the hwm > 1GB
		var MAX_HWM = 0x40000000;
		function computeNewHighWaterMark(n) {
		  if (n >= MAX_HWM) {
		    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
		    n = MAX_HWM;
		  } else {
		    // Get the next highest power of 2 to prevent increasing hwm excessively in
		    // tiny amounts
		    n--;
		    n |= n >>> 1;
		    n |= n >>> 2;
		    n |= n >>> 4;
		    n |= n >>> 8;
		    n |= n >>> 16;
		    n++;
		  }
		  return n;
		}

		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function howMuchToRead(n, state) {
		  if (n <= 0 || state.length === 0 && state.ended) return 0;
		  if (state.objectMode) return 1;
		  if (n !== n) {
		    // Only flow one buffer at a time
		    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
		  }
		  // If we're asking for more than the current hwm, then raise the hwm.
		  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
		  if (n <= state.length) return n;
		  // Don't have enough
		  if (!state.ended) {
		    state.needReadable = true;
		    return 0;
		  }
		  return state.length;
		}

		// you can override either this method, or the async _read(n) below.
		Readable.prototype.read = function (n) {
		  debug('read', n);
		  n = parseInt(n, 10);
		  var state = this._readableState;
		  var nOrig = n;
		  if (n !== 0) state.emittedReadable = false;

		  // if we're doing read(0) to trigger a readable event, but we
		  // already have a bunch of data in the buffer, then just trigger
		  // the 'readable' event and move on.
		  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
		    debug('read: emitReadable', state.length, state.ended);
		    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
		    return null;
		  }
		  n = howMuchToRead(n, state);

		  // if we've ended, and we're now clear, then finish it up.
		  if (n === 0 && state.ended) {
		    if (state.length === 0) endReadable(this);
		    return null;
		  }

		  // All the actual chunk generation logic needs to be
		  // *below* the call to _read.  The reason is that in certain
		  // synthetic stream cases, such as passthrough streams, _read
		  // may be a completely synchronous operation which may change
		  // the state of the read buffer, providing enough data when
		  // before there was *not* enough.
		  //
		  // So, the steps are:
		  // 1. Figure out what the state of things will be after we do
		  // a read from the buffer.
		  //
		  // 2. If that resulting state will trigger a _read, then call _read.
		  // Note that this may be asynchronous, or synchronous.  Yes, it is
		  // deeply ugly to write APIs this way, but that still doesn't mean
		  // that the Readable class should behave improperly, as streams are
		  // designed to be sync/async agnostic.
		  // Take note if the _read call is sync or async (ie, if the read call
		  // has returned yet), so that we know whether or not it's safe to emit
		  // 'readable' etc.
		  //
		  // 3. Actually pull the requested chunks out of the buffer and return.

		  // if we need a readable event, then we need to do some reading.
		  var doRead = state.needReadable;
		  debug('need readable', doRead);

		  // if we currently have less than the highWaterMark, then also read some
		  if (state.length === 0 || state.length - n < state.highWaterMark) {
		    doRead = true;
		    debug('length less than watermark', doRead);
		  }

		  // however, if we've ended, then there's no point, and if we're already
		  // reading, then it's unnecessary.
		  if (state.ended || state.reading) {
		    doRead = false;
		    debug('reading or ended', doRead);
		  } else if (doRead) {
		    debug('do read');
		    state.reading = true;
		    state.sync = true;
		    // if the length is currently zero, then we *need* a readable event.
		    if (state.length === 0) state.needReadable = true;
		    // call internal read method
		    this._read(state.highWaterMark);
		    state.sync = false;
		    // If _read pushed data synchronously, then `reading` will be false,
		    // and we need to re-evaluate how much data we can return to the user.
		    if (!state.reading) n = howMuchToRead(nOrig, state);
		  }
		  var ret;
		  if (n > 0) ret = fromList(n, state);else ret = null;
		  if (ret === null) {
		    state.needReadable = state.length <= state.highWaterMark;
		    n = 0;
		  } else {
		    state.length -= n;
		    state.awaitDrain = 0;
		  }
		  if (state.length === 0) {
		    // If we have nothing in the buffer, then we want to know
		    // as soon as we *do* get something into the buffer.
		    if (!state.ended) state.needReadable = true;

		    // If we tried to read() past the EOF, then emit end on the next tick.
		    if (nOrig !== n && state.ended) endReadable(this);
		  }
		  if (ret !== null) this.emit('data', ret);
		  return ret;
		};
		function onEofChunk(stream, state) {
		  debug('onEofChunk');
		  if (state.ended) return;
		  if (state.decoder) {
		    var chunk = state.decoder.end();
		    if (chunk && chunk.length) {
		      state.buffer.push(chunk);
		      state.length += state.objectMode ? 1 : chunk.length;
		    }
		  }
		  state.ended = true;
		  if (state.sync) {
		    // if we are sync, wait until next tick to emit the data.
		    // Otherwise we risk emitting data in the flow()
		    // the readable code triggers during a read() call
		    emitReadable(stream);
		  } else {
		    // emit 'readable' now to make sure it gets picked up.
		    state.needReadable = false;
		    if (!state.emittedReadable) {
		      state.emittedReadable = true;
		      emitReadable_(stream);
		    }
		  }
		}

		// Don't emit readable right away in sync mode, because this can trigger
		// another read() call => stack overflow.  This way, it might trigger
		// a nextTick recursion warning, but that's not so bad.
		function emitReadable(stream) {
		  var state = stream._readableState;
		  debug('emitReadable', state.needReadable, state.emittedReadable);
		  state.needReadable = false;
		  if (!state.emittedReadable) {
		    debug('emitReadable', state.flowing);
		    state.emittedReadable = true;
		    process.nextTick(emitReadable_, stream);
		  }
		}
		function emitReadable_(stream) {
		  var state = stream._readableState;
		  debug('emitReadable_', state.destroyed, state.length, state.ended);
		  if (!state.destroyed && (state.length || state.ended)) {
		    stream.emit('readable');
		    state.emittedReadable = false;
		  }

		  // The stream needs another readable event if
		  // 1. It is not flowing, as the flow mechanism will take
		  //    care of it.
		  // 2. It is not ended.
		  // 3. It is below the highWaterMark, so we can schedule
		  //    another readable later.
		  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
		  flow(stream);
		}

		// at this point, the user has presumably seen the 'readable' event,
		// and called read() to consume some data.  that may have triggered
		// in turn another _read(n) call, in which case reading = true if
		// it's in progress.
		// However, if we're not ended, or reading, and the length < hwm,
		// then go ahead and try to read some more preemptively.
		function maybeReadMore(stream, state) {
		  if (!state.readingMore) {
		    state.readingMore = true;
		    process.nextTick(maybeReadMore_, stream, state);
		  }
		}
		function maybeReadMore_(stream, state) {
		  // Attempt to read more data if we should.
		  //
		  // The conditions for reading more data are (one of):
		  // - Not enough data buffered (state.length < state.highWaterMark). The loop
		  //   is responsible for filling the buffer with enough data if such data
		  //   is available. If highWaterMark is 0 and we are not in the flowing mode
		  //   we should _not_ attempt to buffer any extra data. We'll get more data
		  //   when the stream consumer calls read() instead.
		  // - No data in the buffer, and the stream is in flowing mode. In this mode
		  //   the loop below is responsible for ensuring read() is called. Failing to
		  //   call read here would abort the flow and there's no other mechanism for
		  //   continuing the flow if the stream consumer has just subscribed to the
		  //   'data' event.
		  //
		  // In addition to the above conditions to keep reading data, the following
		  // conditions prevent the data from being read:
		  // - The stream has ended (state.ended).
		  // - There is already a pending 'read' operation (state.reading). This is a
		  //   case where the the stream has called the implementation defined _read()
		  //   method, but they are processing the call asynchronously and have _not_
		  //   called push() with new data. In this case we skip performing more
		  //   read()s. The execution ends in this method again after the _read() ends
		  //   up calling push() with more data.
		  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
		    var len = state.length;
		    debug('maybeReadMore read 0');
		    stream.read(0);
		    if (len === state.length)
		      // didn't get any data, stop spinning.
		      break;
		  }
		  state.readingMore = false;
		}

		// abstract method.  to be overridden in specific implementation classes.
		// call cb(er, data) where data is <= n in length.
		// for virtual (non-string, non-buffer) streams, "length" is somewhat
		// arbitrary, and perhaps not very meaningful.
		Readable.prototype._read = function (n) {
		  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
		};
		Readable.prototype.pipe = function (dest, pipeOpts) {
		  var src = this;
		  var state = this._readableState;
		  switch (state.pipesCount) {
		    case 0:
		      state.pipes = dest;
		      break;
		    case 1:
		      state.pipes = [state.pipes, dest];
		      break;
		    default:
		      state.pipes.push(dest);
		      break;
		  }
		  state.pipesCount += 1;
		  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
		  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
		  var endFn = doEnd ? onend : unpipe;
		  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
		  dest.on('unpipe', onunpipe);
		  function onunpipe(readable, unpipeInfo) {
		    debug('onunpipe');
		    if (readable === src) {
		      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
		        unpipeInfo.hasUnpiped = true;
		        cleanup();
		      }
		    }
		  }
		  function onend() {
		    debug('onend');
		    dest.end();
		  }

		  // when the dest drains, it reduces the awaitDrain counter
		  // on the source.  This would be more elegant with a .once()
		  // handler in flow(), but adding and removing repeatedly is
		  // too slow.
		  var ondrain = pipeOnDrain(src);
		  dest.on('drain', ondrain);
		  var cleanedUp = false;
		  function cleanup() {
		    debug('cleanup');
		    // cleanup event handlers once the pipe is broken
		    dest.removeListener('close', onclose);
		    dest.removeListener('finish', onfinish);
		    dest.removeListener('drain', ondrain);
		    dest.removeListener('error', onerror);
		    dest.removeListener('unpipe', onunpipe);
		    src.removeListener('end', onend);
		    src.removeListener('end', unpipe);
		    src.removeListener('data', ondata);
		    cleanedUp = true;

		    // if the reader is waiting for a drain event from this
		    // specific writer, then it would cause it to never start
		    // flowing again.
		    // So, if this is awaiting a drain, then we just call it now.
		    // If we don't know, then assume that we are waiting for one.
		    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		  }
		  src.on('data', ondata);
		  function ondata(chunk) {
		    debug('ondata');
		    var ret = dest.write(chunk);
		    debug('dest.write', ret);
		    if (ret === false) {
		      // If the user unpiped during `dest.write()`, it is possible
		      // to get stuck in a permanently paused state if that write
		      // also returned false.
		      // => Check whether `dest` is still a piping destination.
		      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
		        debug('false write response, pause', state.awaitDrain);
		        state.awaitDrain++;
		      }
		      src.pause();
		    }
		  }

		  // if the dest has an error, then stop piping into it.
		  // however, don't suppress the throwing behavior for this.
		  function onerror(er) {
		    debug('onerror', er);
		    unpipe();
		    dest.removeListener('error', onerror);
		    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
		  }

		  // Make sure our error handler is attached before userland ones.
		  prependListener(dest, 'error', onerror);

		  // Both close and finish should trigger unpipe, but only once.
		  function onclose() {
		    dest.removeListener('finish', onfinish);
		    unpipe();
		  }
		  dest.once('close', onclose);
		  function onfinish() {
		    debug('onfinish');
		    dest.removeListener('close', onclose);
		    unpipe();
		  }
		  dest.once('finish', onfinish);
		  function unpipe() {
		    debug('unpipe');
		    src.unpipe(dest);
		  }

		  // tell the dest that it's being piped to
		  dest.emit('pipe', src);

		  // start the flow if it hasn't been started already.
		  if (!state.flowing) {
		    debug('pipe resume');
		    src.resume();
		  }
		  return dest;
		};
		function pipeOnDrain(src) {
		  return function pipeOnDrainFunctionResult() {
		    var state = src._readableState;
		    debug('pipeOnDrain', state.awaitDrain);
		    if (state.awaitDrain) state.awaitDrain--;
		    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
		      state.flowing = true;
		      flow(src);
		    }
		  };
		}
		Readable.prototype.unpipe = function (dest) {
		  var state = this._readableState;
		  var unpipeInfo = {
		    hasUnpiped: false
		  };

		  // if we're not piping anywhere, then do nothing.
		  if (state.pipesCount === 0) return this;

		  // just one destination.  most common case.
		  if (state.pipesCount === 1) {
		    // passed in one, but it's not the right one.
		    if (dest && dest !== state.pipes) return this;
		    if (!dest) dest = state.pipes;

		    // got a match.
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;
		    if (dest) dest.emit('unpipe', this, unpipeInfo);
		    return this;
		  }

		  // slow case. multiple pipe destinations.

		  if (!dest) {
		    // remove all.
		    var dests = state.pipes;
		    var len = state.pipesCount;
		    state.pipes = null;
		    state.pipesCount = 0;
		    state.flowing = false;
		    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
		      hasUnpiped: false
		    });
		    return this;
		  }

		  // try to find the right one.
		  var index = indexOf(state.pipes, dest);
		  if (index === -1) return this;
		  state.pipes.splice(index, 1);
		  state.pipesCount -= 1;
		  if (state.pipesCount === 1) state.pipes = state.pipes[0];
		  dest.emit('unpipe', this, unpipeInfo);
		  return this;
		};

		// set up data events if they are asked for
		// Ensure readable listeners eventually get something
		Readable.prototype.on = function (ev, fn) {
		  var res = Stream.prototype.on.call(this, ev, fn);
		  var state = this._readableState;
		  if (ev === 'data') {
		    // update readableListening so that resume() may be a no-op
		    // a few lines down. This is needed to support once('readable').
		    state.readableListening = this.listenerCount('readable') > 0;

		    // Try start flowing on next tick if stream isn't explicitly paused
		    if (state.flowing !== false) this.resume();
		  } else if (ev === 'readable') {
		    if (!state.endEmitted && !state.readableListening) {
		      state.readableListening = state.needReadable = true;
		      state.flowing = false;
		      state.emittedReadable = false;
		      debug('on readable', state.length, state.reading);
		      if (state.length) {
		        emitReadable(this);
		      } else if (!state.reading) {
		        process.nextTick(nReadingNextTick, this);
		      }
		    }
		  }
		  return res;
		};
		Readable.prototype.addListener = Readable.prototype.on;
		Readable.prototype.removeListener = function (ev, fn) {
		  var res = Stream.prototype.removeListener.call(this, ev, fn);
		  if (ev === 'readable') {
		    // We need to check if there is someone still listening to
		    // readable and reset the state. However this needs to happen
		    // after readable has been emitted but before I/O (nextTick) to
		    // support once('readable', fn) cycles. This means that calling
		    // resume within the same tick will have no
		    // effect.
		    process.nextTick(updateReadableListening, this);
		  }
		  return res;
		};
		Readable.prototype.removeAllListeners = function (ev) {
		  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
		  if (ev === 'readable' || ev === undefined) {
		    // We need to check if there is someone still listening to
		    // readable and reset the state. However this needs to happen
		    // after readable has been emitted but before I/O (nextTick) to
		    // support once('readable', fn) cycles. This means that calling
		    // resume within the same tick will have no
		    // effect.
		    process.nextTick(updateReadableListening, this);
		  }
		  return res;
		};
		function updateReadableListening(self) {
		  var state = self._readableState;
		  state.readableListening = self.listenerCount('readable') > 0;
		  if (state.resumeScheduled && !state.paused) {
		    // flowing needs to be set to true now, otherwise
		    // the upcoming resume will not flow.
		    state.flowing = true;

		    // crude way to check if we should resume
		  } else if (self.listenerCount('data') > 0) {
		    self.resume();
		  }
		}
		function nReadingNextTick(self) {
		  debug('readable nexttick read 0');
		  self.read(0);
		}

		// pause() and resume() are remnants of the legacy readable stream API
		// If the user uses them, then switch into old mode.
		Readable.prototype.resume = function () {
		  var state = this._readableState;
		  if (!state.flowing) {
		    debug('resume');
		    // we flow only if there is no one listening
		    // for readable, but we still have to call
		    // resume()
		    state.flowing = !state.readableListening;
		    resume(this, state);
		  }
		  state.paused = false;
		  return this;
		};
		function resume(stream, state) {
		  if (!state.resumeScheduled) {
		    state.resumeScheduled = true;
		    process.nextTick(resume_, stream, state);
		  }
		}
		function resume_(stream, state) {
		  debug('resume', state.reading);
		  if (!state.reading) {
		    stream.read(0);
		  }
		  state.resumeScheduled = false;
		  stream.emit('resume');
		  flow(stream);
		  if (state.flowing && !state.reading) stream.read(0);
		}
		Readable.prototype.pause = function () {
		  debug('call pause flowing=%j', this._readableState.flowing);
		  if (this._readableState.flowing !== false) {
		    debug('pause');
		    this._readableState.flowing = false;
		    this.emit('pause');
		  }
		  this._readableState.paused = true;
		  return this;
		};
		function flow(stream) {
		  var state = stream._readableState;
		  debug('flow', state.flowing);
		  while (state.flowing && stream.read() !== null);
		}

		// wrap an old-style stream as the async data source.
		// This is *not* part of the readable stream interface.
		// It is an ugly unfortunate mess of history.
		Readable.prototype.wrap = function (stream) {
		  var _this = this;
		  var state = this._readableState;
		  var paused = false;
		  stream.on('end', function () {
		    debug('wrapped end');
		    if (state.decoder && !state.ended) {
		      var chunk = state.decoder.end();
		      if (chunk && chunk.length) _this.push(chunk);
		    }
		    _this.push(null);
		  });
		  stream.on('data', function (chunk) {
		    debug('wrapped data');
		    if (state.decoder) chunk = state.decoder.write(chunk);

		    // don't skip over falsy values in objectMode
		    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
		    var ret = _this.push(chunk);
		    if (!ret) {
		      paused = true;
		      stream.pause();
		    }
		  });

		  // proxy all the other methods.
		  // important when wrapping filters and duplexes.
		  for (var i in stream) {
		    if (this[i] === undefined && typeof stream[i] === 'function') {
		      this[i] = function methodWrap(method) {
		        return function methodWrapReturnFunction() {
		          return stream[method].apply(stream, arguments);
		        };
		      }(i);
		    }
		  }

		  // proxy certain important events.
		  for (var n = 0; n < kProxyEvents.length; n++) {
		    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
		  }

		  // when we try to consume some more bytes, simply unpause the
		  // underlying stream.
		  this._read = function (n) {
		    debug('wrapped _read', n);
		    if (paused) {
		      paused = false;
		      stream.resume();
		    }
		  };
		  return this;
		};
		if (typeof Symbol === 'function') {
		  Readable.prototype[Symbol.asyncIterator] = function () {
		    if (createReadableStreamAsyncIterator === undefined) {
		      createReadableStreamAsyncIterator = requireAsync_iterator();
		    }
		    return createReadableStreamAsyncIterator(this);
		  };
		}
		Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.highWaterMark;
		  }
		});
		Object.defineProperty(Readable.prototype, 'readableBuffer', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState && this._readableState.buffer;
		  }
		});
		Object.defineProperty(Readable.prototype, 'readableFlowing', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.flowing;
		  },
		  set: function set(state) {
		    if (this._readableState) {
		      this._readableState.flowing = state;
		    }
		  }
		});

		// exposed for testing purposes only.
		Readable._fromList = fromList;
		Object.defineProperty(Readable.prototype, 'readableLength', {
		  // making it explicit this property is not enumerable
		  // because otherwise some prototype manipulation in
		  // userland will fail
		  enumerable: false,
		  get: function get() {
		    return this._readableState.length;
		  }
		});

		// Pluck off n bytes from an array of buffers.
		// Length is the combined lengths of all the buffers in the list.
		// This function is designed to be inlinable, so please take care when making
		// changes to the function body.
		function fromList(n, state) {
		  // nothing buffered
		  if (state.length === 0) return null;
		  var ret;
		  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
		    // read it all, truncate the list
		    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
		    state.buffer.clear();
		  } else {
		    // read part of list
		    ret = state.buffer.consume(n, state.decoder);
		  }
		  return ret;
		}
		function endReadable(stream) {
		  var state = stream._readableState;
		  debug('endReadable', state.endEmitted);
		  if (!state.endEmitted) {
		    state.ended = true;
		    process.nextTick(endReadableNT, state, stream);
		  }
		}
		function endReadableNT(state, stream) {
		  debug('endReadableNT', state.endEmitted, state.length);

		  // Check that we didn't get one last unshift.
		  if (!state.endEmitted && state.length === 0) {
		    state.endEmitted = true;
		    stream.readable = false;
		    stream.emit('end');
		    if (state.autoDestroy) {
		      // In case of duplex streams we need a way to detect
		      // if the writable side is ready for autoDestroy as well
		      var wState = stream._writableState;
		      if (!wState || wState.autoDestroy && wState.finished) {
		        stream.destroy();
		      }
		    }
		  }
		}
		if (typeof Symbol === 'function') {
		  Readable.from = function (iterable, opts) {
		    if (from === undefined) {
		      from = requireFromBrowser();
		    }
		    return from(Readable, iterable, opts);
		  };
		}
		function indexOf(xs, x) {
		  for (var i = 0, l = xs.length; i < l; i++) {
		    if (xs[i] === x) return i;
		  }
		  return -1;
		}
		return _stream_readable;
	}

	var _stream_transform = Transform$7;
	var _require$codes$1 = errorsBrowser.codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	inherits_browserExports(Transform$7, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform$7(options) {
	  if (!(this instanceof Transform$7)) return new Transform$7(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform$7.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform$7.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform$7.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform$7.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform$7.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}

	var _stream_passthrough = PassThrough;
	var Transform$6 = _stream_transform;
	inherits_browserExports(PassThrough, Transform$6);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform$6.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = errorsBrowser.codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = endOfStream;
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	var pipeline_1 = pipeline;

	(function (module, exports) {
		exports = module.exports = require_stream_readable();
		exports.Stream = exports;
		exports.Readable = exports;
		exports.Writable = require_stream_writable();
		exports.Duplex = require_stream_duplex();
		exports.Transform = _stream_transform;
		exports.PassThrough = _stream_passthrough;
		exports.finished = endOfStream;
		exports.pipeline = pipeline_1; 
	} (readableBrowser, readableBrowser.exports));

	var readableBrowserExports = readableBrowser.exports;

	var Buffer$F = safeBufferExports.Buffer;
	var Transform$5 = readableBrowserExports.Transform;
	var inherits$v = inherits_browserExports;

	function throwIfNotStringOrBuffer (val, prefix) {
	  if (!Buffer$F.isBuffer(val) && typeof val !== 'string') {
	    throw new TypeError(prefix + ' must be a string or a buffer')
	  }
	}

	function HashBase$2 (blockSize) {
	  Transform$5.call(this);

	  this._block = Buffer$F.allocUnsafe(blockSize);
	  this._blockSize = blockSize;
	  this._blockOffset = 0;
	  this._length = [0, 0, 0, 0];

	  this._finalized = false;
	}

	inherits$v(HashBase$2, Transform$5);

	HashBase$2.prototype._transform = function (chunk, encoding, callback) {
	  var error = null;
	  try {
	    this.update(chunk, encoding);
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase$2.prototype._flush = function (callback) {
	  var error = null;
	  try {
	    this.push(this.digest());
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase$2.prototype.update = function (data, encoding) {
	  throwIfNotStringOrBuffer(data, 'Data');
	  if (this._finalized) throw new Error('Digest already called')
	  if (!Buffer$F.isBuffer(data)) data = Buffer$F.from(data, encoding);

	  // consume data
	  var block = this._block;
	  var offset = 0;
	  while (this._blockOffset + data.length - offset >= this._blockSize) {
	    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
	    this._update();
	    this._blockOffset = 0;
	  }
	  while (offset < data.length) block[this._blockOffset++] = data[offset++];

	  // update length
	  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
	    this._length[j] += carry;
	    carry = (this._length[j] / 0x0100000000) | 0;
	    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
	  }

	  return this
	};

	HashBase$2.prototype._update = function () {
	  throw new Error('_update is not implemented')
	};

	HashBase$2.prototype.digest = function (encoding) {
	  if (this._finalized) throw new Error('Digest already called')
	  this._finalized = true;

	  var digest = this._digest();
	  if (encoding !== undefined) digest = digest.toString(encoding);

	  // reset state
	  this._block.fill(0);
	  this._blockOffset = 0;
	  for (var i = 0; i < 4; ++i) this._length[i] = 0;

	  return digest
	};

	HashBase$2.prototype._digest = function () {
	  throw new Error('_digest is not implemented')
	};

	var hashBase = HashBase$2;

	var inherits$u = inherits_browserExports;
	var HashBase$1 = hashBase;
	var Buffer$E = safeBufferExports.Buffer;

	var ARRAY16$1 = new Array(16);

	function MD5$3 () {
	  HashBase$1.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	}

	inherits$u(MD5$3, HashBase$1);

	MD5$3.prototype._update = function () {
	  var M = ARRAY16$1;
	  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

	  var a = this._a;
	  var b = this._b;
	  var c = this._c;
	  var d = this._d;

	  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
	  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
	  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
	  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
	  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
	  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
	  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
	  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
	  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
	  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
	  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
	  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
	  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
	  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
	  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
	  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

	  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
	  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
	  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
	  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
	  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
	  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
	  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
	  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
	  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
	  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
	  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
	  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
	  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
	  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
	  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
	  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

	  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
	  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
	  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
	  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
	  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
	  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
	  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
	  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
	  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
	  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
	  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
	  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
	  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
	  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
	  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
	  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

	  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
	  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
	  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
	  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
	  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
	  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
	  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
	  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
	  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
	  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
	  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
	  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
	  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
	  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
	  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
	  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

	  this._a = (this._a + a) | 0;
	  this._b = (this._b + b) | 0;
	  this._c = (this._c + c) | 0;
	  this._d = (this._d + d) | 0;
	};

	MD5$3.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = Buffer$E.allocUnsafe(16);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  return buffer
	};

	function rotl$1 (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fnF (a, b, c, d, m, k, s) {
	  return (rotl$1((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
	}

	function fnG (a, b, c, d, m, k, s) {
	  return (rotl$1((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
	}

	function fnH (a, b, c, d, m, k, s) {
	  return (rotl$1((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
	}

	function fnI (a, b, c, d, m, k, s) {
	  return (rotl$1((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
	}

	var md5_js = MD5$3;

	var Buffer$D = require$$0$3.Buffer;
	var inherits$t = inherits_browserExports;
	var HashBase = hashBase;

	var ARRAY16 = new Array(16);

	var zl = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var zr = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var sl = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sr = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
	var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

	function RIPEMD160$4 () {
	  HashBase.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;
	}

	inherits$t(RIPEMD160$4, HashBase);

	RIPEMD160$4.prototype._update = function () {
	  var words = ARRAY16;
	  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

	  var al = this._a | 0;
	  var bl = this._b | 0;
	  var cl = this._c | 0;
	  var dl = this._d | 0;
	  var el = this._e | 0;

	  var ar = this._a | 0;
	  var br = this._b | 0;
	  var cr = this._c | 0;
	  var dr = this._d | 0;
	  var er = this._e | 0;

	  // computation
	  for (var i = 0; i < 80; i += 1) {
	    var tl;
	    var tr;
	    if (i < 16) {
	      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
	      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
	    } else if (i < 32) {
	      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
	      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
	    } else if (i < 48) {
	      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
	      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
	    } else if (i < 64) {
	      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
	      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
	    } else { // if (i<80) {
	      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
	      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
	    }

	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = tl;

	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = tr;
	  }

	  // update state
	  var t = (this._b + cl + dr) | 0;
	  this._b = (this._c + dl + er) | 0;
	  this._c = (this._d + el + ar) | 0;
	  this._d = (this._e + al + br) | 0;
	  this._e = (this._a + bl + cr) | 0;
	  this._a = t;
	};

	RIPEMD160$4.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = Buffer$D.alloc ? Buffer$D.alloc(20) : new Buffer$D(20);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  buffer.writeInt32LE(this._e, 16);
	  return buffer
	};

	function rotl (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fn1 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn2 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
	}

	function fn3 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn4 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
	}

	function fn5 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
	}

	var ripemd160 = RIPEMD160$4;

	var sha_js = {exports: {}};

	var Buffer$C = safeBufferExports.Buffer;

	// prototype class for hash functions
	function Hash$9 (blockSize, finalSize) {
	  this._block = Buffer$C.alloc(blockSize);
	  this._finalSize = finalSize;
	  this._blockSize = blockSize;
	  this._len = 0;
	}

	Hash$9.prototype.update = function (data, enc) {
	  if (typeof data === 'string') {
	    enc = enc || 'utf8';
	    data = Buffer$C.from(data, enc);
	  }

	  var block = this._block;
	  var blockSize = this._blockSize;
	  var length = data.length;
	  var accum = this._len;

	  for (var offset = 0; offset < length;) {
	    var assigned = accum % blockSize;
	    var remainder = Math.min(length - offset, blockSize - assigned);

	    for (var i = 0; i < remainder; i++) {
	      block[assigned + i] = data[offset + i];
	    }

	    accum += remainder;
	    offset += remainder;

	    if ((accum % blockSize) === 0) {
	      this._update(block);
	    }
	  }

	  this._len += length;
	  return this
	};

	Hash$9.prototype.digest = function (enc) {
	  var rem = this._len % this._blockSize;

	  this._block[rem] = 0x80;

	  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	  this._block.fill(0, rem + 1);

	  if (rem >= this._finalSize) {
	    this._update(this._block);
	    this._block.fill(0);
	  }

	  var bits = this._len * 8;

	  // uint32
	  if (bits <= 0xffffffff) {
	    this._block.writeUInt32BE(bits, this._blockSize - 4);

	  // uint64
	  } else {
	    var lowBits = (bits & 0xffffffff) >>> 0;
	    var highBits = (bits - lowBits) / 0x100000000;

	    this._block.writeUInt32BE(highBits, this._blockSize - 8);
	    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
	  }

	  this._update(this._block);
	  var hash = this._hash();

	  return enc ? hash.toString(enc) : hash
	};

	Hash$9.prototype._update = function () {
	  throw new Error('_update must be implemented by subclass')
	};

	var hash$3 = Hash$9;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
	 * in FIPS PUB 180-1
	 * This source code is derived from sha1.js of the same repository.
	 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
	 * operation was added.
	 */

	var inherits$s = inherits_browserExports;
	var Hash$8 = hash$3;
	var Buffer$B = safeBufferExports.Buffer;

	var K$4 = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W$5 = new Array(80);

	function Sha () {
	  this.init();
	  this._w = W$5;

	  Hash$8.call(this, 64, 56);
	}

	inherits$s(Sha, Hash$8);

	Sha.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl5$1 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30$1 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft$1 (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$4[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30$1(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha.prototype._hash = function () {
	  var H = Buffer$B.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	var sha$4 = Sha;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits$r = inherits_browserExports;
	var Hash$7 = hash$3;
	var Buffer$A = safeBufferExports.Buffer;

	var K$3 = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W$4 = new Array(80);

	function Sha1 () {
	  this.init();
	  this._w = W$4;

	  Hash$7.call(this, 64, 56);
	}

	inherits$r(Sha1, Hash$7);

	Sha1.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl1 (num) {
	  return (num << 1) | (num >>> 31)
	}

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha1.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K$3[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha1.prototype._hash = function () {
	  var H = Buffer$A.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	var sha1 = Sha1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits$q = inherits_browserExports;
	var Hash$6 = hash$3;
	var Buffer$z = safeBufferExports.Buffer;

	var K$2 = [
	  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	];

	var W$3 = new Array(64);

	function Sha256$1 () {
	  this.init();

	  this._w = W$3; // new Array(64)

	  Hash$6.call(this, 64, 56);
	}

	inherits$q(Sha256$1, Hash$6);

	Sha256$1.prototype.init = function () {
	  this._a = 0x6a09e667;
	  this._b = 0xbb67ae85;
	  this._c = 0x3c6ef372;
	  this._d = 0xa54ff53a;
	  this._e = 0x510e527f;
	  this._f = 0x9b05688c;
	  this._g = 0x1f83d9ab;
	  this._h = 0x5be0cd19;

	  return this
	};

	function ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj$1 (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0$1 (x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
	}

	function sigma1$1 (x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
	}

	function gamma0 (x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
	}

	function gamma1 (x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
	}

	Sha256$1.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;
	  var f = this._f | 0;
	  var g = this._g | 0;
	  var h = this._h | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

	  for (var j = 0; j < 64; ++j) {
	    var T1 = (h + sigma1$1(e) + ch(e, f, g) + K$2[j] + W[j]) | 0;
	    var T2 = (sigma0$1(a) + maj$1(a, b, c)) | 0;

	    h = g;
	    g = f;
	    f = e;
	    e = (d + T1) | 0;
	    d = c;
	    c = b;
	    b = a;
	    a = (T1 + T2) | 0;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	  this._f = (f + this._f) | 0;
	  this._g = (g + this._g) | 0;
	  this._h = (h + this._h) | 0;
	};

	Sha256$1.prototype._hash = function () {
	  var H = Buffer$z.allocUnsafe(32);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);
	  H.writeInt32BE(this._h, 28);

	  return H
	};

	var sha256$2 = Sha256$1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits$p = inherits_browserExports;
	var Sha256 = sha256$2;
	var Hash$5 = hash$3;
	var Buffer$y = safeBufferExports.Buffer;

	var W$2 = new Array(64);

	function Sha224 () {
	  this.init();

	  this._w = W$2; // new Array(64)

	  Hash$5.call(this, 64, 56);
	}

	inherits$p(Sha224, Sha256);

	Sha224.prototype.init = function () {
	  this._a = 0xc1059ed8;
	  this._b = 0x367cd507;
	  this._c = 0x3070dd17;
	  this._d = 0xf70e5939;
	  this._e = 0xffc00b31;
	  this._f = 0x68581511;
	  this._g = 0x64f98fa7;
	  this._h = 0xbefa4fa4;

	  return this
	};

	Sha224.prototype._hash = function () {
	  var H = Buffer$y.allocUnsafe(28);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);

	  return H
	};

	var sha224$1 = Sha224;

	var inherits$o = inherits_browserExports;
	var Hash$4 = hash$3;
	var Buffer$x = safeBufferExports.Buffer;

	var K$1 = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	var W$1 = new Array(160);

	function Sha512 () {
	  this.init();
	  this._w = W$1;

	  Hash$4.call(this, 128, 112);
	}

	inherits$o(Sha512, Hash$4);

	Sha512.prototype.init = function () {
	  this._ah = 0x6a09e667;
	  this._bh = 0xbb67ae85;
	  this._ch = 0x3c6ef372;
	  this._dh = 0xa54ff53a;
	  this._eh = 0x510e527f;
	  this._fh = 0x9b05688c;
	  this._gh = 0x1f83d9ab;
	  this._hh = 0x5be0cd19;

	  this._al = 0xf3bcc908;
	  this._bl = 0x84caa73b;
	  this._cl = 0xfe94f82b;
	  this._dl = 0x5f1d36f1;
	  this._el = 0xade682d1;
	  this._fl = 0x2b3e6c1f;
	  this._gl = 0xfb41bd6b;
	  this._hl = 0x137e2179;

	  return this
	};

	function Ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x, xl) {
	  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
	}

	function sigma1 (x, xl) {
	  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
	}

	function Gamma0 (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
	}

	function Gamma0l (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
	}

	function Gamma1 (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
	}

	function Gamma1l (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
	}

	function getCarry (a, b) {
	  return (a >>> 0) < (b >>> 0) ? 1 : 0
	}

	Sha512.prototype._update = function (M) {
	  var W = this._w;

	  var ah = this._ah | 0;
	  var bh = this._bh | 0;
	  var ch = this._ch | 0;
	  var dh = this._dh | 0;
	  var eh = this._eh | 0;
	  var fh = this._fh | 0;
	  var gh = this._gh | 0;
	  var hh = this._hh | 0;

	  var al = this._al | 0;
	  var bl = this._bl | 0;
	  var cl = this._cl | 0;
	  var dl = this._dl | 0;
	  var el = this._el | 0;
	  var fl = this._fl | 0;
	  var gl = this._gl | 0;
	  var hl = this._hl | 0;

	  for (var i = 0; i < 32; i += 2) {
	    W[i] = M.readInt32BE(i * 4);
	    W[i + 1] = M.readInt32BE(i * 4 + 4);
	  }
	  for (; i < 160; i += 2) {
	    var xh = W[i - 15 * 2];
	    var xl = W[i - 15 * 2 + 1];
	    var gamma0 = Gamma0(xh, xl);
	    var gamma0l = Gamma0l(xl, xh);

	    xh = W[i - 2 * 2];
	    xl = W[i - 2 * 2 + 1];
	    var gamma1 = Gamma1(xh, xl);
	    var gamma1l = Gamma1l(xl, xh);

	    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	    var Wi7h = W[i - 7 * 2];
	    var Wi7l = W[i - 7 * 2 + 1];

	    var Wi16h = W[i - 16 * 2];
	    var Wi16l = W[i - 16 * 2 + 1];

	    var Wil = (gamma0l + Wi7l) | 0;
	    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
	    Wil = (Wil + gamma1l) | 0;
	    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
	    Wil = (Wil + Wi16l) | 0;
	    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

	    W[i] = Wih;
	    W[i + 1] = Wil;
	  }

	  for (var j = 0; j < 160; j += 2) {
	    Wih = W[j];
	    Wil = W[j + 1];

	    var majh = maj(ah, bh, ch);
	    var majl = maj(al, bl, cl);

	    var sigma0h = sigma0(ah, al);
	    var sigma0l = sigma0(al, ah);
	    var sigma1h = sigma1(eh, el);
	    var sigma1l = sigma1(el, eh);

	    // t1 = h + sigma1 + ch + K[j] + W[j]
	    var Kih = K$1[j];
	    var Kil = K$1[j + 1];

	    var chh = Ch(eh, fh, gh);
	    var chl = Ch(el, fl, gl);

	    var t1l = (hl + sigma1l) | 0;
	    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
	    t1l = (t1l + chl) | 0;
	    t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
	    t1l = (t1l + Kil) | 0;
	    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
	    t1l = (t1l + Wil) | 0;
	    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

	    // t2 = sigma0 + maj
	    var t2l = (sigma0l + majl) | 0;
	    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

	    hh = gh;
	    hl = gl;
	    gh = fh;
	    gl = fl;
	    fh = eh;
	    fl = el;
	    el = (dl + t1l) | 0;
	    eh = (dh + t1h + getCarry(el, dl)) | 0;
	    dh = ch;
	    dl = cl;
	    ch = bh;
	    cl = bl;
	    bh = ah;
	    bl = al;
	    al = (t1l + t2l) | 0;
	    ah = (t1h + t2h + getCarry(al, t1l)) | 0;
	  }

	  this._al = (this._al + al) | 0;
	  this._bl = (this._bl + bl) | 0;
	  this._cl = (this._cl + cl) | 0;
	  this._dl = (this._dl + dl) | 0;
	  this._el = (this._el + el) | 0;
	  this._fl = (this._fl + fl) | 0;
	  this._gl = (this._gl + gl) | 0;
	  this._hl = (this._hl + hl) | 0;

	  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
	  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
	  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
	  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
	  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
	  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
	  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
	  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
	};

	Sha512.prototype._hash = function () {
	  var H = Buffer$x.allocUnsafe(64);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);
	  writeInt64BE(this._gh, this._gl, 48);
	  writeInt64BE(this._hh, this._hl, 56);

	  return H
	};

	var sha512$1 = Sha512;

	var inherits$n = inherits_browserExports;
	var SHA512$2 = sha512$1;
	var Hash$3 = hash$3;
	var Buffer$w = safeBufferExports.Buffer;

	var W = new Array(160);

	function Sha384 () {
	  this.init();
	  this._w = W;

	  Hash$3.call(this, 128, 112);
	}

	inherits$n(Sha384, SHA512$2);

	Sha384.prototype.init = function () {
	  this._ah = 0xcbbb9d5d;
	  this._bh = 0x629a292a;
	  this._ch = 0x9159015a;
	  this._dh = 0x152fecd8;
	  this._eh = 0x67332667;
	  this._fh = 0x8eb44a87;
	  this._gh = 0xdb0c2e0d;
	  this._hh = 0x47b5481d;

	  this._al = 0xc1059ed8;
	  this._bl = 0x367cd507;
	  this._cl = 0x3070dd17;
	  this._dl = 0xf70e5939;
	  this._el = 0xffc00b31;
	  this._fl = 0x68581511;
	  this._gl = 0x64f98fa7;
	  this._hl = 0xbefa4fa4;

	  return this
	};

	Sha384.prototype._hash = function () {
	  var H = Buffer$w.allocUnsafe(48);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);

	  return H
	};

	var sha384$1 = Sha384;

	var exports$1 = sha_js.exports = function SHA (algorithm) {
	  algorithm = algorithm.toLowerCase();

	  var Algorithm = exports$1[algorithm];
	  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

	  return new Algorithm()
	};

	exports$1.sha = sha$4;
	exports$1.sha1 = sha1;
	exports$1.sha224 = sha224$1;
	exports$1.sha256 = sha256$2;
	exports$1.sha384 = sha384$1;
	exports$1.sha512 = sha512$1;

	var sha_jsExports = sha_js.exports;

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var streamBrowserify = Stream;

	var EE = require$$0$4.EventEmitter;
	var inherits$m = inherits_browserExports;

	inherits$m(Stream, EE);
	Stream.Readable = require_stream_readable();
	Stream.Writable = require_stream_writable();
	Stream.Duplex = require_stream_duplex();
	Stream.Transform = _stream_transform;
	Stream.PassThrough = _stream_passthrough;
	Stream.finished = endOfStream;
	Stream.pipeline = pipeline_1;

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};

	var Buffer$v = safeBufferExports.Buffer;
	var Transform$4 = streamBrowserify.Transform;
	var StringDecoder = require$$2$1.StringDecoder;
	var inherits$l = inherits_browserExports;

	function CipherBase$1 (hashMode) {
	  Transform$4.call(this);
	  this.hashMode = typeof hashMode === 'string';
	  if (this.hashMode) {
	    this[hashMode] = this._finalOrDigest;
	  } else {
	    this.final = this._finalOrDigest;
	  }
	  if (this._final) {
	    this.__final = this._final;
	    this._final = null;
	  }
	  this._decoder = null;
	  this._encoding = null;
	}
	inherits$l(CipherBase$1, Transform$4);

	CipherBase$1.prototype.update = function (data, inputEnc, outputEnc) {
	  if (typeof data === 'string') {
	    data = Buffer$v.from(data, inputEnc);
	  }

	  var outData = this._update(data);
	  if (this.hashMode) return this

	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc);
	  }

	  return outData
	};

	CipherBase$1.prototype.setAutoPadding = function () {};
	CipherBase$1.prototype.getAuthTag = function () {
	  throw new Error('trying to get auth tag in unsupported state')
	};

	CipherBase$1.prototype.setAuthTag = function () {
	  throw new Error('trying to set auth tag in unsupported state')
	};

	CipherBase$1.prototype.setAAD = function () {
	  throw new Error('trying to set aad in unsupported state')
	};

	CipherBase$1.prototype._transform = function (data, _, next) {
	  var err;
	  try {
	    if (this.hashMode) {
	      this._update(data);
	    } else {
	      this.push(this._update(data));
	    }
	  } catch (e) {
	    err = e;
	  } finally {
	    next(err);
	  }
	};
	CipherBase$1.prototype._flush = function (done) {
	  var err;
	  try {
	    this.push(this.__final());
	  } catch (e) {
	    err = e;
	  }

	  done(err);
	};
	CipherBase$1.prototype._finalOrDigest = function (outputEnc) {
	  var outData = this.__final() || Buffer$v.alloc(0);
	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc, true);
	  }
	  return outData
	};

	CipherBase$1.prototype._toString = function (value, enc, fin) {
	  if (!this._decoder) {
	    this._decoder = new StringDecoder(enc);
	    this._encoding = enc;
	  }

	  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

	  var out = this._decoder.write(value);
	  if (fin) {
	    out += this._decoder.end();
	  }

	  return out
	};

	var cipherBase = CipherBase$1;

	var inherits$k = inherits_browserExports;
	var MD5$2 = md5_js;
	var RIPEMD160$3 = ripemd160;
	var sha$3 = sha_jsExports;
	var Base$5 = cipherBase;

	function Hash$2 (hash) {
	  Base$5.call(this, 'digest');

	  this._hash = hash;
	}

	inherits$k(Hash$2, Base$5);

	Hash$2.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hash$2.prototype._final = function () {
	  return this._hash.digest()
	};

	var browser$9 = function createHash (alg) {
	  alg = alg.toLowerCase();
	  if (alg === 'md5') return new MD5$2()
	  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160$3()

	  return new Hash$2(sha$3(alg))
	};

	var inherits$j = inherits_browserExports;
	var Buffer$u = safeBufferExports.Buffer;

	var Base$4 = cipherBase;

	var ZEROS$2 = Buffer$u.alloc(128);
	var blocksize = 64;

	function Hmac$3 (alg, key) {
	  Base$4.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer$u.from(key);
	  }

	  this._alg = alg;
	  this._key = key;

	  if (key.length > blocksize) {
	    key = alg(key);
	  } else if (key.length < blocksize) {
	    key = Buffer$u.concat([key, ZEROS$2], blocksize);
	  }

	  var ipad = this._ipad = Buffer$u.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer$u.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  this._hash = [ipad];
	}

	inherits$j(Hmac$3, Base$4);

	Hmac$3.prototype._update = function (data) {
	  this._hash.push(data);
	};

	Hmac$3.prototype._final = function () {
	  var h = this._alg(Buffer$u.concat(this._hash));
	  return this._alg(Buffer$u.concat([this._opad, h]))
	};
	var legacy = Hmac$3;

	var MD5$1 = md5_js;

	var md5$2 = function (buffer) {
	  return new MD5$1().update(buffer).digest()
	};

	var inherits$i = inherits_browserExports;
	var Legacy = legacy;
	var Base$3 = cipherBase;
	var Buffer$t = safeBufferExports.Buffer;
	var md5$1 = md5$2;
	var RIPEMD160$2 = ripemd160;

	var sha$2 = sha_jsExports;

	var ZEROS$1 = Buffer$t.alloc(128);

	function Hmac$2 (alg, key) {
	  Base$3.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer$t.from(key);
	  }

	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  this._alg = alg;
	  this._key = key;
	  if (key.length > blocksize) {
	    var hash = alg === 'rmd160' ? new RIPEMD160$2() : sha$2(alg);
	    key = hash.update(key).digest();
	  } else if (key.length < blocksize) {
	    key = Buffer$t.concat([key, ZEROS$1], blocksize);
	  }

	  var ipad = this._ipad = Buffer$t.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer$t.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }
	  this._hash = alg === 'rmd160' ? new RIPEMD160$2() : sha$2(alg);
	  this._hash.update(ipad);
	}

	inherits$i(Hmac$2, Base$3);

	Hmac$2.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hmac$2.prototype._final = function () {
	  var h = this._hash.digest();
	  var hash = this._alg === 'rmd160' ? new RIPEMD160$2() : sha$2(this._alg);
	  return hash.update(this._opad).update(h).digest()
	};

	var browser$8 = function createHmac (alg, key) {
	  alg = alg.toLowerCase();
	  if (alg === 'rmd160' || alg === 'ripemd160') {
	    return new Hmac$2('rmd160', key)
	  }
	  if (alg === 'md5') {
	    return new Legacy(md5$1, key)
	  }
	  return new Hmac$2(alg, key)
	};

	var sha224WithRSAEncryption = {
		sign: "rsa",
		hash: "sha224",
		id: "302d300d06096086480165030402040500041c"
	};
	var sha256WithRSAEncryption = {
		sign: "rsa",
		hash: "sha256",
		id: "3031300d060960864801650304020105000420"
	};
	var sha384WithRSAEncryption = {
		sign: "rsa",
		hash: "sha384",
		id: "3041300d060960864801650304020205000430"
	};
	var sha512WithRSAEncryption = {
		sign: "rsa",
		hash: "sha512",
		id: "3051300d060960864801650304020305000440"
	};
	var sha256$1 = {
		sign: "ecdsa",
		hash: "sha256",
		id: ""
	};
	var sha224 = {
		sign: "ecdsa",
		hash: "sha224",
		id: ""
	};
	var sha384 = {
		sign: "ecdsa",
		hash: "sha384",
		id: ""
	};
	var sha512 = {
		sign: "ecdsa",
		hash: "sha512",
		id: ""
	};
	var DSA = {
		sign: "dsa",
		hash: "sha1",
		id: ""
	};
	var ripemd160WithRSA = {
		sign: "rsa",
		hash: "rmd160",
		id: "3021300906052b2403020105000414"
	};
	var md5WithRSAEncryption = {
		sign: "rsa",
		hash: "md5",
		id: "3020300c06082a864886f70d020505000410"
	};
	var require$$6 = {
		sha224WithRSAEncryption: sha224WithRSAEncryption,
		"RSA-SHA224": {
		sign: "ecdsa/rsa",
		hash: "sha224",
		id: "302d300d06096086480165030402040500041c"
	},
		sha256WithRSAEncryption: sha256WithRSAEncryption,
		"RSA-SHA256": {
		sign: "ecdsa/rsa",
		hash: "sha256",
		id: "3031300d060960864801650304020105000420"
	},
		sha384WithRSAEncryption: sha384WithRSAEncryption,
		"RSA-SHA384": {
		sign: "ecdsa/rsa",
		hash: "sha384",
		id: "3041300d060960864801650304020205000430"
	},
		sha512WithRSAEncryption: sha512WithRSAEncryption,
		"RSA-SHA512": {
		sign: "ecdsa/rsa",
		hash: "sha512",
		id: "3051300d060960864801650304020305000440"
	},
		"RSA-SHA1": {
		sign: "rsa",
		hash: "sha1",
		id: "3021300906052b0e03021a05000414"
	},
		"ecdsa-with-SHA1": {
		sign: "ecdsa",
		hash: "sha1",
		id: ""
	},
		sha256: sha256$1,
		sha224: sha224,
		sha384: sha384,
		sha512: sha512,
		"DSA-SHA": {
		sign: "dsa",
		hash: "sha1",
		id: ""
	},
		"DSA-SHA1": {
		sign: "dsa",
		hash: "sha1",
		id: ""
	},
		DSA: DSA,
		"DSA-WITH-SHA224": {
		sign: "dsa",
		hash: "sha224",
		id: ""
	},
		"DSA-SHA224": {
		sign: "dsa",
		hash: "sha224",
		id: ""
	},
		"DSA-WITH-SHA256": {
		sign: "dsa",
		hash: "sha256",
		id: ""
	},
		"DSA-SHA256": {
		sign: "dsa",
		hash: "sha256",
		id: ""
	},
		"DSA-WITH-SHA384": {
		sign: "dsa",
		hash: "sha384",
		id: ""
	},
		"DSA-SHA384": {
		sign: "dsa",
		hash: "sha384",
		id: ""
	},
		"DSA-WITH-SHA512": {
		sign: "dsa",
		hash: "sha512",
		id: ""
	},
		"DSA-SHA512": {
		sign: "dsa",
		hash: "sha512",
		id: ""
	},
		"DSA-RIPEMD160": {
		sign: "dsa",
		hash: "rmd160",
		id: ""
	},
		ripemd160WithRSA: ripemd160WithRSA,
		"RSA-RIPEMD160": {
		sign: "rsa",
		hash: "rmd160",
		id: "3021300906052b2403020105000414"
	},
		md5WithRSAEncryption: md5WithRSAEncryption,
		"RSA-MD5": {
		sign: "rsa",
		hash: "md5",
		id: "3020300c06082a864886f70d020505000410"
	}
	};

	var algos = require$$6;

	var browser$7 = {};

	var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

	var precondition = function (iterations, keylen) {
	  if (typeof iterations !== 'number') {
	    throw new TypeError('Iterations not a number')
	  }

	  if (iterations < 0) {
	    throw new TypeError('Bad iterations')
	  }

	  if (typeof keylen !== 'number') {
	    throw new TypeError('Key length not a number')
	  }

	  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
	    throw new TypeError('Bad key length')
	  }
	};

	var defaultEncoding$2;
	/* istanbul ignore next */
	if (commonjsGlobal.process && commonjsGlobal.process.browser) {
	  defaultEncoding$2 = 'utf-8';
	} else if (commonjsGlobal.process && commonjsGlobal.process.version) {
	  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);

	  defaultEncoding$2 = pVersionMajor >= 6 ? 'utf-8' : 'binary';
	} else {
	  defaultEncoding$2 = 'utf-8';
	}
	var defaultEncoding_1 = defaultEncoding$2;

	var Buffer$s = safeBufferExports.Buffer;

	var toBuffer$2 = function (thing, encoding, name) {
	  if (Buffer$s.isBuffer(thing)) {
	    return thing
	  } else if (typeof thing === 'string') {
	    return Buffer$s.from(thing, encoding)
	  } else if (ArrayBuffer.isView(thing)) {
	    return Buffer$s.from(thing.buffer)
	  } else {
	    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
	  }
	};

	var md5 = md5$2;
	var RIPEMD160$1 = ripemd160;
	var sha$1 = sha_jsExports;
	var Buffer$r = safeBufferExports.Buffer;

	var checkParameters$1 = precondition;
	var defaultEncoding$1 = defaultEncoding_1;
	var toBuffer$1 = toBuffer$2;

	var ZEROS = Buffer$r.alloc(128);
	var sizes = {
	  md5: 16,
	  sha1: 20,
	  sha224: 28,
	  sha256: 32,
	  sha384: 48,
	  sha512: 64,
	  rmd160: 20,
	  ripemd160: 20
	};

	function Hmac$1 (alg, key, saltLen) {
	  var hash = getDigest$1(alg);
	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  if (key.length > blocksize) {
	    key = hash(key);
	  } else if (key.length < blocksize) {
	    key = Buffer$r.concat([key, ZEROS], blocksize);
	  }

	  var ipad = Buffer$r.allocUnsafe(blocksize + sizes[alg]);
	  var opad = Buffer$r.allocUnsafe(blocksize + sizes[alg]);
	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  var ipad1 = Buffer$r.allocUnsafe(blocksize + saltLen + 4);
	  ipad.copy(ipad1, 0, 0, blocksize);
	  this.ipad1 = ipad1;
	  this.ipad2 = ipad;
	  this.opad = opad;
	  this.alg = alg;
	  this.blocksize = blocksize;
	  this.hash = hash;
	  this.size = sizes[alg];
	}

	Hmac$1.prototype.run = function (data, ipad) {
	  data.copy(ipad, this.blocksize);
	  var h = this.hash(ipad);
	  h.copy(this.opad, this.blocksize);
	  return this.hash(this.opad)
	};

	function getDigest$1 (alg) {
	  function shaFunc (data) {
	    return sha$1(alg).update(data).digest()
	  }
	  function rmd160Func (data) {
	    return new RIPEMD160$1().update(data).digest()
	  }

	  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
	  if (alg === 'md5') return md5
	  return shaFunc
	}

	function pbkdf2 (password, salt, iterations, keylen, digest) {
	  checkParameters$1(iterations, keylen);
	  password = toBuffer$1(password, defaultEncoding$1, 'Password');
	  salt = toBuffer$1(salt, defaultEncoding$1, 'Salt');

	  digest = digest || 'sha1';

	  var hmac = new Hmac$1(digest, password, salt.length);

	  var DK = Buffer$r.allocUnsafe(keylen);
	  var block1 = Buffer$r.allocUnsafe(salt.length + 4);
	  salt.copy(block1, 0, 0, salt.length);

	  var destPos = 0;
	  var hLen = sizes[digest];
	  var l = Math.ceil(keylen / hLen);

	  for (var i = 1; i <= l; i++) {
	    block1.writeUInt32BE(i, salt.length);

	    var T = hmac.run(block1, hmac.ipad1);
	    var U = T;

	    for (var j = 1; j < iterations; j++) {
	      U = hmac.run(U, hmac.ipad2);
	      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
	    }

	    T.copy(DK, destPos);
	    destPos += hLen;
	  }

	  return DK
	}

	var syncBrowser = pbkdf2;

	var Buffer$q = safeBufferExports.Buffer;

	var checkParameters = precondition;
	var defaultEncoding = defaultEncoding_1;
	var sync = syncBrowser;
	var toBuffer = toBuffer$2;

	var ZERO_BUF;
	var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
	var toBrowser = {
	  sha: 'SHA-1',
	  'sha-1': 'SHA-1',
	  sha1: 'SHA-1',
	  sha256: 'SHA-256',
	  'sha-256': 'SHA-256',
	  sha384: 'SHA-384',
	  'sha-384': 'SHA-384',
	  'sha-512': 'SHA-512',
	  sha512: 'SHA-512'
	};
	var checks = [];
	function checkNative (algo) {
	  if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
	    return Promise.resolve(false)
	  }
	  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
	    return Promise.resolve(false)
	  }
	  if (checks[algo] !== undefined) {
	    return checks[algo]
	  }
	  ZERO_BUF = ZERO_BUF || Buffer$q.alloc(8);
	  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
	    .then(function () {
	      return true
	    }).catch(function () {
	      return false
	    });
	  checks[algo] = prom;
	  return prom
	}
	var nextTick;
	function getNextTick () {
	  if (nextTick) {
	    return nextTick
	  }
	  if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
	    nextTick = commonjsGlobal.process.nextTick;
	  } else if (commonjsGlobal.queueMicrotask) {
	    nextTick = commonjsGlobal.queueMicrotask;
	  } else if (commonjsGlobal.setImmediate) {
	    nextTick = commonjsGlobal.setImmediate;
	  } else {
	    nextTick = commonjsGlobal.setTimeout;
	  }
	  return nextTick
	}
	function browserPbkdf2 (password, salt, iterations, length, algo) {
	  return subtle.importKey(
	    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
	  ).then(function (key) {
	    return subtle.deriveBits({
	      name: 'PBKDF2',
	      salt: salt,
	      iterations: iterations,
	      hash: {
	        name: algo
	      }
	    }, key, length << 3)
	  }).then(function (res) {
	    return Buffer$q.from(res)
	  })
	}

	function resolvePromise (promise, callback) {
	  promise.then(function (out) {
	    getNextTick()(function () {
	      callback(null, out);
	    });
	  }, function (e) {
	    getNextTick()(function () {
	      callback(e);
	    });
	  });
	}
	var async = function (password, salt, iterations, keylen, digest, callback) {
	  if (typeof digest === 'function') {
	    callback = digest;
	    digest = undefined;
	  }

	  digest = digest || 'sha1';
	  var algo = toBrowser[digest.toLowerCase()];

	  if (!algo || typeof commonjsGlobal.Promise !== 'function') {
	    getNextTick()(function () {
	      var out;
	      try {
	        out = sync(password, salt, iterations, keylen, digest);
	      } catch (e) {
	        return callback(e)
	      }
	      callback(null, out);
	    });
	    return
	  }

	  checkParameters(iterations, keylen);
	  password = toBuffer(password, defaultEncoding, 'Password');
	  salt = toBuffer(salt, defaultEncoding, 'Salt');
	  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

	  resolvePromise(checkNative(algo).then(function (resp) {
	    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

	    return sync(password, salt, iterations, keylen, digest)
	  }), callback);
	};

	browser$7.pbkdf2 = async;
	browser$7.pbkdf2Sync = syncBrowser;

	var browser$6 = {};

	var des$2 = {};

	var utils$n = {};

	utils$n.readUInt32BE = function readUInt32BE(bytes, off) {
	  var res =  (bytes[0 + off] << 24) |
	             (bytes[1 + off] << 16) |
	             (bytes[2 + off] << 8) |
	             bytes[3 + off];
	  return res >>> 0;
	};

	utils$n.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
	  bytes[0 + off] = value >>> 24;
	  bytes[1 + off] = (value >>> 16) & 0xff;
	  bytes[2 + off] = (value >>> 8) & 0xff;
	  bytes[3 + off] = value & 0xff;
	};

	utils$n.ip = function ip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$n.rip = function rip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 0; i < 4; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }
	  for (var i = 4; i < 8; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$n.pc1 = function pc1(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  // 7, 15, 23, 31, 39, 47, 55, 63
	  // 6, 14, 22, 30, 39, 47, 55, 63
	  // 5, 13, 21, 29, 39, 47, 55, 63
	  // 4, 12, 20, 28
	  for (var i = 7; i >= 5; i--) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outL <<= 1;
	    outL |= (inR >> (j + i)) & 1;
	  }

	  // 1, 9, 17, 25, 33, 41, 49, 57
	  // 2, 10, 18, 26, 34, 42, 50, 58
	  // 3, 11, 19, 27, 35, 43, 51, 59
	  // 36, 44, 52, 60
	  for (var i = 1; i <= 3; i++) {
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outR <<= 1;
	    outR |= (inL >> (j + i)) & 1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$n.r28shl = function r28shl(num, shift) {
	  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
	};

	var pc2table = [
	  // inL => outL
	  14, 11, 17, 4, 27, 23, 25, 0,
	  13, 22, 7, 18, 5, 9, 16, 24,
	  2, 20, 12, 21, 1, 8, 15, 26,

	  // inR => outR
	  15, 4, 25, 19, 9, 1, 26, 16,
	  5, 11, 23, 8, 12, 7, 17, 0,
	  22, 3, 10, 14, 6, 20, 27, 24
	];

	utils$n.pc2 = function pc2(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  var len = pc2table.length >>> 1;
	  for (var i = 0; i < len; i++) {
	    outL <<= 1;
	    outL |= (inL >>> pc2table[i]) & 0x1;
	  }
	  for (var i = len; i < pc2table.length; i++) {
	    outR <<= 1;
	    outR |= (inR >>> pc2table[i]) & 0x1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$n.expand = function expand(r, out, off) {
	  var outL = 0;
	  var outR = 0;

	  outL = ((r & 1) << 5) | (r >>> 27);
	  for (var i = 23; i >= 15; i -= 4) {
	    outL <<= 6;
	    outL |= (r >>> i) & 0x3f;
	  }
	  for (var i = 11; i >= 3; i -= 4) {
	    outR |= (r >>> i) & 0x3f;
	    outR <<= 6;
	  }
	  outR |= ((r & 0x1f) << 1) | (r >>> 31);

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var sTable = [
	  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
	  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
	  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
	  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

	  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
	  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
	  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
	  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

	  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
	  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
	  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
	  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

	  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
	  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
	  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
	  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

	  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
	  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
	  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
	  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

	  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
	  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
	  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
	  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

	  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
	  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
	  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
	  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

	  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
	  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
	  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
	  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
	];

	utils$n.substitute = function substitute(inL, inR) {
	  var out = 0;
	  for (var i = 0; i < 4; i++) {
	    var b = (inL >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  for (var i = 0; i < 4; i++) {
	    var b = (inR >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[4 * 0x40 + i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  return out >>> 0;
	};

	var permuteTable = [
	  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
	  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
	];

	utils$n.permute = function permute(num) {
	  var out = 0;
	  for (var i = 0; i < permuteTable.length; i++) {
	    out <<= 1;
	    out |= (num >>> permuteTable[i]) & 0x1;
	  }
	  return out >>> 0;
	};

	utils$n.padSplit = function padSplit(num, size, group) {
	  var str = num.toString(2);
	  while (str.length < size)
	    str = '0' + str;

	  var out = [];
	  for (var i = 0; i < size; i += group)
	    out.push(str.slice(i, i + group));
	  return out.join(' ');
	};

	var minimalisticAssert = assert$k;

	function assert$k(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert$k.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};

	var assert$j = minimalisticAssert;

	function Cipher$3(options) {
	  this.options = options;

	  this.type = this.options.type;
	  this.blockSize = 8;
	  this._init();

	  this.buffer = new Array(this.blockSize);
	  this.bufferOff = 0;
	  this.padding = options.padding !== false;
	}
	var cipher = Cipher$3;

	Cipher$3.prototype._init = function _init() {
	  // Might be overrided
	};

	Cipher$3.prototype.update = function update(data) {
	  if (data.length === 0)
	    return [];

	  if (this.type === 'decrypt')
	    return this._updateDecrypt(data);
	  else
	    return this._updateEncrypt(data);
	};

	Cipher$3.prototype._buffer = function _buffer(data, off) {
	  // Append data to buffer
	  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
	  for (var i = 0; i < min; i++)
	    this.buffer[this.bufferOff + i] = data[off + i];
	  this.bufferOff += min;

	  // Shift next
	  return min;
	};

	Cipher$3.prototype._flushBuffer = function _flushBuffer(out, off) {
	  this._update(this.buffer, 0, out, off);
	  this.bufferOff = 0;
	  return this.blockSize;
	};

	Cipher$3.prototype._updateEncrypt = function _updateEncrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
	  var out = new Array(count * this.blockSize);

	  if (this.bufferOff !== 0) {
	    inputOff += this._buffer(data, inputOff);

	    if (this.bufferOff === this.buffer.length)
	      outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Write blocks
	  var max = data.length - ((data.length - inputOff) % this.blockSize);
	  for (; inputOff < max; inputOff += this.blockSize) {
	    this._update(data, inputOff, out, outputOff);
	    outputOff += this.blockSize;
	  }

	  // Queue rest
	  for (; inputOff < data.length; inputOff++, this.bufferOff++)
	    this.buffer[this.bufferOff] = data[inputOff];

	  return out;
	};

	Cipher$3.prototype._updateDecrypt = function _updateDecrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
	  var out = new Array(count * this.blockSize);

	  // TODO(indutny): optimize it, this is far from optimal
	  for (; count > 0; count--) {
	    inputOff += this._buffer(data, inputOff);
	    outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Buffer rest of the input
	  inputOff += this._buffer(data, inputOff);

	  return out;
	};

	Cipher$3.prototype.final = function final(buffer) {
	  var first;
	  if (buffer)
	    first = this.update(buffer);

	  var last;
	  if (this.type === 'encrypt')
	    last = this._finalEncrypt();
	  else
	    last = this._finalDecrypt();

	  if (first)
	    return first.concat(last);
	  else
	    return last;
	};

	Cipher$3.prototype._pad = function _pad(buffer, off) {
	  if (off === 0)
	    return false;

	  while (off < buffer.length)
	    buffer[off++] = 0;

	  return true;
	};

	Cipher$3.prototype._finalEncrypt = function _finalEncrypt() {
	  if (!this._pad(this.buffer, this.bufferOff))
	    return [];

	  var out = new Array(this.blockSize);
	  this._update(this.buffer, 0, out, 0);
	  return out;
	};

	Cipher$3.prototype._unpad = function _unpad(buffer) {
	  return buffer;
	};

	Cipher$3.prototype._finalDecrypt = function _finalDecrypt() {
	  assert$j.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
	  var out = new Array(this.blockSize);
	  this._flushBuffer(out, 0);

	  return this._unpad(out);
	};

	var assert$i = minimalisticAssert;
	var inherits$h = inherits_browserExports;

	var utils$m = utils$n;
	var Cipher$2 = cipher;

	function DESState() {
	  this.tmp = new Array(2);
	  this.keys = null;
	}

	function DES$3(options) {
	  Cipher$2.call(this, options);

	  var state = new DESState();
	  this._desState = state;

	  this.deriveKeys(state, options.key);
	}
	inherits$h(DES$3, Cipher$2);
	var des$1 = DES$3;

	DES$3.create = function create(options) {
	  return new DES$3(options);
	};

	var shiftTable = [
	  1, 1, 2, 2, 2, 2, 2, 2,
	  1, 2, 2, 2, 2, 2, 2, 1
	];

	DES$3.prototype.deriveKeys = function deriveKeys(state, key) {
	  state.keys = new Array(16 * 2);

	  assert$i.equal(key.length, this.blockSize, 'Invalid key length');

	  var kL = utils$m.readUInt32BE(key, 0);
	  var kR = utils$m.readUInt32BE(key, 4);

	  utils$m.pc1(kL, kR, state.tmp, 0);
	  kL = state.tmp[0];
	  kR = state.tmp[1];
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var shift = shiftTable[i >>> 1];
	    kL = utils$m.r28shl(kL, shift);
	    kR = utils$m.r28shl(kR, shift);
	    utils$m.pc2(kL, kR, state.keys, i);
	  }
	};

	DES$3.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._desState;

	  var l = utils$m.readUInt32BE(inp, inOff);
	  var r = utils$m.readUInt32BE(inp, inOff + 4);

	  // Initial Permutation
	  utils$m.ip(l, r, state.tmp, 0);
	  l = state.tmp[0];
	  r = state.tmp[1];

	  if (this.type === 'encrypt')
	    this._encrypt(state, l, r, state.tmp, 0);
	  else
	    this._decrypt(state, l, r, state.tmp, 0);

	  l = state.tmp[0];
	  r = state.tmp[1];

	  utils$m.writeUInt32BE(out, l, outOff);
	  utils$m.writeUInt32BE(out, r, outOff + 4);
	};

	DES$3.prototype._pad = function _pad(buffer, off) {
	  if (this.padding === false) {
	    return false;
	  }

	  var value = buffer.length - off;
	  for (var i = off; i < buffer.length; i++)
	    buffer[i] = value;

	  return true;
	};

	DES$3.prototype._unpad = function _unpad(buffer) {
	  if (this.padding === false) {
	    return buffer;
	  }

	  var pad = buffer[buffer.length - 1];
	  for (var i = buffer.length - pad; i < buffer.length; i++)
	    assert$i.equal(buffer[i], pad);

	  return buffer.slice(0, buffer.length - pad);
	};

	DES$3.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
	  var l = lStart;
	  var r = rStart;

	  // Apply f() x16 times
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils$m.expand(r, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils$m.substitute(keyL, keyR);
	    var f = utils$m.permute(s);

	    var t = r;
	    r = (l ^ f) >>> 0;
	    l = t;
	  }

	  // Reverse Initial Permutation
	  utils$m.rip(r, l, out, off);
	};

	DES$3.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
	  var l = rStart;
	  var r = lStart;

	  // Apply f() x16 times
	  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils$m.expand(l, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils$m.substitute(keyL, keyR);
	    var f = utils$m.permute(s);

	    var t = l;
	    l = (r ^ f) >>> 0;
	    r = t;
	  }

	  // Reverse Initial Permutation
	  utils$m.rip(l, r, out, off);
	};

	var cbc$1 = {};

	var assert$h = minimalisticAssert;
	var inherits$g = inherits_browserExports;

	var proto = {};

	function CBCState(iv) {
	  assert$h.equal(iv.length, 8, 'Invalid IV length');

	  this.iv = new Array(8);
	  for (var i = 0; i < this.iv.length; i++)
	    this.iv[i] = iv[i];
	}

	function instantiate(Base) {
	  function CBC(options) {
	    Base.call(this, options);
	    this._cbcInit();
	  }
	  inherits$g(CBC, Base);

	  var keys = Object.keys(proto);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    CBC.prototype[key] = proto[key];
	  }

	  CBC.create = function create(options) {
	    return new CBC(options);
	  };

	  return CBC;
	}

	cbc$1.instantiate = instantiate;

	proto._cbcInit = function _cbcInit() {
	  var state = new CBCState(this.options.iv);
	  this._cbcState = state;
	};

	proto._update = function _update(inp, inOff, out, outOff) {
	  var state = this._cbcState;
	  var superProto = this.constructor.super_.prototype;

	  var iv = state.iv;
	  if (this.type === 'encrypt') {
	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] ^= inp[inOff + i];

	    superProto._update.call(this, iv, 0, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = out[outOff + i];
	  } else {
	    superProto._update.call(this, inp, inOff, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      out[outOff + i] ^= iv[i];

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = inp[inOff + i];
	  }
	};

	var assert$g = minimalisticAssert;
	var inherits$f = inherits_browserExports;

	var Cipher$1 = cipher;
	var DES$2 = des$1;

	function EDEState(type, key) {
	  assert$g.equal(key.length, 24, 'Invalid key length');

	  var k1 = key.slice(0, 8);
	  var k2 = key.slice(8, 16);
	  var k3 = key.slice(16, 24);

	  if (type === 'encrypt') {
	    this.ciphers = [
	      DES$2.create({ type: 'encrypt', key: k1 }),
	      DES$2.create({ type: 'decrypt', key: k2 }),
	      DES$2.create({ type: 'encrypt', key: k3 })
	    ];
	  } else {
	    this.ciphers = [
	      DES$2.create({ type: 'decrypt', key: k3 }),
	      DES$2.create({ type: 'encrypt', key: k2 }),
	      DES$2.create({ type: 'decrypt', key: k1 })
	    ];
	  }
	}

	function EDE(options) {
	  Cipher$1.call(this, options);

	  var state = new EDEState(this.type, this.options.key);
	  this._edeState = state;
	}
	inherits$f(EDE, Cipher$1);

	var ede = EDE;

	EDE.create = function create(options) {
	  return new EDE(options);
	};

	EDE.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._edeState;

	  state.ciphers[0]._update(inp, inOff, out, outOff);
	  state.ciphers[1]._update(out, outOff, out, outOff);
	  state.ciphers[2]._update(out, outOff, out, outOff);
	};

	EDE.prototype._pad = DES$2.prototype._pad;
	EDE.prototype._unpad = DES$2.prototype._unpad;

	des$2.utils = utils$n;
	des$2.Cipher = cipher;
	des$2.DES = des$1;
	des$2.CBC = cbc$1;
	des$2.EDE = ede;

	var CipherBase = cipherBase;
	var des = des$2;
	var inherits$e = inherits_browserExports;
	var Buffer$p = safeBufferExports.Buffer;

	var modes$3 = {
	  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede3': des.EDE,
	  'des-ede-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede': des.EDE,
	  'des-cbc': des.CBC.instantiate(des.DES),
	  'des-ecb': des.DES
	};
	modes$3.des = modes$3['des-cbc'];
	modes$3.des3 = modes$3['des-ede3-cbc'];
	var browserifyDes = DES$1;
	inherits$e(DES$1, CipherBase);
	function DES$1 (opts) {
	  CipherBase.call(this);
	  var modeName = opts.mode.toLowerCase();
	  var mode = modes$3[modeName];
	  var type;
	  if (opts.decrypt) {
	    type = 'decrypt';
	  } else {
	    type = 'encrypt';
	  }
	  var key = opts.key;
	  if (!Buffer$p.isBuffer(key)) {
	    key = Buffer$p.from(key);
	  }
	  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
	    key = Buffer$p.concat([key, key.slice(0, 8)]);
	  }
	  var iv = opts.iv;
	  if (!Buffer$p.isBuffer(iv)) {
	    iv = Buffer$p.from(iv);
	  }
	  this._des = mode.create({
	    key: key,
	    iv: iv,
	    type: type
	  });
	}
	DES$1.prototype._update = function (data) {
	  return Buffer$p.from(this._des.update(data))
	};
	DES$1.prototype._final = function () {
	  return Buffer$p.from(this._des.final())
	};

	var browser$5 = {};

	var encrypter = {};

	var ecb = {};

	ecb.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block)
	};

	ecb.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block)
	};

	var cbc = {};

	var bufferXor = function xor (a, b) {
	  var length = Math.min(a.length, b.length);
	  var buffer = new require$$0$3.Buffer(length);

	  for (var i = 0; i < length; ++i) {
	    buffer[i] = a[i] ^ b[i];
	  }

	  return buffer
	};

	var xor$7 = bufferXor;

	cbc.encrypt = function (self, block) {
	  var data = xor$7(block, self._prev);

	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev
	};

	cbc.decrypt = function (self, block) {
	  var pad = self._prev;

	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);

	  return xor$7(out, pad)
	};

	var cfb = {};

	var Buffer$o = safeBufferExports.Buffer;
	var xor$6 = bufferXor;

	function encryptStart (self, data, decrypt) {
	  var len = data.length;
	  var out = xor$6(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer$o.concat([self._prev, decrypt ? data : out]);
	  return out
	}

	cfb.encrypt = function (self, data, decrypt) {
	  var out = Buffer$o.allocUnsafe(0);
	  var len;

	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = Buffer$o.allocUnsafe(0);
	    }

	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer$o.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer$o.concat([out, encryptStart(self, data, decrypt)]);
	      break
	    }
	  }

	  return out
	};

	var cfb8 = {};

	var Buffer$n = safeBufferExports.Buffer;

	function encryptByte$1 (self, byteParam, decrypt) {
	  var pad = self._cipher.encryptBlock(self._prev);
	  var out = pad[0] ^ byteParam;

	  self._prev = Buffer$n.concat([
	    self._prev.slice(1),
	    Buffer$n.from([decrypt ? byteParam : out])
	  ]);

	  return out
	}

	cfb8.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer$n.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte$1(self, chunk[i], decrypt);
	  }

	  return out
	};

	var cfb1 = {};

	var Buffer$m = safeBufferExports.Buffer;

	function encryptByte (self, byteParam, decrypt) {
	  var pad;
	  var i = -1;
	  var len = 8;
	  var out = 0;
	  var bit, value;
	  while (++i < len) {
	    pad = self._cipher.encryptBlock(self._prev);
	    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
	    value = pad[0] ^ bit;
	    out += ((value & 0x80) >> (i % 8));
	    self._prev = shiftIn(self._prev, decrypt ? bit : value);
	  }
	  return out
	}

	function shiftIn (buffer, value) {
	  var len = buffer.length;
	  var i = -1;
	  var out = Buffer$m.allocUnsafe(buffer.length);
	  buffer = Buffer$m.concat([buffer, Buffer$m.from([value])]);

	  while (++i < len) {
	    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
	  }

	  return out
	}

	cfb1.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer$m.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt);
	  }

	  return out
	};

	var ofb = {};

	var xor$5 = bufferXor;

	function getBlock$1 (self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev
	}

	ofb.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = require$$0$3.Buffer.concat([self._cache, getBlock$1(self)]);
	  }

	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor$5(chunk, pad)
	};

	var ctr = {};

	function incr32$2 (iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break
	    }
	  }
	}
	var incr32_1 = incr32$2;

	var xor$4 = bufferXor;
	var Buffer$l = safeBufferExports.Buffer;
	var incr32$1 = incr32_1;

	function getBlock (self) {
	  var out = self._cipher.encryptBlockRaw(self._prev);
	  incr32$1(self._prev);
	  return out
	}

	var blockSize = 16;
	ctr.encrypt = function (self, chunk) {
	  var chunkNum = Math.ceil(chunk.length / blockSize);
	  var start = self._cache.length;
	  self._cache = Buffer$l.concat([
	    self._cache,
	    Buffer$l.allocUnsafe(chunkNum * blockSize)
	  ]);
	  for (var i = 0; i < chunkNum; i++) {
	    var out = getBlock(self);
	    var offset = start + i * blockSize;
	    self._cache.writeUInt32BE(out[0], offset + 0);
	    self._cache.writeUInt32BE(out[1], offset + 4);
	    self._cache.writeUInt32BE(out[2], offset + 8);
	    self._cache.writeUInt32BE(out[3], offset + 12);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor$4(chunk, pad)
	};

	var aes128 = {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var aes192 = {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var aes256 = {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CBC",
		type: "block"
	};
	var require$$2 = {
		"aes-128-ecb": {
		cipher: "AES",
		key: 128,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-192-ecb": {
		cipher: "AES",
		key: 192,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-256-ecb": {
		cipher: "AES",
		key: 256,
		iv: 0,
		mode: "ECB",
		type: "block"
	},
		"aes-128-cbc": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		"aes-192-cbc": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		"aes-256-cbc": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
		aes128: aes128,
		aes192: aes192,
		aes256: aes256,
		"aes-128-cfb": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-192-cfb": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-256-cfb": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB",
		type: "stream"
	},
		"aes-128-cfb8": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-192-cfb8": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-256-cfb8": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB8",
		type: "stream"
	},
		"aes-128-cfb1": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-192-cfb1": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-256-cfb1": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CFB1",
		type: "stream"
	},
		"aes-128-ofb": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-192-ofb": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-256-ofb": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "OFB",
		type: "stream"
	},
		"aes-128-ctr": {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-192-ctr": {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-256-ctr": {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CTR",
		type: "stream"
	},
		"aes-128-gcm": {
		cipher: "AES",
		key: 128,
		iv: 12,
		mode: "GCM",
		type: "auth"
	},
		"aes-192-gcm": {
		cipher: "AES",
		key: 192,
		iv: 12,
		mode: "GCM",
		type: "auth"
	},
		"aes-256-gcm": {
		cipher: "AES",
		key: 256,
		iv: 12,
		mode: "GCM",
		type: "auth"
	}
	};

	var modeModules = {
	  ECB: ecb,
	  CBC: cbc,
	  CFB: cfb,
	  CFB8: cfb8,
	  CFB1: cfb1,
	  OFB: ofb,
	  CTR: ctr,
	  GCM: ctr
	};

	var modes$2 = require$$2;

	for (var key$3 in modes$2) {
	  modes$2[key$3].module = modeModules[modes$2[key$3].mode];
	}

	var modes_1 = modes$2;

	var aes$5 = {};

	// based on the aes implimentation in triple sec
	// https://github.com/keybase/triplesec
	// which is in turn based on the one from crypto-js
	// https://code.google.com/p/crypto-js/

	var Buffer$k = safeBufferExports.Buffer;

	function asUInt32Array (buf) {
	  if (!Buffer$k.isBuffer(buf)) buf = Buffer$k.from(buf);

	  var len = (buf.length / 4) | 0;
	  var out = new Array(len);

	  for (var i = 0; i < len; i++) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }

	  return out
	}

	function scrubVec (v) {
	  for (var i = 0; i < v.length; v++) {
	    v[i] = 0;
	  }
	}

	function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
	  var SUB_MIX0 = SUB_MIX[0];
	  var SUB_MIX1 = SUB_MIX[1];
	  var SUB_MIX2 = SUB_MIX[2];
	  var SUB_MIX3 = SUB_MIX[3];

	  var s0 = M[0] ^ keySchedule[0];
	  var s1 = M[1] ^ keySchedule[1];
	  var s2 = M[2] ^ keySchedule[2];
	  var s3 = M[3] ^ keySchedule[3];
	  var t0, t1, t2, t3;
	  var ksRow = 4;

	  for (var round = 1; round < nRounds; round++) {
	    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }

	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  t0 = t0 >>> 0;
	  t1 = t1 >>> 0;
	  t2 = t2 >>> 0;
	  t3 = t3 >>> 0;

	  return [t0, t1, t2, t3]
	}

	// AES constants
	var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	var G = (function () {
	  // Compute double table
	  var d = new Array(256);
	  for (var j = 0; j < 256; j++) {
	    if (j < 128) {
	      d[j] = j << 1;
	    } else {
	      d[j] = (j << 1) ^ 0x11b;
	    }
	  }

	  var SBOX = [];
	  var INV_SBOX = [];
	  var SUB_MIX = [[], [], [], []];
	  var INV_SUB_MIX = [[], [], [], []];

	  // Walk GF(2^8)
	  var x = 0;
	  var xi = 0;
	  for (var i = 0; i < 256; ++i) {
	    // Compute sbox
	    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    SBOX[x] = sx;
	    INV_SBOX[sx] = x;

	    // Compute multiplication
	    var x2 = d[x];
	    var x4 = d[x2];
	    var x8 = d[x4];

	    // Compute sub bytes, mix columns tables
	    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    SUB_MIX[3][x] = t;

	    // Compute inv sub bytes, inv mix columns tables
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    INV_SUB_MIX[3][sx] = t;

	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }

	  return {
	    SBOX: SBOX,
	    INV_SBOX: INV_SBOX,
	    SUB_MIX: SUB_MIX,
	    INV_SUB_MIX: INV_SUB_MIX
	  }
	})();

	function AES (key) {
	  this._key = asUInt32Array(key);
	  this._reset();
	}

	AES.blockSize = 4 * 4;
	AES.keySize = 256 / 8;
	AES.prototype.blockSize = AES.blockSize;
	AES.prototype.keySize = AES.keySize;
	AES.prototype._reset = function () {
	  var keyWords = this._key;
	  var keySize = keyWords.length;
	  var nRounds = keySize + 6;
	  var ksRows = (nRounds + 1) * 4;

	  var keySchedule = [];
	  for (var k = 0; k < keySize; k++) {
	    keySchedule[k] = keyWords[k];
	  }

	  for (k = keySize; k < ksRows; k++) {
	    var t = keySchedule[k - 1];

	    if (k % keySize === 0) {
	      t = (t << 8) | (t >>> 24);
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);

	      t ^= RCON[(k / keySize) | 0] << 24;
	    } else if (keySize > 6 && k % keySize === 4) {
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);
	    }

	    keySchedule[k] = keySchedule[k - keySize] ^ t;
	  }

	  var invKeySchedule = [];
	  for (var ik = 0; ik < ksRows; ik++) {
	    var ksR = ksRows - ik;
	    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

	    if (ik < 4 || ksR <= 4) {
	      invKeySchedule[ik] = tt;
	    } else {
	      invKeySchedule[ik] =
	        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
	        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
	        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
	        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
	    }
	  }

	  this._nRounds = nRounds;
	  this._keySchedule = keySchedule;
	  this._invKeySchedule = invKeySchedule;
	};

	AES.prototype.encryptBlockRaw = function (M) {
	  M = asUInt32Array(M);
	  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
	};

	AES.prototype.encryptBlock = function (M) {
	  var out = this.encryptBlockRaw(M);
	  var buf = Buffer$k.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf
	};

	AES.prototype.decryptBlock = function (M) {
	  M = asUInt32Array(M);

	  // swap
	  var m1 = M[1];
	  M[1] = M[3];
	  M[3] = m1;

	  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
	  var buf = Buffer$k.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf
	};

	AES.prototype.scrub = function () {
	  scrubVec(this._keySchedule);
	  scrubVec(this._invKeySchedule);
	  scrubVec(this._key);
	};

	aes$5.AES = AES;

	var Buffer$j = safeBufferExports.Buffer;
	var ZEROES = Buffer$j.alloc(16, 0);

	function toArray$1 (buf) {
	  return [
	    buf.readUInt32BE(0),
	    buf.readUInt32BE(4),
	    buf.readUInt32BE(8),
	    buf.readUInt32BE(12)
	  ]
	}

	function fromArray (out) {
	  var buf = Buffer$j.allocUnsafe(16);
	  buf.writeUInt32BE(out[0] >>> 0, 0);
	  buf.writeUInt32BE(out[1] >>> 0, 4);
	  buf.writeUInt32BE(out[2] >>> 0, 8);
	  buf.writeUInt32BE(out[3] >>> 0, 12);
	  return buf
	}

	function GHASH$1 (key) {
	  this.h = key;
	  this.state = Buffer$j.alloc(16, 0);
	  this.cache = Buffer$j.allocUnsafe(0);
	}

	// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
	// by Juho Vähä-Herttua
	GHASH$1.prototype.ghash = function (block) {
	  var i = -1;
	  while (++i < block.length) {
	    this.state[i] ^= block[i];
	  }
	  this._multiply();
	};

	GHASH$1.prototype._multiply = function () {
	  var Vi = toArray$1(this.h);
	  var Zi = [0, 0, 0, 0];
	  var j, xi, lsbVi;
	  var i = -1;
	  while (++i < 128) {
	    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0;
	    if (xi) {
	      // Z_i+1 = Z_i ^ V_i
	      Zi[0] ^= Vi[0];
	      Zi[1] ^= Vi[1];
	      Zi[2] ^= Vi[2];
	      Zi[3] ^= Vi[3];
	    }

	    // Store the value of LSB(V_i)
	    lsbVi = (Vi[3] & 1) !== 0;

	    // V_i+1 = V_i >> 1
	    for (j = 3; j > 0; j--) {
	      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
	    }
	    Vi[0] = Vi[0] >>> 1;

	    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
	    if (lsbVi) {
	      Vi[0] = Vi[0] ^ (0xe1 << 24);
	    }
	  }
	  this.state = fromArray(Zi);
	};

	GHASH$1.prototype.update = function (buf) {
	  this.cache = Buffer$j.concat([this.cache, buf]);
	  var chunk;
	  while (this.cache.length >= 16) {
	    chunk = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    this.ghash(chunk);
	  }
	};

	GHASH$1.prototype.final = function (abl, bl) {
	  if (this.cache.length) {
	    this.ghash(Buffer$j.concat([this.cache, ZEROES], 16));
	  }

	  this.ghash(fromArray([0, abl, 0, bl]));
	  return this.state
	};

	var ghash = GHASH$1;

	var aes$4 = aes$5;
	var Buffer$i = safeBufferExports.Buffer;
	var Transform$3 = cipherBase;
	var inherits$d = inherits_browserExports;
	var GHASH = ghash;
	var xor$3 = bufferXor;
	var incr32 = incr32_1;

	function xorTest (a, b) {
	  var out = 0;
	  if (a.length !== b.length) out++;

	  var len = Math.min(a.length, b.length);
	  for (var i = 0; i < len; ++i) {
	    out += (a[i] ^ b[i]);
	  }

	  return out
	}

	function calcIv (self, iv, ck) {
	  if (iv.length === 12) {
	    self._finID = Buffer$i.concat([iv, Buffer$i.from([0, 0, 0, 1])]);
	    return Buffer$i.concat([iv, Buffer$i.from([0, 0, 0, 2])])
	  }
	  var ghash = new GHASH(ck);
	  var len = iv.length;
	  var toPad = len % 16;
	  ghash.update(iv);
	  if (toPad) {
	    toPad = 16 - toPad;
	    ghash.update(Buffer$i.alloc(toPad, 0));
	  }
	  ghash.update(Buffer$i.alloc(8, 0));
	  var ivBits = len * 8;
	  var tail = Buffer$i.alloc(8);
	  tail.writeUIntBE(ivBits, 0, 8);
	  ghash.update(tail);
	  self._finID = ghash.state;
	  var out = Buffer$i.from(self._finID);
	  incr32(out);
	  return out
	}
	function StreamCipher$3 (mode, key, iv, decrypt) {
	  Transform$3.call(this);

	  var h = Buffer$i.alloc(4, 0);

	  this._cipher = new aes$4.AES(key);
	  var ck = this._cipher.encryptBlock(h);
	  this._ghash = new GHASH(ck);
	  iv = calcIv(this, iv, ck);

	  this._prev = Buffer$i.from(iv);
	  this._cache = Buffer$i.allocUnsafe(0);
	  this._secCache = Buffer$i.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._alen = 0;
	  this._len = 0;
	  this._mode = mode;

	  this._authTag = null;
	  this._called = false;
	}

	inherits$d(StreamCipher$3, Transform$3);

	StreamCipher$3.prototype._update = function (chunk) {
	  if (!this._called && this._alen) {
	    var rump = 16 - (this._alen % 16);
	    if (rump < 16) {
	      rump = Buffer$i.alloc(rump, 0);
	      this._ghash.update(rump);
	    }
	  }

	  this._called = true;
	  var out = this._mode.encrypt(this, chunk);
	  if (this._decrypt) {
	    this._ghash.update(chunk);
	  } else {
	    this._ghash.update(out);
	  }
	  this._len += chunk.length;
	  return out
	};

	StreamCipher$3.prototype._final = function () {
	  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

	  var tag = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
	  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

	  this._authTag = tag;
	  this._cipher.scrub();
	};

	StreamCipher$3.prototype.getAuthTag = function getAuthTag () {
	  if (this._decrypt || !Buffer$i.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

	  return this._authTag
	};

	StreamCipher$3.prototype.setAuthTag = function setAuthTag (tag) {
	  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

	  this._authTag = tag;
	};

	StreamCipher$3.prototype.setAAD = function setAAD (buf) {
	  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

	  this._ghash.update(buf);
	  this._alen += buf.length;
	};

	var authCipher = StreamCipher$3;

	var aes$3 = aes$5;
	var Buffer$h = safeBufferExports.Buffer;
	var Transform$2 = cipherBase;
	var inherits$c = inherits_browserExports;

	function StreamCipher$2 (mode, key, iv, decrypt) {
	  Transform$2.call(this);

	  this._cipher = new aes$3.AES(key);
	  this._prev = Buffer$h.from(iv);
	  this._cache = Buffer$h.allocUnsafe(0);
	  this._secCache = Buffer$h.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._mode = mode;
	}

	inherits$c(StreamCipher$2, Transform$2);

	StreamCipher$2.prototype._update = function (chunk) {
	  return this._mode.encrypt(this, chunk, this._decrypt)
	};

	StreamCipher$2.prototype._final = function () {
	  this._cipher.scrub();
	};

	var streamCipher = StreamCipher$2;

	var Buffer$g = safeBufferExports.Buffer;
	var MD5 = md5_js;

	/* eslint-disable camelcase */
	function EVP_BytesToKey (password, salt, keyBits, ivLen) {
	  if (!Buffer$g.isBuffer(password)) password = Buffer$g.from(password, 'binary');
	  if (salt) {
	    if (!Buffer$g.isBuffer(salt)) salt = Buffer$g.from(salt, 'binary');
	    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
	  }

	  var keyLen = keyBits / 8;
	  var key = Buffer$g.alloc(keyLen);
	  var iv = Buffer$g.alloc(ivLen || 0);
	  var tmp = Buffer$g.alloc(0);

	  while (keyLen > 0 || ivLen > 0) {
	    var hash = new MD5();
	    hash.update(tmp);
	    hash.update(password);
	    if (salt) hash.update(salt);
	    tmp = hash.digest();

	    var used = 0;

	    if (keyLen > 0) {
	      var keyStart = key.length - keyLen;
	      used = Math.min(keyLen, tmp.length);
	      tmp.copy(key, keyStart, 0, used);
	      keyLen -= used;
	    }

	    if (used < tmp.length && ivLen > 0) {
	      var ivStart = iv.length - ivLen;
	      var length = Math.min(ivLen, tmp.length - used);
	      tmp.copy(iv, ivStart, used, used + length);
	      ivLen -= length;
	    }
	  }

	  tmp.fill(0);
	  return { key: key, iv: iv }
	}

	var evp_bytestokey = EVP_BytesToKey;

	var MODES$1 = modes_1;
	var AuthCipher$1 = authCipher;
	var Buffer$f = safeBufferExports.Buffer;
	var StreamCipher$1 = streamCipher;
	var Transform$1 = cipherBase;
	var aes$2 = aes$5;
	var ebtk$2 = evp_bytestokey;
	var inherits$b = inherits_browserExports;

	function Cipher (mode, key, iv) {
	  Transform$1.call(this);

	  this._cache = new Splitter$1();
	  this._cipher = new aes$2.AES(key);
	  this._prev = Buffer$f.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits$b(Cipher, Transform$1);

	Cipher.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];

	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    out.push(thing);
	  }

	  return Buffer$f.concat(out)
	};

	var PADDING = Buffer$f.alloc(16, 0x10);

	Cipher.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    chunk = this._mode.encrypt(this, chunk);
	    this._cipher.scrub();
	    return chunk
	  }

	  if (!chunk.equals(PADDING)) {
	    this._cipher.scrub();
	    throw new Error('data not multiple of block length')
	  }
	};

	Cipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter$1 () {
	  this.cache = Buffer$f.allocUnsafe(0);
	}

	Splitter$1.prototype.add = function (data) {
	  this.cache = Buffer$f.concat([this.cache, data]);
	};

	Splitter$1.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out
	  }
	  return null
	};

	Splitter$1.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = Buffer$f.allocUnsafe(len);

	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }

	  return Buffer$f.concat([this.cache, padBuff])
	};

	function createCipheriv$1 (suite, password, iv) {
	  var config = MODES$1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof password === 'string') password = Buffer$f.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (typeof iv === 'string') iv = Buffer$f.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (config.type === 'stream') {
	    return new StreamCipher$1(config.module, password, iv)
	  } else if (config.type === 'auth') {
	    return new AuthCipher$1(config.module, password, iv)
	  }

	  return new Cipher(config.module, password, iv)
	}

	function createCipher$1 (suite, password) {
	  var config = MODES$1[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = ebtk$2(password, false, config.key, config.iv);
	  return createCipheriv$1(suite, keys.key, keys.iv)
	}

	encrypter.createCipheriv = createCipheriv$1;
	encrypter.createCipher = createCipher$1;

	var decrypter = {};

	var AuthCipher = authCipher;
	var Buffer$e = safeBufferExports.Buffer;
	var MODES = modes_1;
	var StreamCipher = streamCipher;
	var Transform = cipherBase;
	var aes$1 = aes$5;
	var ebtk$1 = evp_bytestokey;
	var inherits$a = inherits_browserExports;

	function Decipher (mode, key, iv) {
	  Transform.call(this);

	  this._cache = new Splitter();
	  this._last = void 0;
	  this._cipher = new aes$1.AES(key);
	  this._prev = Buffer$e.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits$a(Decipher, Transform);

	Decipher.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];
	  while ((chunk = this._cache.get(this._autopadding))) {
	    thing = this._mode.decrypt(this, chunk);
	    out.push(thing);
	  }
	  return Buffer$e.concat(out)
	};

	Decipher.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    return unpad(this._mode.decrypt(this, chunk))
	  } else if (chunk) {
	    throw new Error('data not multiple of block length')
	  }
	};

	Decipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter () {
	  this.cache = Buffer$e.allocUnsafe(0);
	}

	Splitter.prototype.add = function (data) {
	  this.cache = Buffer$e.concat([this.cache, data]);
	};

	Splitter.prototype.get = function (autoPadding) {
	  var out;
	  if (autoPadding) {
	    if (this.cache.length > 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  } else {
	    if (this.cache.length >= 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  }

	  return null
	};

	Splitter.prototype.flush = function () {
	  if (this.cache.length) return this.cache
	};

	function unpad (last) {
	  var padded = last[15];
	  if (padded < 1 || padded > 16) {
	    throw new Error('unable to decrypt data')
	  }
	  var i = -1;
	  while (++i < padded) {
	    if (last[(i + (16 - padded))] !== padded) {
	      throw new Error('unable to decrypt data')
	    }
	  }
	  if (padded === 16) return

	  return last.slice(0, 16 - padded)
	}

	function createDecipheriv$1 (suite, password, iv) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof iv === 'string') iv = Buffer$e.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (typeof password === 'string') password = Buffer$e.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (config.type === 'stream') {
	    return new StreamCipher(config.module, password, iv, true)
	  } else if (config.type === 'auth') {
	    return new AuthCipher(config.module, password, iv, true)
	  }

	  return new Decipher(config.module, password, iv)
	}

	function createDecipher$1 (suite, password) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = ebtk$1(password, false, config.key, config.iv);
	  return createDecipheriv$1(suite, keys.key, keys.iv)
	}

	decrypter.createDecipher = createDecipher$1;
	decrypter.createDecipheriv = createDecipheriv$1;

	var ciphers$2 = encrypter;
	var deciphers = decrypter;
	var modes$1 = require$$2;

	function getCiphers$1 () {
	  return Object.keys(modes$1)
	}

	browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
	browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
	browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
	browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
	browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;

	var modes = {};

	(function (exports) {
		exports['des-ecb'] = {
		  key: 8,
		  iv: 0
		};
		exports['des-cbc'] = exports.des = {
		  key: 8,
		  iv: 8
		};
		exports['des-ede3-cbc'] = exports.des3 = {
		  key: 24,
		  iv: 8
		};
		exports['des-ede3'] = {
		  key: 24,
		  iv: 0
		};
		exports['des-ede-cbc'] = {
		  key: 16,
		  iv: 8
		};
		exports['des-ede'] = {
		  key: 16,
		  iv: 0
		}; 
	} (modes));

	var DES = browserifyDes;
	var aes = browser$5;
	var aesModes = modes_1;
	var desModes = modes;
	var ebtk = evp_bytestokey;

	function createCipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key;
	    ivLen = aesModes[suite].iv;
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8;
	    ivLen = desModes[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = ebtk(password, false, keyLen, ivLen);
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	function createDecipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key;
	    ivLen = aesModes[suite].iv;
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8;
	    ivLen = desModes[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = ebtk(password, false, keyLen, ivLen);
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	function createCipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
	  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

	  throw new TypeError('invalid suite type')
	}

	function createDecipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
	  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

	  throw new TypeError('invalid suite type')
	}

	function getCiphers () {
	  return Object.keys(desModes).concat(aes.getCiphers())
	}

	browser$6.createCipher = browser$6.Cipher = createCipher;
	browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
	browser$6.createDecipher = browser$6.Decipher = createDecipher;
	browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
	browser$6.listCiphers = browser$6.getCiphers = getCiphers;

	var browser$4 = {};

	var brorand = {exports: {}};

	var hasRequiredBrorand;

	function requireBrorand () {
		if (hasRequiredBrorand) return brorand.exports;
		hasRequiredBrorand = 1;
		var r;

		brorand.exports = function rand(len) {
		  if (!r)
		    r = new Rand(null);

		  return r.generate(len);
		};

		function Rand(rand) {
		  this.rand = rand;
		}
		brorand.exports.Rand = Rand;

		Rand.prototype.generate = function generate(len) {
		  return this._rand(len);
		};

		// Emulate crypto API using randy
		Rand.prototype._rand = function _rand(n) {
		  if (this.rand.getBytes)
		    return this.rand.getBytes(n);

		  var res = new Uint8Array(n);
		  for (var i = 0; i < res.length; i++)
		    res[i] = this.rand.getByte();
		  return res;
		};

		if (typeof self === 'object') {
		  if (self.crypto && self.crypto.getRandomValues) {
		    // Modern browsers
		    Rand.prototype._rand = function _rand(n) {
		      var arr = new Uint8Array(n);
		      self.crypto.getRandomValues(arr);
		      return arr;
		    };
		  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
		    // IE
		    Rand.prototype._rand = function _rand(n) {
		      var arr = new Uint8Array(n);
		      self.msCrypto.getRandomValues(arr);
		      return arr;
		    };

		  // Safari's WebWorkers do not have `crypto`
		  } else if (typeof window === 'object') {
		    // Old junk
		    Rand.prototype._rand = function() {
		      throw new Error('Not implemented yet');
		    };
		  }
		} else {
		  // Node.js or Web worker with no crypto support
		  try {
		    var crypto = requireCryptoBrowserify();
		    if (typeof crypto.randomBytes !== 'function')
		      throw new Error('Not supported');

		    Rand.prototype._rand = function _rand(n) {
		      return crypto.randomBytes(n);
		    };
		  } catch (e) {
		  }
		}
		return brorand.exports;
	}

	var mr;
	var hasRequiredMr;

	function requireMr () {
		if (hasRequiredMr) return mr;
		hasRequiredMr = 1;
		var bn = bnExports$2;
		var brorand = requireBrorand();

		function MillerRabin(rand) {
		  this.rand = rand || new brorand.Rand();
		}
		mr = MillerRabin;

		MillerRabin.create = function create(rand) {
		  return new MillerRabin(rand);
		};

		MillerRabin.prototype._randbelow = function _randbelow(n) {
		  var len = n.bitLength();
		  var min_bytes = Math.ceil(len / 8);

		  // Generage random bytes until a number less than n is found.
		  // This ensures that 0..n-1 have an equal probability of being selected.
		  do
		    var a = new bn(this.rand.generate(min_bytes));
		  while (a.cmp(n) >= 0);

		  return a;
		};

		MillerRabin.prototype._randrange = function _randrange(start, stop) {
		  // Generate a random number greater than or equal to start and less than stop.
		  var size = stop.sub(start);
		  return start.add(this._randbelow(size));
		};

		MillerRabin.prototype.test = function test(n, k, cb) {
		  var len = n.bitLength();
		  var red = bn.mont(n);
		  var rone = new bn(1).toRed(red);

		  if (!k)
		    k = Math.max(1, (len / 48) | 0);

		  // Find d and s, (n - 1) = (2 ^ s) * d;
		  var n1 = n.subn(1);
		  for (var s = 0; !n1.testn(s); s++) {}
		  var d = n.shrn(s);

		  var rn1 = n1.toRed(red);

		  var prime = true;
		  for (; k > 0; k--) {
		    var a = this._randrange(new bn(2), n1);
		    if (cb)
		      cb(a);

		    var x = a.toRed(red).redPow(d);
		    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
		      continue;

		    for (var i = 1; i < s; i++) {
		      x = x.redSqr();

		      if (x.cmp(rone) === 0)
		        return false;
		      if (x.cmp(rn1) === 0)
		        break;
		    }

		    if (i === s)
		      return false;
		  }

		  return prime;
		};

		MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
		  var len = n.bitLength();
		  var red = bn.mont(n);
		  var rone = new bn(1).toRed(red);

		  if (!k)
		    k = Math.max(1, (len / 48) | 0);

		  // Find d and s, (n - 1) = (2 ^ s) * d;
		  var n1 = n.subn(1);
		  for (var s = 0; !n1.testn(s); s++) {}
		  var d = n.shrn(s);

		  var rn1 = n1.toRed(red);

		  for (; k > 0; k--) {
		    var a = this._randrange(new bn(2), n1);

		    var g = n.gcd(a);
		    if (g.cmpn(1) !== 0)
		      return g;

		    var x = a.toRed(red).redPow(d);
		    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
		      continue;

		    for (var i = 1; i < s; i++) {
		      x = x.redSqr();

		      if (x.cmp(rone) === 0)
		        return x.fromRed().subn(1).gcd(n);
		      if (x.cmp(rn1) === 0)
		        break;
		    }

		    if (i === s) {
		      x = x.redSqr();
		      return x.fromRed().subn(1).gcd(n);
		    }
		  }

		  return false;
		};
		return mr;
	}

	var generatePrime;
	var hasRequiredGeneratePrime;

	function requireGeneratePrime () {
		if (hasRequiredGeneratePrime) return generatePrime;
		hasRequiredGeneratePrime = 1;
		var randomBytes = browserExports;
		generatePrime = findPrime;
		findPrime.simpleSieve = simpleSieve;
		findPrime.fermatTest = fermatTest;
		var BN = bnExports$2;
		var TWENTYFOUR = new BN(24);
		var MillerRabin = requireMr();
		var millerRabin = new MillerRabin();
		var ONE = new BN(1);
		var TWO = new BN(2);
		var FIVE = new BN(5);
		new BN(16);
		new BN(8);
		var TEN = new BN(10);
		var THREE = new BN(3);
		new BN(7);
		var ELEVEN = new BN(11);
		var FOUR = new BN(4);
		new BN(12);
		var primes = null;

		function _getPrimes() {
		  if (primes !== null)
		    return primes;

		  var limit = 0x100000;
		  var res = [];
		  res[0] = 2;
		  for (var i = 1, k = 3; k < limit; k += 2) {
		    var sqrt = Math.ceil(Math.sqrt(k));
		    for (var j = 0; j < i && res[j] <= sqrt; j++)
		      if (k % res[j] === 0)
		        break;

		    if (i !== j && res[j] <= sqrt)
		      continue;

		    res[i++] = k;
		  }
		  primes = res;
		  return res;
		}

		function simpleSieve(p) {
		  var primes = _getPrimes();

		  for (var i = 0; i < primes.length; i++)
		    if (p.modn(primes[i]) === 0) {
		      if (p.cmpn(primes[i]) === 0) {
		        return true;
		      } else {
		        return false;
		      }
		    }

		  return true;
		}

		function fermatTest(p) {
		  var red = BN.mont(p);
		  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
		}

		function findPrime(bits, gen) {
		  if (bits < 16) {
		    // this is what openssl does
		    if (gen === 2 || gen === 5) {
		      return new BN([0x8c, 0x7b]);
		    } else {
		      return new BN([0x8c, 0x27]);
		    }
		  }
		  gen = new BN(gen);

		  var num, n2;

		  while (true) {
		    num = new BN(randomBytes(Math.ceil(bits / 8)));
		    while (num.bitLength() > bits) {
		      num.ishrn(1);
		    }
		    if (num.isEven()) {
		      num.iadd(ONE);
		    }
		    if (!num.testn(1)) {
		      num.iadd(TWO);
		    }
		    if (!gen.cmp(TWO)) {
		      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
		        num.iadd(FOUR);
		      }
		    } else if (!gen.cmp(FIVE)) {
		      while (num.mod(TEN).cmp(THREE)) {
		        num.iadd(FOUR);
		      }
		    }
		    n2 = num.shrn(1);
		    if (simpleSieve(n2) && simpleSieve(num) &&
		      fermatTest(n2) && fermatTest(num) &&
		      millerRabin.test(n2) && millerRabin.test(num)) {
		      return num;
		    }
		  }

		}
		return generatePrime;
	}

	var modp1 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
	};
	var modp2 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
	};
	var modp5 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
	};
	var modp14 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
	};
	var modp15 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
	};
	var modp16 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
	};
	var modp17 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
	};
	var modp18 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
	};
	var require$$1$1 = {
		modp1: modp1,
		modp2: modp2,
		modp5: modp5,
		modp14: modp14,
		modp15: modp15,
		modp16: modp16,
		modp17: modp17,
		modp18: modp18
	};

	var dh;
	var hasRequiredDh;

	function requireDh () {
		if (hasRequiredDh) return dh;
		hasRequiredDh = 1;
		var BN = bnExports$2;
		var MillerRabin = requireMr();
		var millerRabin = new MillerRabin();
		var TWENTYFOUR = new BN(24);
		var ELEVEN = new BN(11);
		var TEN = new BN(10);
		var THREE = new BN(3);
		var SEVEN = new BN(7);
		var primes = requireGeneratePrime();
		var randomBytes = browserExports;
		dh = DH;

		function setPublicKey(pub, enc) {
		  enc = enc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(pub)) {
		    pub = new require$$0$3.Buffer(pub, enc);
		  }
		  this._pub = new BN(pub);
		  return this;
		}

		function setPrivateKey(priv, enc) {
		  enc = enc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(priv)) {
		    priv = new require$$0$3.Buffer(priv, enc);
		  }
		  this._priv = new BN(priv);
		  return this;
		}

		var primeCache = {};
		function checkPrime(prime, generator) {
		  var gen = generator.toString('hex');
		  var hex = [gen, prime.toString(16)].join('_');
		  if (hex in primeCache) {
		    return primeCache[hex];
		  }
		  var error = 0;

		  if (prime.isEven() ||
		    !primes.simpleSieve ||
		    !primes.fermatTest(prime) ||
		    !millerRabin.test(prime)) {
		    //not a prime so +1
		    error += 1;

		    if (gen === '02' || gen === '05') {
		      // we'd be able to check the generator
		      // it would fail so +8
		      error += 8;
		    } else {
		      //we wouldn't be able to test the generator
		      // so +4
		      error += 4;
		    }
		    primeCache[hex] = error;
		    return error;
		  }
		  if (!millerRabin.test(prime.shrn(1))) {
		    //not a safe prime
		    error += 2;
		  }
		  var rem;
		  switch (gen) {
		    case '02':
		      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
		        // unsuidable generator
		        error += 8;
		      }
		      break;
		    case '05':
		      rem = prime.mod(TEN);
		      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
		        // prime mod 10 needs to equal 3 or 7
		        error += 8;
		      }
		      break;
		    default:
		      error += 4;
		  }
		  primeCache[hex] = error;
		  return error;
		}

		function DH(prime, generator, malleable) {
		  this.setGenerator(generator);
		  this.__prime = new BN(prime);
		  this._prime = BN.mont(this.__prime);
		  this._primeLen = prime.length;
		  this._pub = undefined;
		  this._priv = undefined;
		  this._primeCode = undefined;
		  if (malleable) {
		    this.setPublicKey = setPublicKey;
		    this.setPrivateKey = setPrivateKey;
		  } else {
		    this._primeCode = 8;
		  }
		}
		Object.defineProperty(DH.prototype, 'verifyError', {
		  enumerable: true,
		  get: function () {
		    if (typeof this._primeCode !== 'number') {
		      this._primeCode = checkPrime(this.__prime, this.__gen);
		    }
		    return this._primeCode;
		  }
		});
		DH.prototype.generateKeys = function () {
		  if (!this._priv) {
		    this._priv = new BN(randomBytes(this._primeLen));
		  }
		  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
		  return this.getPublicKey();
		};

		DH.prototype.computeSecret = function (other) {
		  other = new BN(other);
		  other = other.toRed(this._prime);
		  var secret = other.redPow(this._priv).fromRed();
		  var out = new require$$0$3.Buffer(secret.toArray());
		  var prime = this.getPrime();
		  if (out.length < prime.length) {
		    var front = new require$$0$3.Buffer(prime.length - out.length);
		    front.fill(0);
		    out = require$$0$3.Buffer.concat([front, out]);
		  }
		  return out;
		};

		DH.prototype.getPublicKey = function getPublicKey(enc) {
		  return formatReturnValue(this._pub, enc);
		};

		DH.prototype.getPrivateKey = function getPrivateKey(enc) {
		  return formatReturnValue(this._priv, enc);
		};

		DH.prototype.getPrime = function (enc) {
		  return formatReturnValue(this.__prime, enc);
		};

		DH.prototype.getGenerator = function (enc) {
		  return formatReturnValue(this._gen, enc);
		};

		DH.prototype.setGenerator = function (gen, enc) {
		  enc = enc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(gen)) {
		    gen = new require$$0$3.Buffer(gen, enc);
		  }
		  this.__gen = gen;
		  this._gen = new BN(gen);
		  return this;
		};

		function formatReturnValue(bn, enc) {
		  var buf = new require$$0$3.Buffer(bn.toArray());
		  if (!enc) {
		    return buf;
		  } else {
		    return buf.toString(enc);
		  }
		}
		return dh;
	}

	var hasRequiredBrowser$2;

	function requireBrowser$2 () {
		if (hasRequiredBrowser$2) return browser$4;
		hasRequiredBrowser$2 = 1;
		var generatePrime = requireGeneratePrime();
		var primes = require$$1$1;

		var DH = requireDh();

		function getDiffieHellman (mod) {
		  var prime = new require$$0$3.Buffer(primes[mod].prime, 'hex');
		  var gen = new require$$0$3.Buffer(primes[mod].gen, 'hex');

		  return new DH(prime, gen)
		}

		var ENCODINGS = {
		  'binary': true, 'hex': true, 'base64': true
		};

		function createDiffieHellman (prime, enc, generator, genc) {
		  if (require$$0$3.Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
		    return createDiffieHellman(prime, 'binary', enc, generator)
		  }

		  enc = enc || 'binary';
		  genc = genc || 'binary';
		  generator = generator || new require$$0$3.Buffer([2]);

		  if (!require$$0$3.Buffer.isBuffer(generator)) {
		    generator = new require$$0$3.Buffer(generator, genc);
		  }

		  if (typeof prime === 'number') {
		    return new DH(generatePrime(prime, generator), generator, true)
		  }

		  if (!require$$0$3.Buffer.isBuffer(prime)) {
		    prime = new require$$0$3.Buffer(prime, enc);
		  }

		  return new DH(prime, generator, true)
		}

		browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = getDiffieHellman;
		browser$4.createDiffieHellman = browser$4.DiffieHellman = createDiffieHellman;
		return browser$4;
	}

	var sign$2 = {exports: {}};

	var bn$1 = {exports: {}};

	bn$1.exports;

	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = require$$0$2.Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [number & 0x3ffffff];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [0];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this._strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // '0' - '9'
		    if (c >= 48 && c <= 57) {
		      return c - 48;
		    // 'A' - 'F'
		    } else if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    } else {
		      assert(false, 'Invalid character in ' + string);
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this._strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var b = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        b = c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        b = c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        b = c;
		      }
		      assert(c >= 0 && b < mul, 'Invalid character');
		      r += b;
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [0];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this._strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  function move (dest, src) {
		    dest.words = src.words;
		    dest.length = src.length;
		    dest.negative = src.negative;
		    dest.red = src.red;
		  }

		  BN.prototype._move = function _move (dest) {
		    move(dest, this);
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype._strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  // Check Symbol.for because not everywhere where Symbol defined
		  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
		  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
		    try {
		      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
		    } catch (e) {
		      BN.prototype.inspect = inspect;
		    }
		  } else {
		    BN.prototype.inspect = inspect;
		  }

		  function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  }

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modrn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16, 2);
		  };

		  if (Buffer) {
		    BN.prototype.toBuffer = function toBuffer (endian, length) {
		      return this.toArrayLike(Buffer, endian, length);
		    };
		  }

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  var allocate = function allocate (ArrayType, size) {
		    if (ArrayType.allocUnsafe) {
		      return ArrayType.allocUnsafe(size);
		    }
		    return new ArrayType(size);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    this._strip();

		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    var res = allocate(ArrayType, reqLength);
		    var postfix = endian === 'le' ? 'LE' : 'BE';
		    this['_toArrayLike' + postfix](res, byteLength);
		    return res;
		  };

		  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
		    var position = 0;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position++] = word & 0xff;
		      if (position < res.length) {
		        res[position++] = (word >> 8) & 0xff;
		      }
		      if (position < res.length) {
		        res[position++] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position < res.length) {
		          res[position++] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position < res.length) {
		      res[position++] = carry;

		      while (position < res.length) {
		        res[position++] = 0;
		      }
		    }
		  };

		  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
		    var position = res.length - 1;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position--] = word & 0xff;
		      if (position >= 0) {
		        res[position--] = (word >> 8) & 0xff;
		      }
		      if (position >= 0) {
		        res[position--] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position >= 0) {
		          res[position--] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position >= 0) {
		      res[position--] = carry;

		      while (position >= 0) {
		        res[position--] = 0;
		      }
		    }
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] >>> wbit) & 0x01;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this._strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this._strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this._strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this._strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this._strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this._strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  function jumboMulTo (self, num, out) {
		    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
		    // var fftm = new FFTM();
		    // return fftm.mulp(self, num, out);
		    return bigMulTo(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this._strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) <= num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this._strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this._strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this._strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q._strip();
		    }
		    a._strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modrn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modrn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modrn = function modrn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return isNegNum ? -acc : acc;
		  };

		  // WARNING: DEPRECATED
		  BN.prototype.modn = function modn (num) {
		    return this.modrn(num);
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    this._strip();
		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this._strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is a BN v4 instance
		        r.strip();
		      } else {
		        // r is a BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

		    move(a, a.umod(this.m)._forceRed(this));
		    return a;
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, commonjsGlobal); 
	} (bn$1));

	var bnExports$1 = bn$1.exports;

	var BN$b = bnExports$1;
	var randomBytes$2 = browserExports;

	function blind (priv) {
	  var r = getr(priv);
	  var blinder = r.toRed(BN$b.mont(priv.modulus)).redPow(new BN$b(priv.publicExponent)).fromRed();
	  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
	}

	function getr (priv) {
	  var len = priv.modulus.byteLength();
	  var r;
	  do {
	    r = new BN$b(randomBytes$2(len));
	  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
	  return r
	}

	function crt$2 (msg, priv) {
	  var blinds = blind(priv);
	  var len = priv.modulus.byteLength();
	  var blinded = new BN$b(msg).mul(blinds.blinder).umod(priv.modulus);
	  var c1 = blinded.toRed(BN$b.mont(priv.prime1));
	  var c2 = blinded.toRed(BN$b.mont(priv.prime2));
	  var qinv = priv.coefficient;
	  var p = priv.prime1;
	  var q = priv.prime2;
	  var m1 = c1.redPow(priv.exponent1).fromRed();
	  var m2 = c2.redPow(priv.exponent2).fromRed();
	  var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
	  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(require$$0$3.Buffer, 'be', len)
	}
	crt$2.getr = getr;

	var browserifyRsa = crt$2;

	var elliptic$2 = {};

	var name = "elliptic";
	var version = "6.5.4";
	var description = "EC cryptography";
	var main = "lib/elliptic.js";
	var files = [
		"lib"
	];
	var scripts = {
		lint: "eslint lib test",
		"lint:fix": "npm run lint -- --fix",
		unit: "istanbul test _mocha --reporter=spec test/index.js",
		test: "npm run lint && npm run unit",
		version: "grunt dist && git add dist/"
	};
	var repository = {
		type: "git",
		url: "git@github.com:indutny/elliptic"
	};
	var keywords = [
		"EC",
		"Elliptic",
		"curve",
		"Cryptography"
	];
	var author = "Fedor Indutny <fedor@indutny.com>";
	var license = "MIT";
	var bugs = {
		url: "https://github.com/indutny/elliptic/issues"
	};
	var homepage = "https://github.com/indutny/elliptic";
	var devDependencies = {
		brfs: "^2.0.2",
		coveralls: "^3.1.0",
		eslint: "^7.6.0",
		grunt: "^1.2.1",
		"grunt-browserify": "^5.3.0",
		"grunt-cli": "^1.3.2",
		"grunt-contrib-connect": "^3.0.0",
		"grunt-contrib-copy": "^1.0.0",
		"grunt-contrib-uglify": "^5.0.0",
		"grunt-mocha-istanbul": "^5.0.2",
		"grunt-saucelabs": "^9.0.1",
		istanbul: "^0.4.5",
		mocha: "^8.0.1"
	};
	var dependencies = {
		"bn.js": "^4.11.9",
		brorand: "^1.1.0",
		"hash.js": "^1.0.0",
		"hmac-drbg": "^1.0.1",
		inherits: "^2.0.4",
		"minimalistic-assert": "^1.0.1",
		"minimalistic-crypto-utils": "^1.0.1"
	};
	var require$$0 = {
		name: name,
		version: version,
		description: description,
		main: main,
		files: files,
		scripts: scripts,
		repository: repository,
		keywords: keywords,
		author: author,
		license: license,
		bugs: bugs,
		homepage: homepage,
		devDependencies: devDependencies,
		dependencies: dependencies
	};

	var utils$l = {};

	var utils$k = {};

	(function (exports) {

		var utils = exports;

		function toArray(msg, enc) {
		  if (Array.isArray(msg))
		    return msg.slice();
		  if (!msg)
		    return [];
		  var res = [];
		  if (typeof msg !== 'string') {
		    for (var i = 0; i < msg.length; i++)
		      res[i] = msg[i] | 0;
		    return res;
		  }
		  if (enc === 'hex') {
		    msg = msg.replace(/[^a-z0-9]+/ig, '');
		    if (msg.length % 2 !== 0)
		      msg = '0' + msg;
		    for (var i = 0; i < msg.length; i += 2)
		      res.push(parseInt(msg[i] + msg[i + 1], 16));
		  } else {
		    for (var i = 0; i < msg.length; i++) {
		      var c = msg.charCodeAt(i);
		      var hi = c >> 8;
		      var lo = c & 0xff;
		      if (hi)
		        res.push(hi, lo);
		      else
		        res.push(lo);
		    }
		  }
		  return res;
		}
		utils.toArray = toArray;

		function zero2(word) {
		  if (word.length === 1)
		    return '0' + word;
		  else
		    return word;
		}
		utils.zero2 = zero2;

		function toHex(msg) {
		  var res = '';
		  for (var i = 0; i < msg.length; i++)
		    res += zero2(msg[i].toString(16));
		  return res;
		}
		utils.toHex = toHex;

		utils.encode = function encode(arr, enc) {
		  if (enc === 'hex')
		    return toHex(arr);
		  else
		    return arr;
		}; 
	} (utils$k));

	(function (exports) {

		var utils = exports;
		var BN = bnExports$2;
		var minAssert = minimalisticAssert;
		var minUtils = utils$k;

		utils.assert = minAssert;
		utils.toArray = minUtils.toArray;
		utils.zero2 = minUtils.zero2;
		utils.toHex = minUtils.toHex;
		utils.encode = minUtils.encode;

		// Represent num in a w-NAF form
		function getNAF(num, w, bits) {
		  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
		  naf.fill(0);

		  var ws = 1 << (w + 1);
		  var k = num.clone();

		  for (var i = 0; i < naf.length; i++) {
		    var z;
		    var mod = k.andln(ws - 1);
		    if (k.isOdd()) {
		      if (mod > (ws >> 1) - 1)
		        z = (ws >> 1) - mod;
		      else
		        z = mod;
		      k.isubn(z);
		    } else {
		      z = 0;
		    }

		    naf[i] = z;
		    k.iushrn(1);
		  }

		  return naf;
		}
		utils.getNAF = getNAF;

		// Represent k1, k2 in a Joint Sparse Form
		function getJSF(k1, k2) {
		  var jsf = [
		    [],
		    [],
		  ];

		  k1 = k1.clone();
		  k2 = k2.clone();
		  var d1 = 0;
		  var d2 = 0;
		  var m8;
		  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
		    // First phase
		    var m14 = (k1.andln(3) + d1) & 3;
		    var m24 = (k2.andln(3) + d2) & 3;
		    if (m14 === 3)
		      m14 = -1;
		    if (m24 === 3)
		      m24 = -1;
		    var u1;
		    if ((m14 & 1) === 0) {
		      u1 = 0;
		    } else {
		      m8 = (k1.andln(7) + d1) & 7;
		      if ((m8 === 3 || m8 === 5) && m24 === 2)
		        u1 = -m14;
		      else
		        u1 = m14;
		    }
		    jsf[0].push(u1);

		    var u2;
		    if ((m24 & 1) === 0) {
		      u2 = 0;
		    } else {
		      m8 = (k2.andln(7) + d2) & 7;
		      if ((m8 === 3 || m8 === 5) && m14 === 2)
		        u2 = -m24;
		      else
		        u2 = m24;
		    }
		    jsf[1].push(u2);

		    // Second phase
		    if (2 * d1 === u1 + 1)
		      d1 = 1 - d1;
		    if (2 * d2 === u2 + 1)
		      d2 = 1 - d2;
		    k1.iushrn(1);
		    k2.iushrn(1);
		  }

		  return jsf;
		}
		utils.getJSF = getJSF;

		function cachedProperty(obj, name, computer) {
		  var key = '_' + name;
		  obj.prototype[name] = function cachedProperty() {
		    return this[key] !== undefined ? this[key] :
		      this[key] = computer.call(this);
		  };
		}
		utils.cachedProperty = cachedProperty;

		function parseBytes(bytes) {
		  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
		    bytes;
		}
		utils.parseBytes = parseBytes;

		function intFromLE(bytes) {
		  return new BN(bytes, 'hex', 'le');
		}
		utils.intFromLE = intFromLE; 
	} (utils$l));

	var curve = {};

	var BN$a = bnExports$2;
	var utils$j = utils$l;
	var getNAF = utils$j.getNAF;
	var getJSF = utils$j.getJSF;
	var assert$f = utils$j.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new BN$a(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? BN$a.red(conf.prime) : BN$a.mont(this.p);

	  // Useful for many curves
	  this.zero = new BN$a(0).toRed(this.red);
	  this.one = new BN$a(1).toRed(this.red);
	  this.two = new BN$a(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new BN$a(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  this._bitLength = this.n ? this.n.bitLength() : 0;

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	var base$1 = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert$f(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1, this._bitLength);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  var j;
	  var nafW;
	  for (j = 0; j < naf.length; j += doubles.step) {
	    nafW = 0;
	    for (var l = j + doubles.step - 1; l >= j; l--)
	      nafW = (nafW << 1) + naf[l];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (j = 0; j < repr.length; j++) {
	      nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w, this._bitLength);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var l = 0; i >= 0 && naf[i] === 0; i--)
	      l++;
	    if (i >= 0)
	      l++;
	    acc = acc.dblp(l);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert$f(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	  points,
	  coeffs,
	  len,
	  jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  var i;
	  var j;
	  var p;
	  for (i = 0; i < len; i++) {
	    p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
	      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b], /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3,  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (j = 0; j < len; j++) {
	      var z = tmp[j];
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils$j.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert$f(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert$f(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	      bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils$j.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null,
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles,
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res,
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};

	var utils$i = utils$l;
	var BN$9 = bnExports$2;
	var inherits$9 = inherits_browserExports;
	var Base$2 = base$1;

	var assert$e = utils$i.assert;

	function ShortCurve(conf) {
	  Base$2.call(this, 'short', conf);

	  this.a = new BN$9(conf.a, 16).toRed(this.red);
	  this.b = new BN$9(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits$9(ShortCurve, Base$2);
	var short = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new BN$9(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new BN$9(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert$e(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new BN$9(vec.a, 16),
	        b: new BN$9(vec.b, 16),
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis,
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : BN$9.mont(num);
	  var tinv = new BN$9(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new BN$9(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new BN$9(1);
	  var y1 = new BN$9(0);
	  var x2 = new BN$9(0);
	  var y2 = new BN$9(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 },
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN$9(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	      var npoints = this._endoWnafT1;
	      var ncoeffs = this._endoWnafT2;
	      for (var i = 0; i < points.length; i++) {
	        var split = this._endoSplit(coeffs[i]);
	        var p = points[i];
	        var beta = p._getBeta();

	        if (split.k1.negative) {
	          split.k1.ineg();
	          p = p.neg(true);
	        }
	        if (split.k2.negative) {
	          split.k2.ineg();
	          beta = beta.neg(true);
	        }

	        npoints[i * 2] = p;
	        npoints[i * 2 + 1] = beta;
	        ncoeffs[i * 2] = split.k1;
	        ncoeffs[i * 2 + 1] = split.k2;
	      }
	      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	      // Clean-up references to points and coefficients
	      for (var j = 0; j < i * 2; j++) {
	        npoints[j] = null;
	        ncoeffs[j] = null;
	      }
	      return res;
	    };

	function Point$2(curve, x, y, isRed) {
	  Base$2.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new BN$9(x, 16);
	    this.y = new BN$9(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits$9(Point$2, Base$2.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point$2(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point$2.fromJSON(this, obj, red);
	};

	Point$2.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul),
	      },
	    };
	  }
	  return beta;
	};

	Point$2.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1),
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1),
	    },
	  } ];
	};

	Point$2.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point)),
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point)),
	    },
	  };
	  return res;
	};

	Point$2.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point$2.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point$2.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point$2.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point$2.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point$2.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point$2.prototype.mul = function mul(k) {
	  k = new BN$9(k, 16);
	  if (this.isInfinity())
	    return this;
	  else if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point$2.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point$2.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate),
	      },
	    };
	  }
	  return res;
	};

	Point$2.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base$2.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new BN$9(0);
	  } else {
	    this.x = new BN$9(x, 16);
	    this.y = new BN$9(y, 16);
	    this.z = new BN$9(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits$9(JPoint, Base$2.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  var i;
	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new BN$9(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	var BN$8 = bnExports$2;
	var inherits$8 = inherits_browserExports;
	var Base$1 = base$1;

	var utils$h = utils$l;

	function MontCurve(conf) {
	  Base$1.call(this, 'mont', conf);

	  this.a = new BN$8(conf.a, 16).toRed(this.red);
	  this.b = new BN$8(conf.b, 16).toRed(this.red);
	  this.i4 = new BN$8(4).toRed(this.red).redInvm();
	  this.two = new BN$8(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits$8(MontCurve, Base$1);
	var mont = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point$1(curve, x, z) {
	  Base$1.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new BN$8(x, 16);
	    this.z = new BN$8(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits$8(Point$1, Base$1.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils$h.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point$1(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point$1.fromJSON(this, obj);
	};

	Point$1.prototype.precompute = function precompute() {
	  // No-op
	};

	Point$1.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point$1.fromJSON = function fromJSON(curve, obj) {
	  return new Point$1(curve, obj[0], obj[1] || curve.one);
	};

	Point$1.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point$1.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point$1.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point$1.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point$1.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point$1.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point$1.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point$1.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point$1.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};

	var utils$g = utils$l;
	var BN$7 = bnExports$2;
	var inherits$7 = inherits_browserExports;
	var Base = base$1;

	var assert$d = utils$g.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new BN$7(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new BN$7(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new BN$7(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert$d(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits$7(EdwardsCurve, Base);
	var edwards = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN$7(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new BN$7(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.c2);
	  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.fromRed().isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new BN$7(x, 16);
	    this.y = new BN$7(y, 16);
	    this.z = z ? new BN$7(z, 16) : this.curve.one;
	    this.t = t && new BN$7(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits$7(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	    (this.y.cmp(this.z) === 0 ||
	    (this.zOne && this.y.cmp(this.curve.c) === 0));
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  var e;
	  var h;
	  var j;
	  if (this.curve.twisted) {
	    // E = a * C
	    e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      h = this.z.redSqr();
	      // J = F - 2 * H
	      j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    e = c.redAdd(d);
	    // H = (c * Z1)^2
	    h = this.curve._mulC(this.z).redSqr();
	    // J = E - 2 * H
	    j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	    this.y,
	    this.z,
	    this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;

	(function (exports) {

		var curve = exports;

		curve.base = base$1;
		curve.short = short;
		curve.mont = mont;
		curve.edwards = edwards; 
	} (curve));

	var curves$1 = {};

	var hash$2 = {};

	var utils$f = {};

	var assert$c = minimalisticAssert;
	var inherits$6 = inherits_browserExports;

	utils$f.inherits = inherits$6;

	function isSurrogatePair(msg, i) {
	  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
	    return false;
	  }
	  if (i < 0 || i + 1 >= msg.length) {
	    return false;
	  }
	  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
	}

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      // Inspired by stringToUtf8ByteArray() in closure-library by Google
	      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
	      // Apache License 2.0
	      // https://github.com/google/closure-library/blob/master/LICENSE
	      var p = 0;
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        if (c < 128) {
	          res[p++] = c;
	        } else if (c < 2048) {
	          res[p++] = (c >> 6) | 192;
	          res[p++] = (c & 63) | 128;
	        } else if (isSurrogatePair(msg, i)) {
	          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
	          res[p++] = (c >> 18) | 240;
	          res[p++] = ((c >> 12) & 63) | 128;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        } else {
	          res[p++] = (c >> 12) | 224;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        }
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils$f.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils$f.toHex = toHex;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	utils$f.htonl = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils$f.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils$f.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils$f.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert$c(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	utils$f.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils$f.split32 = split32;

	function rotr32$1(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils$f.rotr32 = rotr32$1;

	function rotl32$2(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils$f.rotl32 = rotl32$2;

	function sum32$3(a, b) {
	  return (a + b) >>> 0;
	}
	utils$f.sum32 = sum32$3;

	function sum32_3$1(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	utils$f.sum32_3 = sum32_3$1;

	function sum32_4$2(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	utils$f.sum32_4 = sum32_4$2;

	function sum32_5$2(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	utils$f.sum32_5 = sum32_5$2;

	function sum64$1(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	utils$f.sum64 = sum64$1;

	function sum64_hi$1(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	}
	utils$f.sum64_hi = sum64_hi$1;

	function sum64_lo$1(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	}
	utils$f.sum64_lo = sum64_lo$1;

	function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	utils$f.sum64_4_hi = sum64_4_hi$1;

	function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	utils$f.sum64_4_lo = sum64_4_lo$1;

	function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	utils$f.sum64_5_hi = sum64_5_hi$1;

	function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	}
	utils$f.sum64_5_lo = sum64_5_lo$1;

	function rotr64_hi$1(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}
	utils$f.rotr64_hi = rotr64_hi$1;

	function rotr64_lo$1(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$f.rotr64_lo = rotr64_lo$1;

	function shr64_hi$1(ah, al, num) {
	  return ah >>> num;
	}
	utils$f.shr64_hi = shr64_hi$1;

	function shr64_lo$1(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$f.shr64_lo = shr64_lo$1;

	var common$5 = {};

	var utils$e = utils$f;
	var assert$b = minimalisticAssert;

	function BlockHash$4() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	common$5.BlockHash = BlockHash$4;

	BlockHash$4.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils$e.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils$e.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash$4.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert$b(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash$4.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};

	var sha = {};

	var common$4 = {};

	var utils$d = utils$f;
	var rotr32 = utils$d.rotr32;

	function ft_1$1(s, x, y, z) {
	  if (s === 0)
	    return ch32$1(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32$1(x, y, z);
	}
	common$4.ft_1 = ft_1$1;

	function ch32$1(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}
	common$4.ch32 = ch32$1;

	function maj32$1(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}
	common$4.maj32 = maj32$1;

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	common$4.p32 = p32;

	function s0_256$1(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}
	common$4.s0_256 = s0_256$1;

	function s1_256$1(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}
	common$4.s1_256 = s1_256$1;

	function g0_256$1(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}
	common$4.g0_256 = g0_256$1;

	function g1_256$1(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}
	common$4.g1_256 = g1_256$1;

	var utils$c = utils$f;
	var common$3 = common$5;
	var shaCommon$1 = common$4;

	var rotl32$1 = utils$c.rotl32;
	var sum32$2 = utils$c.sum32;
	var sum32_5$1 = utils$c.sum32_5;
	var ft_1 = shaCommon$1.ft_1;
	var BlockHash$3 = common$3.BlockHash;

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash$3.call(this);
	  this.h = [
	    0x67452301, 0xefcdab89, 0x98badcfe,
	    0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils$c.inherits(SHA1, BlockHash$3);
	var _1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32$1(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32$2(this.h[0], a);
	  this.h[1] = sum32$2(this.h[1], b);
	  this.h[2] = sum32$2(this.h[2], c);
	  this.h[3] = sum32$2(this.h[3], d);
	  this.h[4] = sum32$2(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$c.toHex32(this.h, 'big');
	  else
	    return utils$c.split32(this.h, 'big');
	};

	var utils$b = utils$f;
	var common$2 = common$5;
	var shaCommon = common$4;
	var assert$a = minimalisticAssert;

	var sum32$1 = utils$b.sum32;
	var sum32_4$1 = utils$b.sum32_4;
	var sum32_5 = utils$b.sum32_5;
	var ch32 = shaCommon.ch32;
	var maj32 = shaCommon.maj32;
	var s0_256 = shaCommon.s0_256;
	var s1_256 = shaCommon.s1_256;
	var g0_256 = shaCommon.g0_256;
	var g1_256 = shaCommon.g1_256;

	var BlockHash$2 = common$2.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	function SHA256$1() {
	  if (!(this instanceof SHA256$1))
	    return new SHA256$1();

	  BlockHash$2.call(this);
	  this.h = [
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	  ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils$b.inherits(SHA256$1, BlockHash$2);
	var _256 = SHA256$1;

	SHA256$1.blockSize = 512;
	SHA256$1.outSize = 256;
	SHA256$1.hmacStrength = 192;
	SHA256$1.padLength = 64;

	SHA256$1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert$a(this.k.length === W.length);
	  for (i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32$1(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32$1(T1, T2);
	  }

	  this.h[0] = sum32$1(this.h[0], a);
	  this.h[1] = sum32$1(this.h[1], b);
	  this.h[2] = sum32$1(this.h[2], c);
	  this.h[3] = sum32$1(this.h[3], d);
	  this.h[4] = sum32$1(this.h[4], e);
	  this.h[5] = sum32$1(this.h[5], f);
	  this.h[6] = sum32$1(this.h[6], g);
	  this.h[7] = sum32$1(this.h[7], h);
	};

	SHA256$1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$b.toHex32(this.h, 'big');
	  else
	    return utils$b.split32(this.h, 'big');
	};

	var utils$a = utils$f;
	var SHA256 = _256;

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [
	    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils$a.inherits(SHA224, SHA256);
	var _224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils$a.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils$a.split32(this.h.slice(0, 7), 'big');
	};

	var utils$9 = utils$f;
	var common$1 = common$5;
	var assert$9 = minimalisticAssert;

	var rotr64_hi = utils$9.rotr64_hi;
	var rotr64_lo = utils$9.rotr64_lo;
	var shr64_hi = utils$9.shr64_hi;
	var shr64_lo = utils$9.shr64_lo;
	var sum64 = utils$9.sum64;
	var sum64_hi = utils$9.sum64_hi;
	var sum64_lo = utils$9.sum64_lo;
	var sum64_4_hi = utils$9.sum64_4_hi;
	var sum64_4_lo = utils$9.sum64_4_lo;
	var sum64_5_hi = utils$9.sum64_5_hi;
	var sum64_5_lo = utils$9.sum64_5_lo;

	var BlockHash$1 = common$1.BlockHash;

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function SHA512$1() {
	  if (!(this instanceof SHA512$1))
	    return new SHA512$1();

	  BlockHash$1.call(this);
	  this.h = [
	    0x6a09e667, 0xf3bcc908,
	    0xbb67ae85, 0x84caa73b,
	    0x3c6ef372, 0xfe94f82b,
	    0xa54ff53a, 0x5f1d36f1,
	    0x510e527f, 0xade682d1,
	    0x9b05688c, 0x2b3e6c1f,
	    0x1f83d9ab, 0xfb41bd6b,
	    0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils$9.inherits(SHA512$1, BlockHash$1);
	var _512 = SHA512$1;

	SHA512$1.blockSize = 1024;
	SHA512$1.outSize = 512;
	SHA512$1.hmacStrength = 192;
	SHA512$1.padLength = 128;

	SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	  }
	};

	SHA512$1.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  assert$9(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);

	    c0_hi = s0_512_hi(ah, al);
	    c0_lo = s0_512_lo(ah, al);
	    c1_hi = maj64_hi(ah, al, bh, bl, ch);
	    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64(this.h, 0, ah, al);
	  sum64(this.h, 2, bh, bl);
	  sum64(this.h, 4, ch, cl);
	  sum64(this.h, 6, dh, dl);
	  sum64(this.h, 8, eh, el);
	  sum64(this.h, 10, fh, fl);
	  sum64(this.h, 12, gh, gl);
	  sum64(this.h, 14, hh, hl);
	};

	SHA512$1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$9.toHex32(this.h, 'big');
	  else
	    return utils$9.split32(this.h, 'big');
	};

	function ch64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 28);
	  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 28);
	  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 14);
	  var c1_hi = rotr64_hi(xh, xl, 18);
	  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 14);
	  var c1_lo = rotr64_lo(xh, xl, 18);
	  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 1);
	  var c1_hi = rotr64_hi(xh, xl, 8);
	  var c2_hi = shr64_hi(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 1);
	  var c1_lo = rotr64_lo(xh, xl, 8);
	  var c2_lo = shr64_lo(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 19);
	  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 19);
	  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	var utils$8 = utils$f;

	var SHA512 = _512;

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  SHA512.call(this);
	  this.h = [
	    0xcbbb9d5d, 0xc1059ed8,
	    0x629a292a, 0x367cd507,
	    0x9159015a, 0x3070dd17,
	    0x152fecd8, 0xf70e5939,
	    0x67332667, 0xffc00b31,
	    0x8eb44a87, 0x68581511,
	    0xdb0c2e0d, 0x64f98fa7,
	    0x47b5481d, 0xbefa4fa4 ];
	}
	utils$8.inherits(SHA384, SHA512);
	var _384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$8.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils$8.split32(this.h.slice(0, 12), 'big');
	};

	sha.sha1 = _1;
	sha.sha224 = _224;
	sha.sha256 = _256;
	sha.sha384 = _384;
	sha.sha512 = _512;

	var ripemd = {};

	var utils$7 = utils$f;
	var common = common$5;

	var rotl32 = utils$7.rotl32;
	var sum32 = utils$7.sum32;
	var sum32_3 = utils$7.sum32_3;
	var sum32_4 = utils$7.sum32_4;
	var BlockHash = common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils$7.inherits(RIPEMD160, BlockHash);
	ripemd.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils$7.toHex32(this.h, 'little');
	  else
	    return utils$7.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var utils$6 = utils$f;
	var assert$8 = minimalisticAssert;

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils$6.toArray(key, enc));
	}
	var hmac = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert$8(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};

	(function (exports) {
		var hash = exports;

		hash.utils = utils$f;
		hash.common = common$5;
		hash.sha = sha;
		hash.ripemd = ripemd;
		hash.hmac = hmac;

		// Proxy hash functions to the main object
		hash.sha1 = hash.sha.sha1;
		hash.sha256 = hash.sha.sha256;
		hash.sha224 = hash.sha.sha224;
		hash.sha384 = hash.sha.sha384;
		hash.sha512 = hash.sha.sha512;
		hash.ripemd160 = hash.ripemd.ripemd160; 
	} (hash$2));

	var secp256k1;
	var hasRequiredSecp256k1;

	function requireSecp256k1 () {
		if (hasRequiredSecp256k1) return secp256k1;
		hasRequiredSecp256k1 = 1;
		secp256k1 = {
		  doubles: {
		    step: 4,
		    points: [
		      [
		        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
		        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
		      ],
		      [
		        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
		        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
		      ],
		      [
		        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
		        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
		      ],
		      [
		        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
		        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
		      ],
		      [
		        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
		        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
		      ],
		      [
		        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
		        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
		      ],
		      [
		        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
		        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
		      ],
		      [
		        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
		        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
		      ],
		      [
		        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
		        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
		      ],
		      [
		        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
		        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
		      ],
		      [
		        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
		        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
		      ],
		      [
		        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
		        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
		      ],
		      [
		        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
		        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
		      ],
		      [
		        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
		        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
		      ],
		      [
		        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
		        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
		      ],
		      [
		        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
		        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
		      ],
		      [
		        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
		        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
		      ],
		      [
		        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
		        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
		      ],
		      [
		        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
		        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
		      ],
		      [
		        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
		        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
		      ],
		      [
		        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
		        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
		      ],
		      [
		        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
		        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
		      ],
		      [
		        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
		        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
		      ],
		      [
		        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
		        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
		      ],
		      [
		        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
		        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
		      ],
		      [
		        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
		        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
		      ],
		      [
		        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
		        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
		      ],
		      [
		        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
		        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
		      ],
		      [
		        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
		        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
		      ],
		      [
		        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
		        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
		      ],
		      [
		        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
		        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
		      ],
		      [
		        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
		        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
		      ],
		      [
		        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
		        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
		      ],
		      [
		        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
		        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
		      ],
		      [
		        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
		        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
		      ],
		      [
		        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
		        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
		      ],
		      [
		        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
		        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
		      ],
		      [
		        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
		        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
		      ],
		      [
		        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
		        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
		      ],
		      [
		        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
		        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
		      ],
		      [
		        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
		        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
		      ],
		      [
		        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
		        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
		      ],
		      [
		        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
		        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
		      ],
		      [
		        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
		        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
		      ],
		      [
		        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
		        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
		      ],
		      [
		        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
		        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
		      ],
		      [
		        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
		        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
		      ],
		      [
		        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
		        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
		      ],
		      [
		        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
		        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
		      ],
		      [
		        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
		        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
		      ],
		      [
		        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
		        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
		      ],
		      [
		        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
		        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
		      ],
		      [
		        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
		        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
		      ],
		      [
		        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
		        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
		      ],
		      [
		        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
		        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
		      ],
		      [
		        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
		        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
		      ],
		      [
		        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
		        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
		      ],
		      [
		        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
		        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
		      ],
		      [
		        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
		        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
		      ],
		      [
		        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
		        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
		      ],
		      [
		        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
		        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
		      ],
		      [
		        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
		        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
		      ],
		      [
		        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
		        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
		      ],
		      [
		        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
		        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
		      ],
		      [
		        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
		        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
		      ],
		    ],
		  },
		  naf: {
		    wnd: 7,
		    points: [
		      [
		        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
		        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
		      ],
		      [
		        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
		        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
		      ],
		      [
		        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
		        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
		      ],
		      [
		        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
		        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
		      ],
		      [
		        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
		        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
		      ],
		      [
		        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
		        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
		      ],
		      [
		        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
		        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
		      ],
		      [
		        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
		        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
		      ],
		      [
		        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
		        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
		      ],
		      [
		        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
		        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
		      ],
		      [
		        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
		        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
		      ],
		      [
		        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
		        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
		      ],
		      [
		        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
		        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
		      ],
		      [
		        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
		        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
		      ],
		      [
		        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
		        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
		      ],
		      [
		        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
		        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
		      ],
		      [
		        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
		        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
		      ],
		      [
		        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
		        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
		      ],
		      [
		        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
		        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
		      ],
		      [
		        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
		        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
		      ],
		      [
		        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
		        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
		      ],
		      [
		        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
		        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
		      ],
		      [
		        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
		        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
		      ],
		      [
		        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
		        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
		      ],
		      [
		        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
		        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
		      ],
		      [
		        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
		        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
		      ],
		      [
		        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
		        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
		      ],
		      [
		        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
		        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
		      ],
		      [
		        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
		        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
		      ],
		      [
		        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
		        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
		      ],
		      [
		        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
		        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
		      ],
		      [
		        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
		        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
		      ],
		      [
		        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
		        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
		      ],
		      [
		        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
		        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
		      ],
		      [
		        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
		        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
		      ],
		      [
		        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
		        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
		      ],
		      [
		        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
		        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
		      ],
		      [
		        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
		        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
		      ],
		      [
		        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
		        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
		      ],
		      [
		        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
		        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
		      ],
		      [
		        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
		        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
		      ],
		      [
		        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
		        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
		      ],
		      [
		        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
		        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
		      ],
		      [
		        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
		        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
		      ],
		      [
		        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
		        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
		      ],
		      [
		        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
		        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
		      ],
		      [
		        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
		        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
		      ],
		      [
		        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
		        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
		      ],
		      [
		        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
		        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
		      ],
		      [
		        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
		        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
		      ],
		      [
		        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
		        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
		      ],
		      [
		        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
		        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
		      ],
		      [
		        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
		        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
		      ],
		      [
		        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
		        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
		      ],
		      [
		        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
		        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
		      ],
		      [
		        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
		        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
		      ],
		      [
		        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
		        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
		      ],
		      [
		        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
		        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
		      ],
		      [
		        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
		        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
		      ],
		      [
		        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
		        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
		      ],
		      [
		        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
		        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
		      ],
		      [
		        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
		        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
		      ],
		      [
		        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
		        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
		      ],
		      [
		        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
		        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
		      ],
		      [
		        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
		        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
		      ],
		      [
		        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
		        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
		      ],
		      [
		        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
		        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
		      ],
		      [
		        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
		        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
		      ],
		      [
		        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
		        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
		      ],
		      [
		        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
		        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
		      ],
		      [
		        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
		        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
		      ],
		      [
		        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
		        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
		      ],
		      [
		        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
		        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
		      ],
		      [
		        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
		        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
		      ],
		      [
		        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
		        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
		      ],
		      [
		        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
		        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
		      ],
		      [
		        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
		        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
		      ],
		      [
		        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
		        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
		      ],
		      [
		        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
		        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
		      ],
		      [
		        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
		        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
		      ],
		      [
		        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
		        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
		      ],
		      [
		        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
		        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
		      ],
		      [
		        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
		        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
		      ],
		      [
		        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
		        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
		      ],
		      [
		        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
		        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
		      ],
		      [
		        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
		        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
		      ],
		      [
		        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
		        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
		      ],
		      [
		        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
		        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
		      ],
		      [
		        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
		        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
		      ],
		      [
		        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
		        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
		      ],
		      [
		        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
		        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
		      ],
		      [
		        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
		        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
		      ],
		      [
		        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
		        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
		      ],
		      [
		        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
		        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
		      ],
		      [
		        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
		        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
		      ],
		      [
		        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
		        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
		      ],
		      [
		        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
		        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
		      ],
		      [
		        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
		        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
		      ],
		      [
		        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
		        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
		      ],
		      [
		        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
		        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
		      ],
		      [
		        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
		        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
		      ],
		      [
		        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
		        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
		      ],
		      [
		        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
		        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
		      ],
		      [
		        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
		        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
		      ],
		      [
		        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
		        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
		      ],
		      [
		        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
		        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
		      ],
		      [
		        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
		        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
		      ],
		      [
		        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
		        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
		      ],
		      [
		        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
		        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
		      ],
		      [
		        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
		        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
		      ],
		      [
		        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
		        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
		      ],
		      [
		        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
		        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
		      ],
		      [
		        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
		        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
		      ],
		      [
		        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
		        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
		      ],
		      [
		        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
		        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
		      ],
		      [
		        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
		        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
		      ],
		      [
		        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
		        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
		      ],
		      [
		        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
		        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
		      ],
		      [
		        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
		        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
		      ],
		      [
		        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
		        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
		      ],
		      [
		        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
		        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
		      ],
		      [
		        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
		        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
		      ],
		      [
		        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
		        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
		      ],
		      [
		        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
		        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
		      ],
		      [
		        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
		        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
		      ],
		      [
		        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
		        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
		      ],
		      [
		        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
		        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
		      ],
		    ],
		  },
		};
		return secp256k1;
	}

	(function (exports) {

		var curves = exports;

		var hash = hash$2;
		var curve$1 = curve;
		var utils = utils$l;

		var assert = utils.assert;

		function PresetCurve(options) {
		  if (options.type === 'short')
		    this.curve = new curve$1.short(options);
		  else if (options.type === 'edwards')
		    this.curve = new curve$1.edwards(options);
		  else
		    this.curve = new curve$1.mont(options);
		  this.g = this.curve.g;
		  this.n = this.curve.n;
		  this.hash = options.hash;

		  assert(this.g.validate(), 'Invalid curve');
		  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
		}
		curves.PresetCurve = PresetCurve;

		function defineCurve(name, options) {
		  Object.defineProperty(curves, name, {
		    configurable: true,
		    enumerable: true,
		    get: function() {
		      var curve = new PresetCurve(options);
		      Object.defineProperty(curves, name, {
		        configurable: true,
		        enumerable: true,
		        value: curve,
		      });
		      return curve;
		    },
		  });
		}

		defineCurve('p192', {
		  type: 'short',
		  prime: 'p192',
		  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
		  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
		  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
		    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
		  ],
		});

		defineCurve('p224', {
		  type: 'short',
		  prime: 'p224',
		  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
		  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
		  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
		    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
		  ],
		});

		defineCurve('p256', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
		  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
		  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
		  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
		  ],
		});

		defineCurve('p384', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 ffffffff',
		  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 fffffffc',
		  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
		     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
		  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
		     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
		  hash: hash.sha384,
		  gRed: false,
		  g: [
		    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
		    '5502f25d bf55296c 3a545e38 72760ab7',
		    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
		  ],
		});

		defineCurve('p521', {
		  type: 'short',
		  prime: null,
		  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff',
		  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff fffffffc',
		  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
		     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
		     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
		  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
		     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
		  hash: hash.sha512,
		  gRed: false,
		  g: [
		    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
		    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
		    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
		    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
		    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
		    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
		  ],
		});

		defineCurve('curve25519', {
		  type: 'mont',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '76d06',
		  b: '1',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '9',
		  ],
		});

		defineCurve('ed25519', {
		  type: 'edwards',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '-1',
		  c: '1',
		  // -121665 * (121666^(-1)) (mod P)
		  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

		    // 4/5
		    '6666666666666666666666666666666666666666666666666666666666666658',
		  ],
		});

		var pre;
		try {
		  pre = requireSecp256k1();
		} catch (e) {
		  pre = undefined;
		}

		defineCurve('secp256k1', {
		  type: 'short',
		  prime: 'k256',
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
		  a: '0',
		  b: '7',
		  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
		  h: '1',
		  hash: hash.sha256,

		  // Precomputed endomorphism
		  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
		  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
		  basis: [
		    {
		      a: '3086d221a7d46bcde86c90e49284eb15',
		      b: '-e4437ed6010e88286f547fa90abfe4c3',
		    },
		    {
		      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
		      b: '3086d221a7d46bcde86c90e49284eb15',
		    },
		  ],

		  gRed: false,
		  g: [
		    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
		    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
		    pre,
		  ],
		}); 
	} (curves$1));

	var hash$1 = hash$2;
	var utils$5 = utils$k;
	var assert$7 = minimalisticAssert;

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this._reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils$5.toArray(options.entropy, options.entropyEnc || 'hex');
	  var nonce = utils$5.toArray(options.nonce, options.nonceEnc || 'hex');
	  var pers = utils$5.toArray(options.pers, options.persEnc || 'hex');
	  assert$7(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	var hmacDrbg = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this._reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash$1.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils$5.toArray(entropy, entropyEnc);
	  add = utils$5.toArray(add, addEnc);

	  assert$7(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this._reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this._reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils$5.toArray(add, addEnc || 'hex');
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this._reseed++;
	  return utils$5.encode(res, enc);
	};

	var BN$6 = bnExports$2;
	var utils$4 = utils$l;
	var assert$6 = utils$4.assert;

	function KeyPair$2(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	var key$2 = KeyPair$2;

	KeyPair$2.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair$2)
	    return pub;

	  return new KeyPair$2(ec, {
	    pub: pub,
	    pubEnc: enc,
	  });
	};

	KeyPair$2.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair$2)
	    return priv;

	  return new KeyPair$2(ec, {
	    priv: priv,
	    privEnc: enc,
	  });
	};

	KeyPair$2.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair$2.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair$2.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair$2.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new BN$6(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair$2.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    // Montgomery points only have an `x` coordinate.
	    // Weierstrass/Edwards points on the other hand have both `x` and
	    // `y` coordinates.
	    if (this.ec.curve.type === 'mont') {
	      assert$6(key.x, 'Need x coordinate');
	    } else if (this.ec.curve.type === 'short' ||
	               this.ec.curve.type === 'edwards') {
	      assert$6(key.x && key.y, 'Need both x and y coordinate');
	    }
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair$2.prototype.derive = function derive(pub) {
	  if(!pub.validate()) {
	    assert$6(pub.validate(), 'public point not validated');
	  }
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair$2.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair$2.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair$2.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};

	var BN$5 = bnExports$2;

	var utils$3 = utils$l;
	var assert$5 = utils$3.assert;

	function Signature$2(options, enc) {
	  if (options instanceof Signature$2)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert$5(options.r && options.s, 'Signature without r or s');
	  this.r = new BN$5(options.r, 16);
	  this.s = new BN$5(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	var signature$1 = Signature$2;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;

	  // Indefinite length or overflow
	  if (octetLen === 0 || octetLen > 4) {
	    return false;
	  }

	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	    val >>>= 0;
	  }

	  // Leading zeroes
	  if (val <= 0x7f) {
	    return false;
	  }

	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature$2.prototype._importDER = function _importDER(data, enc) {
	  data = utils$3.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if (len === false) {
	    return false;
	  }
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  if (rlen === false) {
	    return false;
	  }
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (slen === false) {
	    return false;
	  }
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0) {
	    if (r[1] & 0x80) {
	      r = r.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }
	  if (s[0] === 0) {
	    if (s[1] & 0x80) {
	      s = s.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }

	  this.r = new BN$5(r);
	  this.s = new BN$5(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature$2.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils$3.encode(res, enc);
	};

	var ec$1;
	var hasRequiredEc;

	function requireEc () {
		if (hasRequiredEc) return ec$1;
		hasRequiredEc = 1;

		var BN = bnExports$2;
		var HmacDRBG = hmacDrbg;
		var utils = utils$l;
		var curves = curves$1;
		var rand = requireBrorand();
		var assert = utils.assert;

		var KeyPair = key$2;
		var Signature = signature$1;

		function EC(options) {
		  if (!(this instanceof EC))
		    return new EC(options);

		  // Shortcut `elliptic.ec(curve-name)`
		  if (typeof options === 'string') {
		    assert(Object.prototype.hasOwnProperty.call(curves, options),
		      'Unknown curve ' + options);

		    options = curves[options];
		  }

		  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
		  if (options instanceof curves.PresetCurve)
		    options = { curve: options };

		  this.curve = options.curve.curve;
		  this.n = this.curve.n;
		  this.nh = this.n.ushrn(1);
		  this.g = this.curve.g;

		  // Point on curve
		  this.g = options.curve.g;
		  this.g.precompute(options.curve.n.bitLength() + 1);

		  // Hash for function for DRBG
		  this.hash = options.hash || options.curve.hash;
		}
		ec$1 = EC;

		EC.prototype.keyPair = function keyPair(options) {
		  return new KeyPair(this, options);
		};

		EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
		  return KeyPair.fromPrivate(this, priv, enc);
		};

		EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
		  return KeyPair.fromPublic(this, pub, enc);
		};

		EC.prototype.genKeyPair = function genKeyPair(options) {
		  if (!options)
		    options = {};

		  // Instantiate Hmac_DRBG
		  var drbg = new HmacDRBG({
		    hash: this.hash,
		    pers: options.pers,
		    persEnc: options.persEnc || 'utf8',
		    entropy: options.entropy || rand(this.hash.hmacStrength),
		    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
		    nonce: this.n.toArray(),
		  });

		  var bytes = this.n.byteLength();
		  var ns2 = this.n.sub(new BN(2));
		  for (;;) {
		    var priv = new BN(drbg.generate(bytes));
		    if (priv.cmp(ns2) > 0)
		      continue;

		    priv.iaddn(1);
		    return this.keyFromPrivate(priv);
		  }
		};

		EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
		  var delta = msg.byteLength() * 8 - this.n.bitLength();
		  if (delta > 0)
		    msg = msg.ushrn(delta);
		  if (!truncOnly && msg.cmp(this.n) >= 0)
		    return msg.sub(this.n);
		  else
		    return msg;
		};

		EC.prototype.sign = function sign(msg, key, enc, options) {
		  if (typeof enc === 'object') {
		    options = enc;
		    enc = null;
		  }
		  if (!options)
		    options = {};

		  key = this.keyFromPrivate(key, enc);
		  msg = this._truncateToN(new BN(msg, 16));

		  // Zero-extend key to provide enough entropy
		  var bytes = this.n.byteLength();
		  var bkey = key.getPrivate().toArray('be', bytes);

		  // Zero-extend nonce to have the same byte size as N
		  var nonce = msg.toArray('be', bytes);

		  // Instantiate Hmac_DRBG
		  var drbg = new HmacDRBG({
		    hash: this.hash,
		    entropy: bkey,
		    nonce: nonce,
		    pers: options.pers,
		    persEnc: options.persEnc || 'utf8',
		  });

		  // Number of bytes to generate
		  var ns1 = this.n.sub(new BN(1));

		  for (var iter = 0; ; iter++) {
		    var k = options.k ?
		      options.k(iter) :
		      new BN(drbg.generate(this.n.byteLength()));
		    k = this._truncateToN(k, true);
		    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
		      continue;

		    var kp = this.g.mul(k);
		    if (kp.isInfinity())
		      continue;

		    var kpX = kp.getX();
		    var r = kpX.umod(this.n);
		    if (r.cmpn(0) === 0)
		      continue;

		    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
		    s = s.umod(this.n);
		    if (s.cmpn(0) === 0)
		      continue;

		    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
		                        (kpX.cmp(r) !== 0 ? 2 : 0);

		    // Use complement of `s`, if it is > `n / 2`
		    if (options.canonical && s.cmp(this.nh) > 0) {
		      s = this.n.sub(s);
		      recoveryParam ^= 1;
		    }

		    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
		  }
		};

		EC.prototype.verify = function verify(msg, signature, key, enc) {
		  msg = this._truncateToN(new BN(msg, 16));
		  key = this.keyFromPublic(key, enc);
		  signature = new Signature(signature, 'hex');

		  // Perform primitive values validation
		  var r = signature.r;
		  var s = signature.s;
		  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
		    return false;
		  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
		    return false;

		  // Validate signature
		  var sinv = s.invm(this.n);
		  var u1 = sinv.mul(msg).umod(this.n);
		  var u2 = sinv.mul(r).umod(this.n);
		  var p;

		  if (!this.curve._maxwellTrick) {
		    p = this.g.mulAdd(u1, key.getPublic(), u2);
		    if (p.isInfinity())
		      return false;

		    return p.getX().umod(this.n).cmp(r) === 0;
		  }

		  // NOTE: Greg Maxwell's trick, inspired by:
		  // https://git.io/vad3K

		  p = this.g.jmulAdd(u1, key.getPublic(), u2);
		  if (p.isInfinity())
		    return false;

		  // Compare `p.x` of Jacobian point with `r`,
		  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
		  // inverse of `p.z^2`
		  return p.eqXToP(r);
		};

		EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
		  assert((3 & j) === j, 'The recovery param is more than two bits');
		  signature = new Signature(signature, enc);

		  var n = this.n;
		  var e = new BN(msg);
		  var r = signature.r;
		  var s = signature.s;

		  // A set LSB signifies that the y-coordinate is odd
		  var isYOdd = j & 1;
		  var isSecondKey = j >> 1;
		  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
		    throw new Error('Unable to find sencond key candinate');

		  // 1.1. Let x = r + jn.
		  if (isSecondKey)
		    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
		  else
		    r = this.curve.pointFromX(r, isYOdd);

		  var rInv = signature.r.invm(n);
		  var s1 = n.sub(e).mul(rInv).umod(n);
		  var s2 = s.mul(rInv).umod(n);

		  // 1.6.1 Compute Q = r^-1 (sR -  eG)
		  //               Q = r^-1 (sR + -eG)
		  return this.g.mulAdd(s1, r, s2);
		};

		EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
		  signature = new Signature(signature, enc);
		  if (signature.recoveryParam !== null)
		    return signature.recoveryParam;

		  for (var i = 0; i < 4; i++) {
		    var Qprime;
		    try {
		      Qprime = this.recoverPubKey(e, signature, i);
		    } catch (e) {
		      continue;
		    }

		    if (Qprime.eq(Q))
		      return i;
		  }
		  throw new Error('Unable to find valid recovery factor');
		};
		return ec$1;
	}

	var utils$2 = utils$l;
	var assert$4 = utils$2.assert;
	var parseBytes$2 = utils$2.parseBytes;
	var cachedProperty$1 = utils$2.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair$1(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes$2(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes$2(params.pub);
	}

	KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair$1)
	    return pub;
	  return new KeyPair$1(eddsa, { pub: pub });
	};

	KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair$1)
	    return secret;
	  return new KeyPair$1(eddsa, { secret: secret });
	};

	KeyPair$1.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty$1(KeyPair$1, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty$1(KeyPair$1, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty$1(KeyPair$1, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair$1.prototype.sign = function sign(message) {
	  assert$4(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair$1.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair$1.prototype.getSecret = function getSecret(enc) {
	  assert$4(this._secret, 'KeyPair is public only');
	  return utils$2.encode(this.secret(), enc);
	};

	KeyPair$1.prototype.getPublic = function getPublic(enc) {
	  return utils$2.encode(this.pubBytes(), enc);
	};

	var key$1 = KeyPair$1;

	var BN$4 = bnExports$2;
	var utils$1 = utils$l;
	var assert$3 = utils$1.assert;
	var cachedProperty = utils$1.cachedProperty;
	var parseBytes$1 = utils$1.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature$1(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes$1(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength),
	    };
	  }

	  assert$3(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof BN$4)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature$1, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature$1, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature$1.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature$1.prototype.toHex = function toHex() {
	  return utils$1.encode(this.toBytes(), 'hex').toUpperCase();
	};

	var signature = Signature$1;

	var hash = hash$2;
	var curves = curves$1;
	var utils = utils$l;
	var assert$2 = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = key$1;
	var Signature = signature;

	function EDDSA(curve) {
	  assert$2(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  curve = curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	var eddsa = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	    .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};

	var hasRequiredElliptic;

	function requireElliptic () {
		if (hasRequiredElliptic) return elliptic$2;
		hasRequiredElliptic = 1;
		(function (exports) {

			var elliptic = exports;

			elliptic.version = require$$0.version;
			elliptic.utils = utils$l;
			elliptic.rand = requireBrorand();
			elliptic.curve = curve;
			elliptic.curves = curves$1;

			// Protocols
			elliptic.ec = requireEc();
			elliptic.eddsa = eddsa; 
		} (elliptic$2));
		return elliptic$2;
	}

	var bn = {exports: {}};

	bn.exports;

	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = require$$0$2.Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [number & 0x3ffffff];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [0];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this._strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // '0' - '9'
		    if (c >= 48 && c <= 57) {
		      return c - 48;
		    // 'A' - 'F'
		    } else if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    } else {
		      assert(false, 'Invalid character in ' + string);
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this._strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var b = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        b = c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        b = c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        b = c;
		      }
		      assert(c >= 0 && b < mul, 'Invalid character');
		      r += b;
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [0];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this._strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  function move (dest, src) {
		    dest.words = src.words;
		    dest.length = src.length;
		    dest.negative = src.negative;
		    dest.red = src.red;
		  }

		  BN.prototype._move = function _move (dest) {
		    move(dest, this);
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype._strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  // Check Symbol.for because not everywhere where Symbol defined
		  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
		  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
		    try {
		      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
		    } catch (e) {
		      BN.prototype.inspect = inspect;
		    }
		  } else {
		    BN.prototype.inspect = inspect;
		  }

		  function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  }

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modrn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16, 2);
		  };

		  if (Buffer) {
		    BN.prototype.toBuffer = function toBuffer (endian, length) {
		      return this.toArrayLike(Buffer, endian, length);
		    };
		  }

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  var allocate = function allocate (ArrayType, size) {
		    if (ArrayType.allocUnsafe) {
		      return ArrayType.allocUnsafe(size);
		    }
		    return new ArrayType(size);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    this._strip();

		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    var res = allocate(ArrayType, reqLength);
		    var postfix = endian === 'le' ? 'LE' : 'BE';
		    this['_toArrayLike' + postfix](res, byteLength);
		    return res;
		  };

		  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
		    var position = 0;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position++] = word & 0xff;
		      if (position < res.length) {
		        res[position++] = (word >> 8) & 0xff;
		      }
		      if (position < res.length) {
		        res[position++] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position < res.length) {
		          res[position++] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position < res.length) {
		      res[position++] = carry;

		      while (position < res.length) {
		        res[position++] = 0;
		      }
		    }
		  };

		  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
		    var position = res.length - 1;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position--] = word & 0xff;
		      if (position >= 0) {
		        res[position--] = (word >> 8) & 0xff;
		      }
		      if (position >= 0) {
		        res[position--] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position >= 0) {
		          res[position--] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position >= 0) {
		      res[position--] = carry;

		      while (position >= 0) {
		        res[position--] = 0;
		      }
		    }
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] >>> wbit) & 0x01;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this._strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this._strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this._strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this._strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this._strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this._strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  function jumboMulTo (self, num, out) {
		    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
		    // var fftm = new FFTM();
		    // return fftm.mulp(self, num, out);
		    return bigMulTo(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this._strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) <= num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this._strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this._strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this._strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q._strip();
		    }
		    a._strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modrn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modrn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modrn = function modrn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return isNegNum ? -acc : acc;
		  };

		  // WARNING: DEPRECATED
		  BN.prototype.modn = function modn (num) {
		    return this.modrn(num);
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    this._strip();
		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this._strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is a BN v4 instance
		        r.strip();
		      } else {
		        // r is a BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

		    move(a, a.umod(this.m)._forceRed(this));
		    return a;
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, commonjsGlobal); 
	} (bn));

	var bnExports = bn.exports;

	var asn1$3 = {};

	var asn1$2 = {};

	var api = {};

	var encoders = {};

	/* eslint-disable node/no-deprecated-api */

	var buffer$1 = require$$0$3;
	var Buffer$d = buffer$1.Buffer;

	var safer = {};

	var key;

	for (key in buffer$1) {
	  if (!buffer$1.hasOwnProperty(key)) continue
	  if (key === 'SlowBuffer' || key === 'Buffer') continue
	  safer[key] = buffer$1[key];
	}

	var Safer = safer.Buffer = {};
	for (key in Buffer$d) {
	  if (!Buffer$d.hasOwnProperty(key)) continue
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
	  Safer[key] = Buffer$d[key];
	}

	safer.Buffer.prototype = Buffer$d.prototype;

	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
	    }
	    return Buffer$d(value, encodingOrOffset, length)
	  };
	}

	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
	    }
	    var buf = Buffer$d(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf
	  };
	}

	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}

	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}

	var safer_1 = safer;

	var reporter = {};

	const inherits$5 = inherits_browserExports;

	function Reporter$2(options) {
	  this._reporterState = {
	    obj: null,
	    path: [],
	    options: options || {},
	    errors: []
	  };
	}
	reporter.Reporter = Reporter$2;

	Reporter$2.prototype.isError = function isError(obj) {
	  return obj instanceof ReporterError;
	};

	Reporter$2.prototype.save = function save() {
	  const state = this._reporterState;

	  return { obj: state.obj, pathLen: state.path.length };
	};

	Reporter$2.prototype.restore = function restore(data) {
	  const state = this._reporterState;

	  state.obj = data.obj;
	  state.path = state.path.slice(0, data.pathLen);
	};

	Reporter$2.prototype.enterKey = function enterKey(key) {
	  return this._reporterState.path.push(key);
	};

	Reporter$2.prototype.exitKey = function exitKey(index) {
	  const state = this._reporterState;

	  state.path = state.path.slice(0, index - 1);
	};

	Reporter$2.prototype.leaveKey = function leaveKey(index, key, value) {
	  const state = this._reporterState;

	  this.exitKey(index);
	  if (state.obj !== null)
	    state.obj[key] = value;
	};

	Reporter$2.prototype.path = function path() {
	  return this._reporterState.path.join('/');
	};

	Reporter$2.prototype.enterObject = function enterObject() {
	  const state = this._reporterState;

	  const prev = state.obj;
	  state.obj = {};
	  return prev;
	};

	Reporter$2.prototype.leaveObject = function leaveObject(prev) {
	  const state = this._reporterState;

	  const now = state.obj;
	  state.obj = prev;
	  return now;
	};

	Reporter$2.prototype.error = function error(msg) {
	  let err;
	  const state = this._reporterState;

	  const inherited = msg instanceof ReporterError;
	  if (inherited) {
	    err = msg;
	  } else {
	    err = new ReporterError(state.path.map(function(elem) {
	      return '[' + JSON.stringify(elem) + ']';
	    }).join(''), msg.message || msg, msg.stack);
	  }

	  if (!state.options.partial)
	    throw err;

	  if (!inherited)
	    state.errors.push(err);

	  return err;
	};

	Reporter$2.prototype.wrapResult = function wrapResult(result) {
	  const state = this._reporterState;
	  if (!state.options.partial)
	    return result;

	  return {
	    result: this.isError(result) ? null : result,
	    errors: state.errors
	  };
	};

	function ReporterError(path, msg) {
	  this.path = path;
	  this.rethrow(msg);
	}
	inherits$5(ReporterError, Error);

	ReporterError.prototype.rethrow = function rethrow(msg) {
	  this.message = msg + ' at: ' + (this.path || '(shallow)');
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, ReporterError);

	  if (!this.stack) {
	    try {
	      // IE only adds stack when thrown
	      throw new Error(this.message);
	    } catch (e) {
	      this.stack = e.stack;
	    }
	  }
	  return this;
	};

	var buffer = {};

	const inherits$4 = inherits_browserExports;
	const Reporter$1 = reporter.Reporter;
	const Buffer$c = safer_1.Buffer;

	function DecoderBuffer$2(base, options) {
	  Reporter$1.call(this, options);
	  if (!Buffer$c.isBuffer(base)) {
	    this.error('Input not Buffer');
	    return;
	  }

	  this.base = base;
	  this.offset = 0;
	  this.length = base.length;
	}
	inherits$4(DecoderBuffer$2, Reporter$1);
	buffer.DecoderBuffer = DecoderBuffer$2;

	DecoderBuffer$2.isDecoderBuffer = function isDecoderBuffer(data) {
	  if (data instanceof DecoderBuffer$2) {
	    return true;
	  }

	  // Or accept compatible API
	  const isCompatible = typeof data === 'object' &&
	    Buffer$c.isBuffer(data.base) &&
	    data.constructor.name === 'DecoderBuffer' &&
	    typeof data.offset === 'number' &&
	    typeof data.length === 'number' &&
	    typeof data.save === 'function' &&
	    typeof data.restore === 'function' &&
	    typeof data.isEmpty === 'function' &&
	    typeof data.readUInt8 === 'function' &&
	    typeof data.skip === 'function' &&
	    typeof data.raw === 'function';

	  return isCompatible;
	};

	DecoderBuffer$2.prototype.save = function save() {
	  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
	};

	DecoderBuffer$2.prototype.restore = function restore(save) {
	  // Return skipped data
	  const res = new DecoderBuffer$2(this.base);
	  res.offset = save.offset;
	  res.length = this.offset;

	  this.offset = save.offset;
	  Reporter$1.prototype.restore.call(this, save.reporter);

	  return res;
	};

	DecoderBuffer$2.prototype.isEmpty = function isEmpty() {
	  return this.offset === this.length;
	};

	DecoderBuffer$2.prototype.readUInt8 = function readUInt8(fail) {
	  if (this.offset + 1 <= this.length)
	    return this.base.readUInt8(this.offset++, true);
	  else
	    return this.error(fail || 'DecoderBuffer overrun');
	};

	DecoderBuffer$2.prototype.skip = function skip(bytes, fail) {
	  if (!(this.offset + bytes <= this.length))
	    return this.error(fail || 'DecoderBuffer overrun');

	  const res = new DecoderBuffer$2(this.base);

	  // Share reporter state
	  res._reporterState = this._reporterState;

	  res.offset = this.offset;
	  res.length = this.offset + bytes;
	  this.offset += bytes;
	  return res;
	};

	DecoderBuffer$2.prototype.raw = function raw(save) {
	  return this.base.slice(save ? save.offset : this.offset, this.length);
	};

	function EncoderBuffer$1(value, reporter) {
	  if (Array.isArray(value)) {
	    this.length = 0;
	    this.value = value.map(function(item) {
	      if (!EncoderBuffer$1.isEncoderBuffer(item))
	        item = new EncoderBuffer$1(item, reporter);
	      this.length += item.length;
	      return item;
	    }, this);
	  } else if (typeof value === 'number') {
	    if (!(0 <= value && value <= 0xff))
	      return reporter.error('non-byte EncoderBuffer value');
	    this.value = value;
	    this.length = 1;
	  } else if (typeof value === 'string') {
	    this.value = value;
	    this.length = Buffer$c.byteLength(value);
	  } else if (Buffer$c.isBuffer(value)) {
	    this.value = value;
	    this.length = value.length;
	  } else {
	    return reporter.error('Unsupported type: ' + typeof value);
	  }
	}
	buffer.EncoderBuffer = EncoderBuffer$1;

	EncoderBuffer$1.isEncoderBuffer = function isEncoderBuffer(data) {
	  if (data instanceof EncoderBuffer$1) {
	    return true;
	  }

	  // Or accept compatible API
	  const isCompatible = typeof data === 'object' &&
	    data.constructor.name === 'EncoderBuffer' &&
	    typeof data.length === 'number' &&
	    typeof data.join === 'function';

	  return isCompatible;
	};

	EncoderBuffer$1.prototype.join = function join(out, offset) {
	  if (!out)
	    out = Buffer$c.alloc(this.length);
	  if (!offset)
	    offset = 0;

	  if (this.length === 0)
	    return out;

	  if (Array.isArray(this.value)) {
	    this.value.forEach(function(item) {
	      item.join(out, offset);
	      offset += item.length;
	    });
	  } else {
	    if (typeof this.value === 'number')
	      out[offset] = this.value;
	    else if (typeof this.value === 'string')
	      out.write(this.value, offset);
	    else if (Buffer$c.isBuffer(this.value))
	      this.value.copy(out, offset);
	    offset += this.length;
	  }

	  return out;
	};

	const Reporter = reporter.Reporter;
	const EncoderBuffer = buffer.EncoderBuffer;
	const DecoderBuffer$1 = buffer.DecoderBuffer;
	const assert$1 = minimalisticAssert;

	// Supported tags
	const tags = [
	  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
	  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
	  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
	  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
	];

	// Public methods list
	const methods = [
	  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
	  'any', 'contains'
	].concat(tags);

	// Overrided methods list
	const overrided = [
	  '_peekTag', '_decodeTag', '_use',
	  '_decodeStr', '_decodeObjid', '_decodeTime',
	  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

	  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
	  '_encodeNull', '_encodeInt', '_encodeBool'
	];

	function Node$4(enc, parent, name) {
	  const state = {};
	  this._baseState = state;

	  state.name = name;
	  state.enc = enc;

	  state.parent = parent || null;
	  state.children = null;

	  // State
	  state.tag = null;
	  state.args = null;
	  state.reverseArgs = null;
	  state.choice = null;
	  state.optional = false;
	  state.any = false;
	  state.obj = false;
	  state.use = null;
	  state.useDecoder = null;
	  state.key = null;
	  state['default'] = null;
	  state.explicit = null;
	  state.implicit = null;
	  state.contains = null;

	  // Should create new instance on each method
	  if (!state.parent) {
	    state.children = [];
	    this._wrap();
	  }
	}
	var node = Node$4;

	const stateProps = [
	  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
	  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
	  'implicit', 'contains'
	];

	Node$4.prototype.clone = function clone() {
	  const state = this._baseState;
	  const cstate = {};
	  stateProps.forEach(function(prop) {
	    cstate[prop] = state[prop];
	  });
	  const res = new this.constructor(cstate.parent);
	  res._baseState = cstate;
	  return res;
	};

	Node$4.prototype._wrap = function wrap() {
	  const state = this._baseState;
	  methods.forEach(function(method) {
	    this[method] = function _wrappedMethod() {
	      const clone = new this.constructor(this);
	      state.children.push(clone);
	      return clone[method].apply(clone, arguments);
	    };
	  }, this);
	};

	Node$4.prototype._init = function init(body) {
	  const state = this._baseState;

	  assert$1(state.parent === null);
	  body.call(this);

	  // Filter children
	  state.children = state.children.filter(function(child) {
	    return child._baseState.parent === this;
	  }, this);
	  assert$1.equal(state.children.length, 1, 'Root node can have only one child');
	};

	Node$4.prototype._useArgs = function useArgs(args) {
	  const state = this._baseState;

	  // Filter children and args
	  const children = args.filter(function(arg) {
	    return arg instanceof this.constructor;
	  }, this);
	  args = args.filter(function(arg) {
	    return !(arg instanceof this.constructor);
	  }, this);

	  if (children.length !== 0) {
	    assert$1(state.children === null);
	    state.children = children;

	    // Replace parent to maintain backward link
	    children.forEach(function(child) {
	      child._baseState.parent = this;
	    }, this);
	  }
	  if (args.length !== 0) {
	    assert$1(state.args === null);
	    state.args = args;
	    state.reverseArgs = args.map(function(arg) {
	      if (typeof arg !== 'object' || arg.constructor !== Object)
	        return arg;

	      const res = {};
	      Object.keys(arg).forEach(function(key) {
	        if (key == (key | 0))
	          key |= 0;
	        const value = arg[key];
	        res[value] = key;
	      });
	      return res;
	    });
	  }
	};

	//
	// Overrided methods
	//

	overrided.forEach(function(method) {
	  Node$4.prototype[method] = function _overrided() {
	    const state = this._baseState;
	    throw new Error(method + ' not implemented for encoding: ' + state.enc);
	  };
	});

	//
	// Public methods
	//

	tags.forEach(function(tag) {
	  Node$4.prototype[tag] = function _tagMethod() {
	    const state = this._baseState;
	    const args = Array.prototype.slice.call(arguments);

	    assert$1(state.tag === null);
	    state.tag = tag;

	    this._useArgs(args);

	    return this;
	  };
	});

	Node$4.prototype.use = function use(item) {
	  assert$1(item);
	  const state = this._baseState;

	  assert$1(state.use === null);
	  state.use = item;

	  return this;
	};

	Node$4.prototype.optional = function optional() {
	  const state = this._baseState;

	  state.optional = true;

	  return this;
	};

	Node$4.prototype.def = function def(val) {
	  const state = this._baseState;

	  assert$1(state['default'] === null);
	  state['default'] = val;
	  state.optional = true;

	  return this;
	};

	Node$4.prototype.explicit = function explicit(num) {
	  const state = this._baseState;

	  assert$1(state.explicit === null && state.implicit === null);
	  state.explicit = num;

	  return this;
	};

	Node$4.prototype.implicit = function implicit(num) {
	  const state = this._baseState;

	  assert$1(state.explicit === null && state.implicit === null);
	  state.implicit = num;

	  return this;
	};

	Node$4.prototype.obj = function obj() {
	  const state = this._baseState;
	  const args = Array.prototype.slice.call(arguments);

	  state.obj = true;

	  if (args.length !== 0)
	    this._useArgs(args);

	  return this;
	};

	Node$4.prototype.key = function key(newKey) {
	  const state = this._baseState;

	  assert$1(state.key === null);
	  state.key = newKey;

	  return this;
	};

	Node$4.prototype.any = function any() {
	  const state = this._baseState;

	  state.any = true;

	  return this;
	};

	Node$4.prototype.choice = function choice(obj) {
	  const state = this._baseState;

	  assert$1(state.choice === null);
	  state.choice = obj;
	  this._useArgs(Object.keys(obj).map(function(key) {
	    return obj[key];
	  }));

	  return this;
	};

	Node$4.prototype.contains = function contains(item) {
	  const state = this._baseState;

	  assert$1(state.use === null);
	  state.contains = item;

	  return this;
	};

	//
	// Decoding
	//

	Node$4.prototype._decode = function decode(input, options) {
	  const state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return input.wrapResult(state.children[0]._decode(input, options));

	  let result = state['default'];
	  let present = true;

	  let prevKey = null;
	  if (state.key !== null)
	    prevKey = input.enterKey(state.key);

	  // Check if tag is there
	  if (state.optional) {
	    let tag = null;
	    if (state.explicit !== null)
	      tag = state.explicit;
	    else if (state.implicit !== null)
	      tag = state.implicit;
	    else if (state.tag !== null)
	      tag = state.tag;

	    if (tag === null && !state.any) {
	      // Trial and Error
	      const save = input.save();
	      try {
	        if (state.choice === null)
	          this._decodeGeneric(state.tag, input, options);
	        else
	          this._decodeChoice(input, options);
	        present = true;
	      } catch (e) {
	        present = false;
	      }
	      input.restore(save);
	    } else {
	      present = this._peekTag(input, tag, state.any);

	      if (input.isError(present))
	        return present;
	    }
	  }

	  // Push object on stack
	  let prevObj;
	  if (state.obj && present)
	    prevObj = input.enterObject();

	  if (present) {
	    // Unwrap explicit values
	    if (state.explicit !== null) {
	      const explicit = this._decodeTag(input, state.explicit);
	      if (input.isError(explicit))
	        return explicit;
	      input = explicit;
	    }

	    const start = input.offset;

	    // Unwrap implicit and normal values
	    if (state.use === null && state.choice === null) {
	      let save;
	      if (state.any)
	        save = input.save();
	      const body = this._decodeTag(
	        input,
	        state.implicit !== null ? state.implicit : state.tag,
	        state.any
	      );
	      if (input.isError(body))
	        return body;

	      if (state.any)
	        result = input.raw(save);
	      else
	        input = body;
	    }

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), start, input.length, 'tagged');

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), input.offset, input.length, 'content');

	    // Select proper method for tag
	    if (state.any) ; else if (state.choice === null) {
	      result = this._decodeGeneric(state.tag, input, options);
	    } else {
	      result = this._decodeChoice(input, options);
	    }

	    if (input.isError(result))
	      return result;

	    // Decode children
	    if (!state.any && state.choice === null && state.children !== null) {
	      state.children.forEach(function decodeChildren(child) {
	        // NOTE: We are ignoring errors here, to let parser continue with other
	        // parts of encoded data
	        child._decode(input, options);
	      });
	    }

	    // Decode contained/encoded by schema, only in bit or octet strings
	    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
	      const data = new DecoderBuffer$1(result);
	      result = this._getUse(state.contains, input._reporterState.obj)
	        ._decode(data, options);
	    }
	  }

	  // Pop object
	  if (state.obj && present)
	    result = input.leaveObject(prevObj);

	  // Set key
	  if (state.key !== null && (result !== null || present === true))
	    input.leaveKey(prevKey, state.key, result);
	  else if (prevKey !== null)
	    input.exitKey(prevKey);

	  return result;
	};

	Node$4.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
	  const state = this._baseState;

	  if (tag === 'seq' || tag === 'set')
	    return null;
	  if (tag === 'seqof' || tag === 'setof')
	    return this._decodeList(input, tag, state.args[0], options);
	  else if (/str$/.test(tag))
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'objid' && state.args)
	    return this._decodeObjid(input, state.args[0], state.args[1], options);
	  else if (tag === 'objid')
	    return this._decodeObjid(input, null, null, options);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._decodeTime(input, tag, options);
	  else if (tag === 'null_')
	    return this._decodeNull(input, options);
	  else if (tag === 'bool')
	    return this._decodeBool(input, options);
	  else if (tag === 'objDesc')
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'int' || tag === 'enum')
	    return this._decodeInt(input, state.args && state.args[0], options);

	  if (state.use !== null) {
	    return this._getUse(state.use, input._reporterState.obj)
	      ._decode(input, options);
	  } else {
	    return input.error('unknown tag: ' + tag);
	  }
	};

	Node$4.prototype._getUse = function _getUse(entity, obj) {

	  const state = this._baseState;
	  // Create altered use decoder if implicit is set
	  state.useDecoder = this._use(entity, obj);
	  assert$1(state.useDecoder._baseState.parent === null);
	  state.useDecoder = state.useDecoder._baseState.children[0];
	  if (state.implicit !== state.useDecoder._baseState.implicit) {
	    state.useDecoder = state.useDecoder.clone();
	    state.useDecoder._baseState.implicit = state.implicit;
	  }
	  return state.useDecoder;
	};

	Node$4.prototype._decodeChoice = function decodeChoice(input, options) {
	  const state = this._baseState;
	  let result = null;
	  let match = false;

	  Object.keys(state.choice).some(function(key) {
	    const save = input.save();
	    const node = state.choice[key];
	    try {
	      const value = node._decode(input, options);
	      if (input.isError(value))
	        return false;

	      result = { type: key, value: value };
	      match = true;
	    } catch (e) {
	      input.restore(save);
	      return false;
	    }
	    return true;
	  }, this);

	  if (!match)
	    return input.error('Choice not matched');

	  return result;
	};

	//
	// Encoding
	//

	Node$4.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
	  return new EncoderBuffer(data, this.reporter);
	};

	Node$4.prototype._encode = function encode(data, reporter, parent) {
	  const state = this._baseState;
	  if (state['default'] !== null && state['default'] === data)
	    return;

	  const result = this._encodeValue(data, reporter, parent);
	  if (result === undefined)
	    return;

	  if (this._skipDefault(result, reporter, parent))
	    return;

	  return result;
	};

	Node$4.prototype._encodeValue = function encode(data, reporter, parent) {
	  const state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return state.children[0]._encode(data, reporter || new Reporter());

	  let result = null;

	  // Set reporter to share it with a child class
	  this.reporter = reporter;

	  // Check if data is there
	  if (state.optional && data === undefined) {
	    if (state['default'] !== null)
	      data = state['default'];
	    else
	      return;
	  }

	  // Encode children first
	  let content = null;
	  let primitive = false;
	  if (state.any) {
	    // Anything that was given is translated to buffer
	    result = this._createEncoderBuffer(data);
	  } else if (state.choice) {
	    result = this._encodeChoice(data, reporter);
	  } else if (state.contains) {
	    content = this._getUse(state.contains, parent)._encode(data, reporter);
	    primitive = true;
	  } else if (state.children) {
	    content = state.children.map(function(child) {
	      if (child._baseState.tag === 'null_')
	        return child._encode(null, reporter, data);

	      if (child._baseState.key === null)
	        return reporter.error('Child should have a key');
	      const prevKey = reporter.enterKey(child._baseState.key);

	      if (typeof data !== 'object')
	        return reporter.error('Child expected, but input is not object');

	      const res = child._encode(data[child._baseState.key], reporter, data);
	      reporter.leaveKey(prevKey);

	      return res;
	    }, this).filter(function(child) {
	      return child;
	    });
	    content = this._createEncoderBuffer(content);
	  } else {
	    if (state.tag === 'seqof' || state.tag === 'setof') {
	      // TODO(indutny): this should be thrown on DSL level
	      if (!(state.args && state.args.length === 1))
	        return reporter.error('Too many args for : ' + state.tag);

	      if (!Array.isArray(data))
	        return reporter.error('seqof/setof, but data is not Array');

	      const child = this.clone();
	      child._baseState.implicit = null;
	      content = this._createEncoderBuffer(data.map(function(item) {
	        const state = this._baseState;

	        return this._getUse(state.args[0], data)._encode(item, reporter);
	      }, child));
	    } else if (state.use !== null) {
	      result = this._getUse(state.use, parent)._encode(data, reporter);
	    } else {
	      content = this._encodePrimitive(state.tag, data);
	      primitive = true;
	    }
	  }

	  // Encode data itself
	  if (!state.any && state.choice === null) {
	    const tag = state.implicit !== null ? state.implicit : state.tag;
	    const cls = state.implicit === null ? 'universal' : 'context';

	    if (tag === null) {
	      if (state.use === null)
	        reporter.error('Tag could be omitted only for .use()');
	    } else {
	      if (state.use === null)
	        result = this._encodeComposite(tag, primitive, cls, content);
	    }
	  }

	  // Wrap in explicit
	  if (state.explicit !== null)
	    result = this._encodeComposite(state.explicit, false, 'context', result);

	  return result;
	};

	Node$4.prototype._encodeChoice = function encodeChoice(data, reporter) {
	  const state = this._baseState;

	  const node = state.choice[data.type];
	  if (!node) {
	    assert$1(
	      false,
	      data.type + ' not found in ' +
	            JSON.stringify(Object.keys(state.choice)));
	  }
	  return node._encode(data.value, reporter);
	};

	Node$4.prototype._encodePrimitive = function encodePrimitive(tag, data) {
	  const state = this._baseState;

	  if (/str$/.test(tag))
	    return this._encodeStr(data, tag);
	  else if (tag === 'objid' && state.args)
	    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._encodeObjid(data, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._encodeTime(data, tag);
	  else if (tag === 'null_')
	    return this._encodeNull();
	  else if (tag === 'int' || tag === 'enum')
	    return this._encodeInt(data, state.args && state.reverseArgs[0]);
	  else if (tag === 'bool')
	    return this._encodeBool(data);
	  else if (tag === 'objDesc')
	    return this._encodeStr(data, tag);
	  else
	    throw new Error('Unsupported tag: ' + tag);
	};

	Node$4.prototype._isNumstr = function isNumstr(str) {
	  return /^[0-9 ]*$/.test(str);
	};

	Node$4.prototype._isPrintstr = function isPrintstr(str) {
	  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
	};

	var der$2 = {};

	(function (exports) {

		// Helper
		function reverse(map) {
		  const res = {};

		  Object.keys(map).forEach(function(key) {
		    // Convert key to integer if it is stringified
		    if ((key | 0) == key)
		      key = key | 0;

		    const value = map[key];
		    res[value] = key;
		  });

		  return res;
		}

		exports.tagClass = {
		  0: 'universal',
		  1: 'application',
		  2: 'context',
		  3: 'private'
		};
		exports.tagClassByName = reverse(exports.tagClass);

		exports.tag = {
		  0x00: 'end',
		  0x01: 'bool',
		  0x02: 'int',
		  0x03: 'bitstr',
		  0x04: 'octstr',
		  0x05: 'null_',
		  0x06: 'objid',
		  0x07: 'objDesc',
		  0x08: 'external',
		  0x09: 'real',
		  0x0a: 'enum',
		  0x0b: 'embed',
		  0x0c: 'utf8str',
		  0x0d: 'relativeOid',
		  0x10: 'seq',
		  0x11: 'set',
		  0x12: 'numstr',
		  0x13: 'printstr',
		  0x14: 't61str',
		  0x15: 'videostr',
		  0x16: 'ia5str',
		  0x17: 'utctime',
		  0x18: 'gentime',
		  0x19: 'graphstr',
		  0x1a: 'iso646str',
		  0x1b: 'genstr',
		  0x1c: 'unistr',
		  0x1d: 'charstr',
		  0x1e: 'bmpstr'
		};
		exports.tagByName = reverse(exports.tag); 
	} (der$2));

	const inherits$3 = inherits_browserExports;
	const Buffer$b = safer_1.Buffer;
	const Node$3 = node;

	// Import DER constants
	const der$1 = der$2;

	function DEREncoder$1(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode$1();
	  this.tree._init(entity.body);
	}
	var der_1$1 = DEREncoder$1;

	DEREncoder$1.prototype.encode = function encode(data, reporter) {
	  return this.tree._encode(data, reporter).join();
	};

	// Tree methods

	function DERNode$1(parent) {
	  Node$3.call(this, 'der', parent);
	}
	inherits$3(DERNode$1, Node$3);

	DERNode$1.prototype._encodeComposite = function encodeComposite(tag,
	  primitive,
	  cls,
	  content) {
	  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

	  // Short form
	  if (content.length < 0x80) {
	    const header = Buffer$b.alloc(2);
	    header[0] = encodedTag;
	    header[1] = content.length;
	    return this._createEncoderBuffer([ header, content ]);
	  }

	  // Long form
	  // Count octets required to store length
	  let lenOctets = 1;
	  for (let i = content.length; i >= 0x100; i >>= 8)
	    lenOctets++;

	  const header = Buffer$b.alloc(1 + 1 + lenOctets);
	  header[0] = encodedTag;
	  header[1] = 0x80 | lenOctets;

	  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
	    header[i] = j & 0xff;

	  return this._createEncoderBuffer([ header, content ]);
	};

	DERNode$1.prototype._encodeStr = function encodeStr(str, tag) {
	  if (tag === 'bitstr') {
	    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
	  } else if (tag === 'bmpstr') {
	    const buf = Buffer$b.alloc(str.length * 2);
	    for (let i = 0; i < str.length; i++) {
	      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
	    }
	    return this._createEncoderBuffer(buf);
	  } else if (tag === 'numstr') {
	    if (!this._isNumstr(str)) {
	      return this.reporter.error('Encoding of string type: numstr supports ' +
	                                 'only digits and space');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'printstr') {
	    if (!this._isPrintstr(str)) {
	      return this.reporter.error('Encoding of string type: printstr supports ' +
	                                 'only latin upper and lower case letters, ' +
	                                 'digits, space, apostrophe, left and rigth ' +
	                                 'parenthesis, plus sign, comma, hyphen, ' +
	                                 'dot, slash, colon, equal sign, ' +
	                                 'question mark');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (/str$/.test(tag)) {
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'objDesc') {
	    return this._createEncoderBuffer(str);
	  } else {
	    return this.reporter.error('Encoding of string type: ' + tag +
	                               ' unsupported');
	  }
	};

	DERNode$1.prototype._encodeObjid = function encodeObjid(id, values, relative) {
	  if (typeof id === 'string') {
	    if (!values)
	      return this.reporter.error('string objid given, but no values map found');
	    if (!values.hasOwnProperty(id))
	      return this.reporter.error('objid not found in values map');
	    id = values[id].split(/[\s.]+/g);
	    for (let i = 0; i < id.length; i++)
	      id[i] |= 0;
	  } else if (Array.isArray(id)) {
	    id = id.slice();
	    for (let i = 0; i < id.length; i++)
	      id[i] |= 0;
	  }

	  if (!Array.isArray(id)) {
	    return this.reporter.error('objid() should be either array or string, ' +
	                               'got: ' + JSON.stringify(id));
	  }

	  if (!relative) {
	    if (id[1] >= 40)
	      return this.reporter.error('Second objid identifier OOB');
	    id.splice(0, 2, id[0] * 40 + id[1]);
	  }

	  // Count number of octets
	  let size = 0;
	  for (let i = 0; i < id.length; i++) {
	    let ident = id[i];
	    for (size++; ident >= 0x80; ident >>= 7)
	      size++;
	  }

	  const objid = Buffer$b.alloc(size);
	  let offset = objid.length - 1;
	  for (let i = id.length - 1; i >= 0; i--) {
	    let ident = id[i];
	    objid[offset--] = ident & 0x7f;
	    while ((ident >>= 7) > 0)
	      objid[offset--] = 0x80 | (ident & 0x7f);
	  }

	  return this._createEncoderBuffer(objid);
	};

	function two(num) {
	  if (num < 10)
	    return '0' + num;
	  else
	    return num;
	}

	DERNode$1.prototype._encodeTime = function encodeTime(time, tag) {
	  let str;
	  const date = new Date(time);

	  if (tag === 'gentime') {
	    str = [
	      two(date.getUTCFullYear()),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else if (tag === 'utctime') {
	    str = [
	      two(date.getUTCFullYear() % 100),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else {
	    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
	  }

	  return this._encodeStr(str, 'octstr');
	};

	DERNode$1.prototype._encodeNull = function encodeNull() {
	  return this._createEncoderBuffer('');
	};

	DERNode$1.prototype._encodeInt = function encodeInt(num, values) {
	  if (typeof num === 'string') {
	    if (!values)
	      return this.reporter.error('String int or enum given, but no values map');
	    if (!values.hasOwnProperty(num)) {
	      return this.reporter.error('Values map doesn\'t contain: ' +
	                                 JSON.stringify(num));
	    }
	    num = values[num];
	  }

	  // Bignum, assume big endian
	  if (typeof num !== 'number' && !Buffer$b.isBuffer(num)) {
	    const numArray = num.toArray();
	    if (!num.sign && numArray[0] & 0x80) {
	      numArray.unshift(0);
	    }
	    num = Buffer$b.from(numArray);
	  }

	  if (Buffer$b.isBuffer(num)) {
	    let size = num.length;
	    if (num.length === 0)
	      size++;

	    const out = Buffer$b.alloc(size);
	    num.copy(out);
	    if (num.length === 0)
	      out[0] = 0;
	    return this._createEncoderBuffer(out);
	  }

	  if (num < 0x80)
	    return this._createEncoderBuffer(num);

	  if (num < 0x100)
	    return this._createEncoderBuffer([0, num]);

	  let size = 1;
	  for (let i = num; i >= 0x100; i >>= 8)
	    size++;

	  const out = new Array(size);
	  for (let i = out.length - 1; i >= 0; i--) {
	    out[i] = num & 0xff;
	    num >>= 8;
	  }
	  if(out[0] & 0x80) {
	    out.unshift(0);
	  }

	  return this._createEncoderBuffer(Buffer$b.from(out));
	};

	DERNode$1.prototype._encodeBool = function encodeBool(value) {
	  return this._createEncoderBuffer(value ? 0xff : 0);
	};

	DERNode$1.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getEncoder('der').tree;
	};

	DERNode$1.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
	  const state = this._baseState;
	  let i;
	  if (state['default'] === null)
	    return false;

	  const data = dataBuffer.join();
	  if (state.defaultBuffer === undefined)
	    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

	  if (data.length !== state.defaultBuffer.length)
	    return false;

	  for (i=0; i < data.length; i++)
	    if (data[i] !== state.defaultBuffer[i])
	      return false;

	  return true;
	};

	// Utility methods

	function encodeTag(tag, primitive, cls, reporter) {
	  let res;

	  if (tag === 'seqof')
	    tag = 'seq';
	  else if (tag === 'setof')
	    tag = 'set';

	  if (der$1.tagByName.hasOwnProperty(tag))
	    res = der$1.tagByName[tag];
	  else if (typeof tag === 'number' && (tag | 0) === tag)
	    res = tag;
	  else
	    return reporter.error('Unknown tag: ' + tag);

	  if (res >= 0x1f)
	    return reporter.error('Multi-octet tag encoding unsupported');

	  if (!primitive)
	    res |= 0x20;

	  res |= (der$1.tagClassByName[cls || 'universal'] << 6);

	  return res;
	}

	const inherits$2 = inherits_browserExports;

	const DEREncoder = der_1$1;

	function PEMEncoder(entity) {
	  DEREncoder.call(this, entity);
	  this.enc = 'pem';
	}
	inherits$2(PEMEncoder, DEREncoder);
	var pem$1 = PEMEncoder;

	PEMEncoder.prototype.encode = function encode(data, options) {
	  const buf = DEREncoder.prototype.encode.call(this, data);

	  const p = buf.toString('base64');
	  const out = [ '-----BEGIN ' + options.label + '-----' ];
	  for (let i = 0; i < p.length; i += 64)
	    out.push(p.slice(i, i + 64));
	  out.push('-----END ' + options.label + '-----');
	  return out.join('\n');
	};

	(function (exports) {

		const encoders = exports;

		encoders.der = der_1$1;
		encoders.pem = pem$1; 
	} (encoders));

	var decoders = {};

	const inherits$1 = inherits_browserExports;

	const bignum = bnExports$2;
	const DecoderBuffer = buffer.DecoderBuffer;
	const Node$2 = node;

	// Import DER constants
	const der = der$2;

	function DERDecoder$1(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	}
	var der_1 = DERDecoder$1;

	DERDecoder$1.prototype.decode = function decode(data, options) {
	  if (!DecoderBuffer.isDecoderBuffer(data)) {
	    data = new DecoderBuffer(data, options);
	  }

	  return this.tree._decode(data, options);
	};

	// Tree methods

	function DERNode(parent) {
	  Node$2.call(this, 'der', parent);
	}
	inherits$1(DERNode, Node$2);

	DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
	  if (buffer.isEmpty())
	    return false;

	  const state = buffer.save();
	  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  buffer.restore(state);

	  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
	    (decodedTag.tagStr + 'of') === tag || any;
	};

	DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
	  const decodedTag = derDecodeTag(buffer,
	    'Failed to decode tag of "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  let len = derDecodeLen(buffer,
	    decodedTag.primitive,
	    'Failed to get length of "' + tag + '"');

	  // Failure
	  if (buffer.isError(len))
	    return len;

	  if (!any &&
	      decodedTag.tag !== tag &&
	      decodedTag.tagStr !== tag &&
	      decodedTag.tagStr + 'of' !== tag) {
	    return buffer.error('Failed to match tag: "' + tag + '"');
	  }

	  if (decodedTag.primitive || len !== null)
	    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

	  // Indefinite length... find END tag
	  const state = buffer.save();
	  const res = this._skipUntilEnd(
	    buffer,
	    'Failed to skip indefinite length body: "' + this.tag + '"');
	  if (buffer.isError(res))
	    return res;

	  len = buffer.offset - state.offset;
	  buffer.restore(state);
	  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
	};

	DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
	  for (;;) {
	    const tag = derDecodeTag(buffer, fail);
	    if (buffer.isError(tag))
	      return tag;
	    const len = derDecodeLen(buffer, tag.primitive, fail);
	    if (buffer.isError(len))
	      return len;

	    let res;
	    if (tag.primitive || len !== null)
	      res = buffer.skip(len);
	    else
	      res = this._skipUntilEnd(buffer, fail);

	    // Failure
	    if (buffer.isError(res))
	      return res;

	    if (tag.tagStr === 'end')
	      break;
	  }
	};

	DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
	  options) {
	  const result = [];
	  while (!buffer.isEmpty()) {
	    const possibleEnd = this._peekTag(buffer, 'end');
	    if (buffer.isError(possibleEnd))
	      return possibleEnd;

	    const res = decoder.decode(buffer, 'der', options);
	    if (buffer.isError(res) && possibleEnd)
	      break;
	    result.push(res);
	  }
	  return result;
	};

	DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
	  if (tag === 'bitstr') {
	    const unused = buffer.readUInt8();
	    if (buffer.isError(unused))
	      return unused;
	    return { unused: unused, data: buffer.raw() };
	  } else if (tag === 'bmpstr') {
	    const raw = buffer.raw();
	    if (raw.length % 2 === 1)
	      return buffer.error('Decoding of string type: bmpstr length mismatch');

	    let str = '';
	    for (let i = 0; i < raw.length / 2; i++) {
	      str += String.fromCharCode(raw.readUInt16BE(i * 2));
	    }
	    return str;
	  } else if (tag === 'numstr') {
	    const numstr = buffer.raw().toString('ascii');
	    if (!this._isNumstr(numstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'numstr unsupported characters');
	    }
	    return numstr;
	  } else if (tag === 'octstr') {
	    return buffer.raw();
	  } else if (tag === 'objDesc') {
	    return buffer.raw();
	  } else if (tag === 'printstr') {
	    const printstr = buffer.raw().toString('ascii');
	    if (!this._isPrintstr(printstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'printstr unsupported characters');
	    }
	    return printstr;
	  } else if (/str$/.test(tag)) {
	    return buffer.raw().toString();
	  } else {
	    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
	  }
	};

	DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
	  let result;
	  const identifiers = [];
	  let ident = 0;
	  let subident = 0;
	  while (!buffer.isEmpty()) {
	    subident = buffer.readUInt8();
	    ident <<= 7;
	    ident |= subident & 0x7f;
	    if ((subident & 0x80) === 0) {
	      identifiers.push(ident);
	      ident = 0;
	    }
	  }
	  if (subident & 0x80)
	    identifiers.push(ident);

	  const first = (identifiers[0] / 40) | 0;
	  const second = identifiers[0] % 40;

	  if (relative)
	    result = identifiers;
	  else
	    result = [first, second].concat(identifiers.slice(1));

	  if (values) {
	    let tmp = values[result.join(' ')];
	    if (tmp === undefined)
	      tmp = values[result.join('.')];
	    if (tmp !== undefined)
	      result = tmp;
	  }

	  return result;
	};

	DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
	  const str = buffer.raw().toString();

	  let year;
	  let mon;
	  let day;
	  let hour;
	  let min;
	  let sec;
	  if (tag === 'gentime') {
	    year = str.slice(0, 4) | 0;
	    mon = str.slice(4, 6) | 0;
	    day = str.slice(6, 8) | 0;
	    hour = str.slice(8, 10) | 0;
	    min = str.slice(10, 12) | 0;
	    sec = str.slice(12, 14) | 0;
	  } else if (tag === 'utctime') {
	    year = str.slice(0, 2) | 0;
	    mon = str.slice(2, 4) | 0;
	    day = str.slice(4, 6) | 0;
	    hour = str.slice(6, 8) | 0;
	    min = str.slice(8, 10) | 0;
	    sec = str.slice(10, 12) | 0;
	    if (year < 70)
	      year = 2000 + year;
	    else
	      year = 1900 + year;
	  } else {
	    return buffer.error('Decoding ' + tag + ' time is not supported yet');
	  }

	  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
	};

	DERNode.prototype._decodeNull = function decodeNull() {
	  return null;
	};

	DERNode.prototype._decodeBool = function decodeBool(buffer) {
	  const res = buffer.readUInt8();
	  if (buffer.isError(res))
	    return res;
	  else
	    return res !== 0;
	};

	DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
	  // Bigint, return as it is (assume big endian)
	  const raw = buffer.raw();
	  let res = new bignum(raw);

	  if (values)
	    res = values[res.toString(10)] || res;

	  return res;
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getDecoder('der').tree;
	};

	// Utility methods

	function derDecodeTag(buf, fail) {
	  let tag = buf.readUInt8(fail);
	  if (buf.isError(tag))
	    return tag;

	  const cls = der.tagClass[tag >> 6];
	  const primitive = (tag & 0x20) === 0;

	  // Multi-octet tag - load
	  if ((tag & 0x1f) === 0x1f) {
	    let oct = tag;
	    tag = 0;
	    while ((oct & 0x80) === 0x80) {
	      oct = buf.readUInt8(fail);
	      if (buf.isError(oct))
	        return oct;

	      tag <<= 7;
	      tag |= oct & 0x7f;
	    }
	  } else {
	    tag &= 0x1f;
	  }
	  const tagStr = der.tag[tag];

	  return {
	    cls: cls,
	    primitive: primitive,
	    tag: tag,
	    tagStr: tagStr
	  };
	}

	function derDecodeLen(buf, primitive, fail) {
	  let len = buf.readUInt8(fail);
	  if (buf.isError(len))
	    return len;

	  // Indefinite form
	  if (!primitive && len === 0x80)
	    return null;

	  // Definite form
	  if ((len & 0x80) === 0) {
	    // Short form
	    return len;
	  }

	  // Long form
	  const num = len & 0x7f;
	  if (num > 4)
	    return buf.error('length octect is too long');

	  len = 0;
	  for (let i = 0; i < num; i++) {
	    len <<= 8;
	    const j = buf.readUInt8(fail);
	    if (buf.isError(j))
	      return j;
	    len |= j;
	  }

	  return len;
	}

	const inherits = inherits_browserExports;
	const Buffer$a = safer_1.Buffer;

	const DERDecoder = der_1;

	function PEMDecoder(entity) {
	  DERDecoder.call(this, entity);
	  this.enc = 'pem';
	}
	inherits(PEMDecoder, DERDecoder);
	var pem = PEMDecoder;

	PEMDecoder.prototype.decode = function decode(data, options) {
	  const lines = data.toString().split(/[\r\n]+/g);

	  const label = options.label.toUpperCase();

	  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
	  let start = -1;
	  let end = -1;
	  for (let i = 0; i < lines.length; i++) {
	    const match = lines[i].match(re);
	    if (match === null)
	      continue;

	    if (match[2] !== label)
	      continue;

	    if (start === -1) {
	      if (match[1] !== 'BEGIN')
	        break;
	      start = i;
	    } else {
	      if (match[1] !== 'END')
	        break;
	      end = i;
	      break;
	    }
	  }
	  if (start === -1 || end === -1)
	    throw new Error('PEM section not found for: ' + label);

	  const base64 = lines.slice(start + 1, end).join('');
	  // Remove excessive symbols
	  base64.replace(/[^a-z0-9+/=]+/gi, '');

	  const input = Buffer$a.from(base64, 'base64');
	  return DERDecoder.prototype.decode.call(this, input, options);
	};

	(function (exports) {

		const decoders = exports;

		decoders.der = der_1;
		decoders.pem = pem; 
	} (decoders));

	(function (exports) {

		const encoders$1 = encoders;
		const decoders$1 = decoders;
		const inherits = inherits_browserExports;

		const api = exports;

		api.define = function define(name, body) {
		  return new Entity(name, body);
		};

		function Entity(name, body) {
		  this.name = name;
		  this.body = body;

		  this.decoders = {};
		  this.encoders = {};
		}

		Entity.prototype._createNamed = function createNamed(Base) {
		  const name = this.name;

		  function Generated(entity) {
		    this._initNamed(entity, name);
		  }
		  inherits(Generated, Base);
		  Generated.prototype._initNamed = function _initNamed(entity, name) {
		    Base.call(this, entity, name);
		  };

		  return new Generated(this);
		};

		Entity.prototype._getDecoder = function _getDecoder(enc) {
		  enc = enc || 'der';
		  // Lazily create decoder
		  if (!this.decoders.hasOwnProperty(enc))
		    this.decoders[enc] = this._createNamed(decoders$1[enc]);
		  return this.decoders[enc];
		};

		Entity.prototype.decode = function decode(data, enc, options) {
		  return this._getDecoder(enc).decode(data, options);
		};

		Entity.prototype._getEncoder = function _getEncoder(enc) {
		  enc = enc || 'der';
		  // Lazily create encoder
		  if (!this.encoders.hasOwnProperty(enc))
		    this.encoders[enc] = this._createNamed(encoders$1[enc]);
		  return this.encoders[enc];
		};

		Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
		  return this._getEncoder(enc).encode(data, reporter);
		}; 
	} (api));

	var base = {};

	(function (exports) {

		const base = exports;

		base.Reporter = reporter.Reporter;
		base.DecoderBuffer = buffer.DecoderBuffer;
		base.EncoderBuffer = buffer.EncoderBuffer;
		base.Node = node; 
	} (base));

	var constants = {};

	(function (exports) {

		const constants = exports;

		// Helper
		constants._reverse = function reverse(map) {
		  const res = {};

		  Object.keys(map).forEach(function(key) {
		    // Convert key to integer if it is stringified
		    if ((key | 0) == key)
		      key = key | 0;

		    const value = map[key];
		    res[value] = key;
		  });

		  return res;
		};

		constants.der = der$2; 
	} (constants));

	(function (exports) {

		const asn1 = exports;

		asn1.bignum = bnExports$2;

		asn1.define = api.define;
		asn1.base = base;
		asn1.constants = constants;
		asn1.decoders = decoders;
		asn1.encoders = encoders; 
	} (asn1$2));

	var asn = asn1$2;

	var Time = asn.define('Time', function () {
	  this.choice({
	    utcTime: this.utctime(),
	    generalTime: this.gentime()
	  });
	});

	var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
	  this.seq().obj(
	    this.key('type').objid(),
	    this.key('value').any()
	  );
	});

	var AlgorithmIdentifier$1 = asn.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('parameters').optional(),
	    this.key('curve').objid().optional()
	  );
	});

	var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier$1),
	    this.key('subjectPublicKey').bitstr()
	  );
	});

	var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
	  this.setof(AttributeTypeValue);
	});

	var RDNSequence = asn.define('RDNSequence', function () {
	  this.seqof(RelativeDistinguishedName);
	});

	var Name = asn.define('Name', function () {
	  this.choice({
	    rdnSequence: this.use(RDNSequence)
	  });
	});

	var Validity = asn.define('Validity', function () {
	  this.seq().obj(
	    this.key('notBefore').use(Time),
	    this.key('notAfter').use(Time)
	  );
	});

	var Extension = asn.define('Extension', function () {
	  this.seq().obj(
	    this.key('extnID').objid(),
	    this.key('critical').bool().def(false),
	    this.key('extnValue').octstr()
	  );
	});

	var TBSCertificate = asn.define('TBSCertificate', function () {
	  this.seq().obj(
	    this.key('version').explicit(0).int().optional(),
	    this.key('serialNumber').int(),
	    this.key('signature').use(AlgorithmIdentifier$1),
	    this.key('issuer').use(Name),
	    this.key('validity').use(Validity),
	    this.key('subject').use(Name),
	    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
	    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
	    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
	    this.key('extensions').explicit(3).seqof(Extension).optional()
	  );
	});

	var X509Certificate = asn.define('X509Certificate', function () {
	  this.seq().obj(
	    this.key('tbsCertificate').use(TBSCertificate),
	    this.key('signatureAlgorithm').use(AlgorithmIdentifier$1),
	    this.key('signatureValue').bitstr()
	  );
	});

	var certificate = X509Certificate;

	var asn1$1 = asn1$2;

	asn1$3.certificate = certificate;

	var RSAPrivateKey = asn1$1.define('RSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('modulus').int(),
	    this.key('publicExponent').int(),
	    this.key('privateExponent').int(),
	    this.key('prime1').int(),
	    this.key('prime2').int(),
	    this.key('exponent1').int(),
	    this.key('exponent2').int(),
	    this.key('coefficient').int()
	  );
	});
	asn1$3.RSAPrivateKey = RSAPrivateKey;

	var RSAPublicKey = asn1$1.define('RSAPublicKey', function () {
	  this.seq().obj(
	    this.key('modulus').int(),
	    this.key('publicExponent').int()
	  );
	});
	asn1$3.RSAPublicKey = RSAPublicKey;

	var PublicKey = asn1$1.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPublicKey').bitstr()
	  );
	});
	asn1$3.PublicKey = PublicKey;

	var AlgorithmIdentifier = asn1$1.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('none').null_().optional(),
	    this.key('curve').objid().optional(),
	    this.key('params').seq().obj(
	      this.key('p').int(),
	      this.key('q').int(),
	      this.key('g').int()
	    ).optional()
	  );
	});

	var PrivateKeyInfo = asn1$1.define('PrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPrivateKey').octstr()
	  );
	});
	asn1$3.PrivateKey = PrivateKeyInfo;
	var EncryptedPrivateKeyInfo = asn1$1.define('EncryptedPrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').seq().obj(
	      this.key('id').objid(),
	      this.key('decrypt').seq().obj(
	        this.key('kde').seq().obj(
	          this.key('id').objid(),
	          this.key('kdeparams').seq().obj(
	            this.key('salt').octstr(),
	            this.key('iters').int()
	          )
	        ),
	        this.key('cipher').seq().obj(
	          this.key('algo').objid(),
	          this.key('iv').octstr()
	        )
	      )
	    ),
	    this.key('subjectPrivateKey').octstr()
	  );
	});

	asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

	var DSAPrivateKey = asn1$1.define('DSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('p').int(),
	    this.key('q').int(),
	    this.key('g').int(),
	    this.key('pub_key').int(),
	    this.key('priv_key').int()
	  );
	});
	asn1$3.DSAPrivateKey = DSAPrivateKey;

	asn1$3.DSAparam = asn1$1.define('DSAparam', function () {
	  this.int();
	});

	var ECPrivateKey = asn1$1.define('ECPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('privateKey').octstr(),
	    this.key('parameters').optional().explicit(0).use(ECParameters),
	    this.key('publicKey').optional().explicit(1).bitstr()
	  );
	});
	asn1$3.ECPrivateKey = ECPrivateKey;

	var ECParameters = asn1$1.define('ECParameters', function () {
	  this.choice({
	    namedCurve: this.objid()
	  });
	});

	asn1$3.signature = asn1$1.define('signature', function () {
	  this.seq().obj(
	    this.key('r').int(),
	    this.key('s').int()
	  );
	});

	var require$$1 = {
		"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
		"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
		"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
		"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
		"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
		"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
		"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
		"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
		"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
		"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
		"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
		"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
	};

	// adapted from https://github.com/apatil/pemstrip
	var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
	var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
	var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
	var evp = evp_bytestokey;
	var ciphers$1 = browser$5;
	var Buffer$9 = safeBufferExports.Buffer;
	var fixProc$1 = function (okey, password) {
	  var key = okey.toString();
	  var match = key.match(findProc);
	  var decrypted;
	  if (!match) {
	    var match2 = key.match(fullRegex);
	    decrypted = Buffer$9.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
	  } else {
	    var suite = 'aes' + match[1];
	    var iv = Buffer$9.from(match[2], 'hex');
	    var cipherText = Buffer$9.from(match[3].replace(/[\r\n]/g, ''), 'base64');
	    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
	    var out = [];
	    var cipher = ciphers$1.createDecipheriv(suite, cipherKey, iv);
	    out.push(cipher.update(cipherText));
	    out.push(cipher.final());
	    decrypted = Buffer$9.concat(out);
	  }
	  var tag = key.match(startRegex)[1];
	  return {
	    tag: tag,
	    data: decrypted
	  }
	};

	var asn1 = asn1$3;
	var aesid = require$$1;
	var fixProc = fixProc$1;
	var ciphers = browser$5;
	var compat = browser$7;
	var Buffer$8 = safeBufferExports.Buffer;
	var parseAsn1 = parseKeys$2;

	function parseKeys$2 (buffer) {
	  var password;
	  if (typeof buffer === 'object' && !Buffer$8.isBuffer(buffer)) {
	    password = buffer.passphrase;
	    buffer = buffer.key;
	  }
	  if (typeof buffer === 'string') {
	    buffer = Buffer$8.from(buffer);
	  }

	  var stripped = fixProc(buffer, password);

	  var type = stripped.tag;
	  var data = stripped.data;
	  var subtype, ndata;
	  switch (type) {
	    case 'CERTIFICATE':
	      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
	      // falls through
	    case 'PUBLIC KEY':
	      if (!ndata) {
	        ndata = asn1.PublicKey.decode(data, 'der');
	      }
	      subtype = ndata.algorithm.algorithm.join('.');
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
	        case '1.2.840.10045.2.1':
	          ndata.subjectPrivateKey = ndata.subjectPublicKey;
	          return {
	            type: 'ec',
	            data: ndata
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
	          return {
	            type: 'dsa',
	            data: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      // throw new Error('unknown key type ' + type)
	    case 'ENCRYPTED PRIVATE KEY':
	      data = asn1.EncryptedPrivateKey.decode(data, 'der');
	      data = decrypt(data, password);
	      // falls through
	    case 'PRIVATE KEY':
	      ndata = asn1.PrivateKey.decode(data, 'der');
	      subtype = ndata.algorithm.algorithm.join('.');
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
	        case '1.2.840.10045.2.1':
	          return {
	            curve: ndata.algorithm.curve,
	            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
	          return {
	            type: 'dsa',
	            params: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      // throw new Error('unknown key type ' + type)
	    case 'RSA PUBLIC KEY':
	      return asn1.RSAPublicKey.decode(data, 'der')
	    case 'RSA PRIVATE KEY':
	      return asn1.RSAPrivateKey.decode(data, 'der')
	    case 'DSA PRIVATE KEY':
	      return {
	        type: 'dsa',
	        params: asn1.DSAPrivateKey.decode(data, 'der')
	      }
	    case 'EC PRIVATE KEY':
	      data = asn1.ECPrivateKey.decode(data, 'der');
	      return {
	        curve: data.parameters.value,
	        privateKey: data.privateKey
	      }
	    default: throw new Error('unknown key type ' + type)
	  }
	}
	parseKeys$2.signature = asn1.signature;
	function decrypt (data, password) {
	  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
	  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
	  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
	  var iv = data.algorithm.decrypt.cipher.iv;
	  var cipherText = data.subjectPrivateKey;
	  var keylen = parseInt(algo.split('-')[1], 10) / 8;
	  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
	  var cipher = ciphers.createDecipheriv(algo, key, iv);
	  var out = [];
	  out.push(cipher.update(cipherText));
	  out.push(cipher.final());
	  return Buffer$8.concat(out)
	}

	var require$$4 = {
		"1.3.132.0.10": "secp256k1",
		"1.3.132.0.33": "p224",
		"1.2.840.10045.3.1.1": "p192",
		"1.2.840.10045.3.1.7": "p256",
		"1.3.132.0.34": "p384",
		"1.3.132.0.35": "p521"
	};

	var hasRequiredSign;

	function requireSign () {
		if (hasRequiredSign) return sign$2.exports;
		hasRequiredSign = 1;

		// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
		var Buffer = safeBufferExports.Buffer;
		var createHmac = browser$8;
		var crt = browserifyRsa;
		var EC = requireElliptic().ec;
		var BN = bnExports;
		var parseKeys = parseAsn1;
		var curves = require$$4;

		var RSA_PKCS1_PADDING = 1;

		function sign(hash, key, hashType, signType, tag) {
		  var priv = parseKeys(key);
		  if (priv.curve) {
		    // rsa keys can be interpreted as ecdsa ones in openssl
		    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
		    return ecSign(hash, priv);
		  } else if (priv.type === 'dsa') {
		    if (signType !== 'dsa') { throw new Error('wrong private key type'); }
		    return dsaSign(hash, priv, hashType);
		  }
		  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
		  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) { throw new Error('illegal or unsupported padding mode'); }

		  hash = Buffer.concat([tag, hash]);
		  var len = priv.modulus.byteLength();
		  var pad = [0, 1];
		  while (hash.length + pad.length + 1 < len) { pad.push(0xff); }
		  pad.push(0x00);
		  var i = -1;
		  while (++i < hash.length) { pad.push(hash[i]); }

		  var out = crt(pad, priv);
		  return out;
		}

		function ecSign(hash, priv) {
		  var curveId = curves[priv.curve.join('.')];
		  if (!curveId) { throw new Error('unknown curve ' + priv.curve.join('.')); }

		  var curve = new EC(curveId);
		  var key = curve.keyFromPrivate(priv.privateKey);
		  var out = key.sign(hash);

		  return Buffer.from(out.toDER());
		}

		function dsaSign(hash, priv, algo) {
		  var x = priv.params.priv_key;
		  var p = priv.params.p;
		  var q = priv.params.q;
		  var g = priv.params.g;
		  var r = new BN(0);
		  var k;
		  var H = bits2int(hash, q).mod(q);
		  var s = false;
		  var kv = getKey(x, q, hash, algo);
		  while (s === false) {
		    k = makeKey(q, kv, algo);
		    r = makeR(g, k, p, q);
		    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
		    if (s.cmpn(0) === 0) {
		      s = false;
		      r = new BN(0);
		    }
		  }
		  return toDER(r, s);
		}

		function toDER(r, s) {
		  r = r.toArray();
		  s = s.toArray();

		  // Pad values
		  if (r[0] & 0x80) { r = [0].concat(r); }
		  if (s[0] & 0x80) { s = [0].concat(s); }

		  var total = r.length + s.length + 4;
		  var res = [
		    0x30, total, 0x02, r.length
		  ];
		  res = res.concat(r, [0x02, s.length], s);
		  return Buffer.from(res);
		}

		function getKey(x, q, hash, algo) {
		  x = Buffer.from(x.toArray());
		  if (x.length < q.byteLength()) {
		    var zeros = Buffer.alloc(q.byteLength() - x.length);
		    x = Buffer.concat([zeros, x]);
		  }
		  var hlen = hash.length;
		  var hbits = bits2octets(hash, q);
		  var v = Buffer.alloc(hlen);
		  v.fill(1);
		  var k = Buffer.alloc(hlen);
		  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
		  v = createHmac(algo, k).update(v).digest();
		  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
		  v = createHmac(algo, k).update(v).digest();
		  return { k: k, v: v };
		}

		function bits2int(obits, q) {
		  var bits = new BN(obits);
		  var shift = (obits.length << 3) - q.bitLength();
		  if (shift > 0) { bits.ishrn(shift); }
		  return bits;
		}

		function bits2octets(bits, q) {
		  bits = bits2int(bits, q);
		  bits = bits.mod(q);
		  var out = Buffer.from(bits.toArray());
		  if (out.length < q.byteLength()) {
		    var zeros = Buffer.alloc(q.byteLength() - out.length);
		    out = Buffer.concat([zeros, out]);
		  }
		  return out;
		}

		function makeKey(q, kv, algo) {
		  var t;
		  var k;

		  do {
		    t = Buffer.alloc(0);

		    while (t.length * 8 < q.bitLength()) {
		      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
		      t = Buffer.concat([t, kv.v]);
		    }

		    k = bits2int(t, q);
		    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
		    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
		  } while (k.cmp(q) !== -1);

		  return k;
		}

		function makeR(g, k, p, q) {
		  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
		}

		sign$2.exports = sign;
		sign$2.exports.getKey = getKey;
		sign$2.exports.makeKey = makeKey;
		return sign$2.exports;
	}

	var verify_1;
	var hasRequiredVerify;

	function requireVerify () {
		if (hasRequiredVerify) return verify_1;
		hasRequiredVerify = 1;

		// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
		var Buffer = safeBufferExports.Buffer;
		var BN = bnExports;
		var EC = requireElliptic().ec;
		var parseKeys = parseAsn1;
		var curves = require$$4;

		function verify(sig, hash, key, signType, tag) {
		  var pub = parseKeys(key);
		  if (pub.type === 'ec') {
		    // rsa keys can be interpreted as ecdsa ones in openssl
		    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }
		    return ecVerify(sig, hash, pub);
		  } else if (pub.type === 'dsa') {
		    if (signType !== 'dsa') { throw new Error('wrong public key type'); }
		    return dsaVerify(sig, hash, pub);
		  }
		  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }

		  hash = Buffer.concat([tag, hash]);
		  var len = pub.modulus.byteLength();
		  var pad = [1];
		  var padNum = 0;
		  while (hash.length + pad.length + 2 < len) {
		    pad.push(0xff);
		    padNum += 1;
		  }
		  pad.push(0x00);
		  var i = -1;
		  while (++i < hash.length) {
		    pad.push(hash[i]);
		  }
		  pad = Buffer.from(pad);
		  var red = BN.mont(pub.modulus);
		  sig = new BN(sig).toRed(red);

		  sig = sig.redPow(new BN(pub.publicExponent));
		  sig = Buffer.from(sig.fromRed().toArray());
		  var out = padNum < 8 ? 1 : 0;
		  len = Math.min(sig.length, pad.length);
		  if (sig.length !== pad.length) { out = 1; }

		  i = -1;
		  while (++i < len) { out |= sig[i] ^ pad[i]; }
		  return out === 0;
		}

		function ecVerify(sig, hash, pub) {
		  var curveId = curves[pub.data.algorithm.curve.join('.')];
		  if (!curveId) { throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')); }

		  var curve = new EC(curveId);
		  var pubkey = pub.data.subjectPrivateKey.data;

		  return curve.verify(hash, sig, pubkey);
		}

		function dsaVerify(sig, hash, pub) {
		  var p = pub.data.p;
		  var q = pub.data.q;
		  var g = pub.data.g;
		  var y = pub.data.pub_key;
		  var unpacked = parseKeys.signature.decode(sig, 'der');
		  var s = unpacked.s;
		  var r = unpacked.r;
		  checkValue(s, q);
		  checkValue(r, q);
		  var montp = BN.mont(p);
		  var w = s.invm(q);
		  var v = g.toRed(montp)
		    .redPow(new BN(hash).mul(w).mod(q))
		    .fromRed()
		    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
		    .mod(p)
		    .mod(q);
		  return v.cmp(r) === 0;
		}

		function checkValue(b, q) {
		  if (b.cmpn(0) <= 0) { throw new Error('invalid sig'); }
		  if (b.cmp(q) >= 0) { throw new Error('invalid sig'); }
		}

		verify_1 = verify;
		return verify_1;
	}

	var browser$3;
	var hasRequiredBrowser$1;

	function requireBrowser$1 () {
		if (hasRequiredBrowser$1) return browser$3;
		hasRequiredBrowser$1 = 1;

		var Buffer = safeBufferExports.Buffer;
		var createHash = browser$9;
		var stream = readableBrowserExports;
		var inherits = inherits_browserExports;
		var sign = requireSign();
		var verify = requireVerify();

		var algorithms = require$$6;
		Object.keys(algorithms).forEach(function (key) {
		  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
		  algorithms[key.toLowerCase()] = algorithms[key];
		});

		function Sign(algorithm) {
		  stream.Writable.call(this);

		  var data = algorithms[algorithm];
		  if (!data) { throw new Error('Unknown message digest'); }

		  this._hashType = data.hash;
		  this._hash = createHash(data.hash);
		  this._tag = data.id;
		  this._signType = data.sign;
		}
		inherits(Sign, stream.Writable);

		Sign.prototype._write = function _write(data, _, done) {
		  this._hash.update(data);
		  done();
		};

		Sign.prototype.update = function update(data, enc) {
		  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

		  return this;
		};

		Sign.prototype.sign = function signMethod(key, enc) {
		  this.end();
		  var hash = this._hash.digest();
		  var sig = sign(hash, key, this._hashType, this._signType, this._tag);

		  return enc ? sig.toString(enc) : sig;
		};

		function Verify(algorithm) {
		  stream.Writable.call(this);

		  var data = algorithms[algorithm];
		  if (!data) { throw new Error('Unknown message digest'); }

		  this._hash = createHash(data.hash);
		  this._tag = data.id;
		  this._signType = data.sign;
		}
		inherits(Verify, stream.Writable);

		Verify.prototype._write = function _write(data, _, done) {
		  this._hash.update(data);
		  done();
		};

		Verify.prototype.update = function update(data, enc) {
		  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

		  return this;
		};

		Verify.prototype.verify = function verifyMethod(key, sig, enc) {
		  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;

		  this.end();
		  var hash = this._hash.digest();
		  return verify(sigBuffer, hash, key, this._signType, this._tag);
		};

		function createSign(algorithm) {
		  return new Sign(algorithm);
		}

		function createVerify(algorithm) {
		  return new Verify(algorithm);
		}

		browser$3 = {
		  Sign: createSign,
		  Verify: createVerify,
		  createSign: createSign,
		  createVerify: createVerify
		};
		return browser$3;
	}

	var browser$2;
	var hasRequiredBrowser;

	function requireBrowser () {
		if (hasRequiredBrowser) return browser$2;
		hasRequiredBrowser = 1;
		var elliptic = requireElliptic();
		var BN = bnExports$2;

		browser$2 = function createECDH (curve) {
		  return new ECDH(curve)
		};

		var aliases = {
		  secp256k1: {
		    name: 'secp256k1',
		    byteLength: 32
		  },
		  secp224r1: {
		    name: 'p224',
		    byteLength: 28
		  },
		  prime256v1: {
		    name: 'p256',
		    byteLength: 32
		  },
		  prime192v1: {
		    name: 'p192',
		    byteLength: 24
		  },
		  ed25519: {
		    name: 'ed25519',
		    byteLength: 32
		  },
		  secp384r1: {
		    name: 'p384',
		    byteLength: 48
		  },
		  secp521r1: {
		    name: 'p521',
		    byteLength: 66
		  }
		};

		aliases.p224 = aliases.secp224r1;
		aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
		aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
		aliases.p384 = aliases.secp384r1;
		aliases.p521 = aliases.secp521r1;

		function ECDH (curve) {
		  this.curveType = aliases[curve];
		  if (!this.curveType) {
		    this.curveType = {
		      name: curve
		    };
		  }
		  this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap
		  this.keys = void 0;
		}

		ECDH.prototype.generateKeys = function (enc, format) {
		  this.keys = this.curve.genKeyPair();
		  return this.getPublicKey(enc, format)
		};

		ECDH.prototype.computeSecret = function (other, inenc, enc) {
		  inenc = inenc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(other)) {
		    other = new require$$0$3.Buffer(other, inenc);
		  }
		  var otherPub = this.curve.keyFromPublic(other).getPublic();
		  var out = otherPub.mul(this.keys.getPrivate()).getX();
		  return formatReturnValue(out, enc, this.curveType.byteLength)
		};

		ECDH.prototype.getPublicKey = function (enc, format) {
		  var key = this.keys.getPublic(format === 'compressed', true);
		  if (format === 'hybrid') {
		    if (key[key.length - 1] % 2) {
		      key[0] = 7;
		    } else {
		      key[0] = 6;
		    }
		  }
		  return formatReturnValue(key, enc)
		};

		ECDH.prototype.getPrivateKey = function (enc) {
		  return formatReturnValue(this.keys.getPrivate(), enc)
		};

		ECDH.prototype.setPublicKey = function (pub, enc) {
		  enc = enc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(pub)) {
		    pub = new require$$0$3.Buffer(pub, enc);
		  }
		  this.keys._importPublic(pub);
		  return this
		};

		ECDH.prototype.setPrivateKey = function (priv, enc) {
		  enc = enc || 'utf8';
		  if (!require$$0$3.Buffer.isBuffer(priv)) {
		    priv = new require$$0$3.Buffer(priv, enc);
		  }

		  var _priv = new BN(priv);
		  _priv = _priv.toString(16);
		  this.keys = this.curve.genKeyPair();
		  this.keys._importPrivate(_priv);
		  return this
		};

		function formatReturnValue (bn, enc, len) {
		  if (!Array.isArray(bn)) {
		    bn = bn.toArray();
		  }
		  var buf = new require$$0$3.Buffer(bn);
		  if (len && buf.length < len) {
		    var zeros = new require$$0$3.Buffer(len - buf.length);
		    zeros.fill(0);
		    buf = require$$0$3.Buffer.concat([zeros, buf]);
		  }
		  if (!enc) {
		    return buf
		  } else {
		    return buf.toString(enc)
		  }
		}
		return browser$2;
	}

	var browser$1 = {};

	var createHash$2 = browser$9;
	var Buffer$7 = safeBufferExports.Buffer;

	var mgf$2 = function (seed, len) {
	  var t = Buffer$7.alloc(0);
	  var i = 0;
	  var c;
	  while (t.length < len) {
	    c = i2ops(i++);
	    t = Buffer$7.concat([t, createHash$2('sha1').update(seed).update(c).digest()]);
	  }
	  return t.slice(0, len)
	};

	function i2ops (c) {
	  var out = Buffer$7.allocUnsafe(4);
	  out.writeUInt32BE(c, 0);
	  return out
	}

	var xor$2 = function xor (a, b) {
	  var len = a.length;
	  var i = -1;
	  while (++i < len) {
	    a[i] ^= b[i];
	  }
	  return a
	};

	var BN$3 = bnExports$2;
	var Buffer$6 = safeBufferExports.Buffer;

	function withPublic$2 (paddedMsg, key) {
	  return Buffer$6.from(paddedMsg
	    .toRed(BN$3.mont(key.modulus))
	    .redPow(new BN$3(key.publicExponent))
	    .fromRed()
	    .toArray())
	}

	var withPublic_1 = withPublic$2;

	var parseKeys$1 = parseAsn1;
	var randomBytes$1 = browserExports;
	var createHash$1 = browser$9;
	var mgf$1 = mgf$2;
	var xor$1 = xor$2;
	var BN$2 = bnExports$2;
	var withPublic$1 = withPublic_1;
	var crt$1 = browserifyRsa;
	var Buffer$5 = safeBufferExports.Buffer;

	var publicEncrypt = function publicEncrypt (publicKey, msg, reverse) {
	  var padding;
	  if (publicKey.padding) {
	    padding = publicKey.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  var key = parseKeys$1(publicKey);
	  var paddedMsg;
	  if (padding === 4) {
	    paddedMsg = oaep$1(key, msg);
	  } else if (padding === 1) {
	    paddedMsg = pkcs1$1(key, msg, reverse);
	  } else if (padding === 3) {
	    paddedMsg = new BN$2(msg);
	    if (paddedMsg.cmp(key.modulus) >= 0) {
	      throw new Error('data too long for modulus')
	    }
	  } else {
	    throw new Error('unknown padding')
	  }
	  if (reverse) {
	    return crt$1(paddedMsg, key)
	  } else {
	    return withPublic$1(paddedMsg, key)
	  }
	};

	function oaep$1 (key, msg) {
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash$1('sha1').update(Buffer$5.alloc(0)).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (mLen > k - hLen2 - 2) {
	    throw new Error('message too long')
	  }
	  var ps = Buffer$5.alloc(k - mLen - hLen2 - 2);
	  var dblen = k - hLen - 1;
	  var seed = randomBytes$1(hLen);
	  var maskedDb = xor$1(Buffer$5.concat([iHash, ps, Buffer$5.alloc(1, 1), msg], dblen), mgf$1(seed, dblen));
	  var maskedSeed = xor$1(seed, mgf$1(maskedDb, hLen));
	  return new BN$2(Buffer$5.concat([Buffer$5.alloc(1), maskedSeed, maskedDb], k))
	}
	function pkcs1$1 (key, msg, reverse) {
	  var mLen = msg.length;
	  var k = key.modulus.byteLength();
	  if (mLen > k - 11) {
	    throw new Error('message too long')
	  }
	  var ps;
	  if (reverse) {
	    ps = Buffer$5.alloc(k - mLen - 3, 0xff);
	  } else {
	    ps = nonZero(k - mLen - 3);
	  }
	  return new BN$2(Buffer$5.concat([Buffer$5.from([0, reverse ? 1 : 2]), ps, Buffer$5.alloc(1), msg], k))
	}
	function nonZero (len) {
	  var out = Buffer$5.allocUnsafe(len);
	  var i = 0;
	  var cache = randomBytes$1(len * 2);
	  var cur = 0;
	  var num;
	  while (i < len) {
	    if (cur === cache.length) {
	      cache = randomBytes$1(len * 2);
	      cur = 0;
	    }
	    num = cache[cur++];
	    if (num) {
	      out[i++] = num;
	    }
	  }
	  return out
	}

	var parseKeys = parseAsn1;
	var mgf = mgf$2;
	var xor = xor$2;
	var BN$1 = bnExports$2;
	var crt = browserifyRsa;
	var createHash = browser$9;
	var withPublic = withPublic_1;
	var Buffer$4 = safeBufferExports.Buffer;

	var privateDecrypt = function privateDecrypt (privateKey, enc, reverse) {
	  var padding;
	  if (privateKey.padding) {
	    padding = privateKey.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }

	  var key = parseKeys(privateKey);
	  var k = key.modulus.byteLength();
	  if (enc.length > k || new BN$1(enc).cmp(key.modulus) >= 0) {
	    throw new Error('decryption error')
	  }
	  var msg;
	  if (reverse) {
	    msg = withPublic(new BN$1(enc), key);
	  } else {
	    msg = crt(enc, key);
	  }
	  var zBuffer = Buffer$4.alloc(k - msg.length);
	  msg = Buffer$4.concat([zBuffer, msg], k);
	  if (padding === 4) {
	    return oaep(key, msg)
	  } else if (padding === 1) {
	    return pkcs1(key, msg, reverse)
	  } else if (padding === 3) {
	    return msg
	  } else {
	    throw new Error('unknown padding')
	  }
	};

	function oaep (key, msg) {
	  var k = key.modulus.byteLength();
	  var iHash = createHash('sha1').update(Buffer$4.alloc(0)).digest();
	  var hLen = iHash.length;
	  if (msg[0] !== 0) {
	    throw new Error('decryption error')
	  }
	  var maskedSeed = msg.slice(1, hLen + 1);
	  var maskedDb = msg.slice(hLen + 1);
	  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
	  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
	  if (compare(iHash, db.slice(0, hLen))) {
	    throw new Error('decryption error')
	  }
	  var i = hLen;
	  while (db[i] === 0) {
	    i++;
	  }
	  if (db[i++] !== 1) {
	    throw new Error('decryption error')
	  }
	  return db.slice(i)
	}

	function pkcs1 (key, msg, reverse) {
	  var p1 = msg.slice(0, 2);
	  var i = 2;
	  var status = 0;
	  while (msg[i++] !== 0) {
	    if (i >= msg.length) {
	      status++;
	      break
	    }
	  }
	  var ps = msg.slice(2, i - 1);

	  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
	    status++;
	  }
	  if (ps.length < 8) {
	    status++;
	  }
	  if (status) {
	    throw new Error('decryption error')
	  }
	  return msg.slice(i)
	}
	function compare (a, b) {
	  a = Buffer$4.from(a);
	  b = Buffer$4.from(b);
	  var dif = 0;
	  var len = a.length;
	  if (a.length !== b.length) {
	    dif++;
	    len = Math.min(a.length, b.length);
	  }
	  var i = -1;
	  while (++i < len) {
	    dif += (a[i] ^ b[i]);
	  }
	  return dif
	}

	(function (exports) {
		exports.publicEncrypt = publicEncrypt;
		exports.privateDecrypt = privateDecrypt;

		exports.privateEncrypt = function privateEncrypt (key, buf) {
		  return exports.publicEncrypt(key, buf, true)
		};

		exports.publicDecrypt = function publicDecrypt (key, buf) {
		  return exports.privateDecrypt(key, buf, true)
		}; 
	} (browser$1));

	var browser = {};

	function oldBrowser () {
	  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
	}
	var safeBuffer = safeBufferExports;
	var randombytes = browserExports;
	var Buffer$3 = safeBuffer.Buffer;
	var kBufferMaxLength = safeBuffer.kMaxLength;
	var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	var kMaxUint32 = Math.pow(2, 32) - 1;
	function assertOffset (offset, length) {
	  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
	    throw new TypeError('offset must be a number')
	  }

	  if (offset > kMaxUint32 || offset < 0) {
	    throw new TypeError('offset must be a uint32')
	  }

	  if (offset > kBufferMaxLength || offset > length) {
	    throw new RangeError('offset out of range')
	  }
	}

	function assertSize (size, offset, length) {
	  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
	    throw new TypeError('size must be a number')
	  }

	  if (size > kMaxUint32 || size < 0) {
	    throw new TypeError('size must be a uint32')
	  }

	  if (size + offset > length || size > kBufferMaxLength) {
	    throw new RangeError('buffer too small')
	  }
	}
	if ((crypto && crypto.getRandomValues) || !process.browser) {
	  browser.randomFill = randomFill;
	  browser.randomFillSync = randomFillSync;
	} else {
	  browser.randomFill = oldBrowser;
	  browser.randomFillSync = oldBrowser;
	}
	function randomFill (buf, offset, size, cb) {
	  if (!Buffer$3.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  if (typeof offset === 'function') {
	    cb = offset;
	    offset = 0;
	    size = buf.length;
	  } else if (typeof size === 'function') {
	    cb = size;
	    size = buf.length - offset;
	  } else if (typeof cb !== 'function') {
	    throw new TypeError('"cb" argument must be a function')
	  }
	  assertOffset(offset, buf.length);
	  assertSize(size, offset, buf.length);
	  return actualFill(buf, offset, size, cb)
	}

	function actualFill (buf, offset, size, cb) {
	  if (process.browser) {
	    var ourBuf = buf.buffer;
	    var uint = new Uint8Array(ourBuf, offset, size);
	    crypto.getRandomValues(uint);
	    if (cb) {
	      process.nextTick(function () {
	        cb(null, buf);
	      });
	      return
	    }
	    return buf
	  }
	  if (cb) {
	    randombytes(size, function (err, bytes) {
	      if (err) {
	        return cb(err)
	      }
	      bytes.copy(buf, offset);
	      cb(null, buf);
	    });
	    return
	  }
	  var bytes = randombytes(size);
	  bytes.copy(buf, offset);
	  return buf
	}
	function randomFillSync (buf, offset, size) {
	  if (typeof offset === 'undefined') {
	    offset = 0;
	  }
	  if (!Buffer$3.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  assertOffset(offset, buf.length);

	  if (size === undefined) size = buf.length - offset;

	  assertSize(size, offset, buf.length);

	  return actualFill(buf, offset, size)
	}

	var hasRequiredCryptoBrowserify;

	function requireCryptoBrowserify () {
		if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
		hasRequiredCryptoBrowserify = 1;

		cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports;
		cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9;
		cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;

		var algos$1 = algos;
		var algoKeys = Object.keys(algos$1);
		var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);
		cryptoBrowserify.getHashes = function () {
		  return hashes
		};

		var p = browser$7;
		cryptoBrowserify.pbkdf2 = p.pbkdf2;
		cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;

		var aes = browser$6;

		cryptoBrowserify.Cipher = aes.Cipher;
		cryptoBrowserify.createCipher = aes.createCipher;
		cryptoBrowserify.Cipheriv = aes.Cipheriv;
		cryptoBrowserify.createCipheriv = aes.createCipheriv;
		cryptoBrowserify.Decipher = aes.Decipher;
		cryptoBrowserify.createDecipher = aes.createDecipher;
		cryptoBrowserify.Decipheriv = aes.Decipheriv;
		cryptoBrowserify.createDecipheriv = aes.createDecipheriv;
		cryptoBrowserify.getCiphers = aes.getCiphers;
		cryptoBrowserify.listCiphers = aes.listCiphers;

		var dh = requireBrowser$2();

		cryptoBrowserify.DiffieHellmanGroup = dh.DiffieHellmanGroup;
		cryptoBrowserify.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
		cryptoBrowserify.getDiffieHellman = dh.getDiffieHellman;
		cryptoBrowserify.createDiffieHellman = dh.createDiffieHellman;
		cryptoBrowserify.DiffieHellman = dh.DiffieHellman;

		var sign = requireBrowser$1();

		cryptoBrowserify.createSign = sign.createSign;
		cryptoBrowserify.Sign = sign.Sign;
		cryptoBrowserify.createVerify = sign.createVerify;
		cryptoBrowserify.Verify = sign.Verify;

		cryptoBrowserify.createECDH = requireBrowser();

		var publicEncrypt = browser$1;

		cryptoBrowserify.publicEncrypt = publicEncrypt.publicEncrypt;
		cryptoBrowserify.privateEncrypt = publicEncrypt.privateEncrypt;
		cryptoBrowserify.publicDecrypt = publicEncrypt.publicDecrypt;
		cryptoBrowserify.privateDecrypt = publicEncrypt.privateDecrypt;

		// the least I can do is make error messages for the rest of the node.js/crypto api.
		// ;[
		//   'createCredentials'
		// ].forEach(function (name) {
		//   exports[name] = function () {
		//     throw new Error([
		//       'sorry, ' + name + ' is not implemented yet',
		//       'we accept pull requests',
		//       'https://github.com/crypto-browserify/crypto-browserify'
		//     ].join('\n'))
		//   }
		// })

		var rf = browser;

		cryptoBrowserify.randomFill = rf.randomFill;
		cryptoBrowserify.randomFillSync = rf.randomFillSync;

		cryptoBrowserify.createCredentials = function () {
		  throw new Error([
		    'sorry, createCredentials is not implemented yet',
		    'we accept pull requests',
		    'https://github.com/crypto-browserify/crypto-browserify'
		  ].join('\n'))
		};

		cryptoBrowserify.constants = {
		  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
		  'DH_CHECK_P_NOT_PRIME': 1,
		  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
		  'DH_NOT_SUITABLE_GENERATOR': 8,
		  'NPN_ENABLED': 1,
		  'ALPN_ENABLED': 1,
		  'RSA_PKCS1_PADDING': 1,
		  'RSA_SSLV23_PADDING': 2,
		  'RSA_NO_PADDING': 3,
		  'RSA_PKCS1_OAEP_PADDING': 4,
		  'RSA_X931_PADDING': 5,
		  'RSA_PKCS1_PSS_PADDING': 6,
		  'POINT_CONVERSION_COMPRESSED': 2,
		  'POINT_CONVERSION_UNCOMPRESSED': 4,
		  'POINT_CONVERSION_HYBRID': 6
		};
		return cryptoBrowserify;
	}

	var cryptoBrowserifyExports = requireCryptoBrowserify();

	const errors = {
	  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
	  TWEAK_ADD:
	    'The tweak was out of range or the resulted private key is invalid',
	  TWEAK_MUL: 'The tweak was out of range or equal to zero',
	  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
	  SECKEY_INVALID: 'Private Key is invalid',
	  PUBKEY_PARSE: 'Public Key could not be parsed',
	  PUBKEY_SERIALIZE: 'Public Key serialization error',
	  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
	  SIG_PARSE: 'Signature could not be parsed',
	  SIGN: 'The nonce generation function failed, or the private key was invalid',
	  RECOVER: 'Public key could not be recover',
	  ECDH: 'Scalar was invalid (zero or overflow)'
	};

	function assert (cond, msg) {
	  if (!cond) throw new Error(msg)
	}

	function isUint8Array (name, value, length) {
	  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);

	  if (length !== undefined) {
	    if (Array.isArray(length)) {
	      const numbers = length.join(', ');
	      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
	      assert(length.includes(value.length), msg);
	    } else {
	      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
	      assert(value.length === length, msg);
	    }
	  }
	}

	function isCompressed (value) {
	  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
	}

	function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
	  if (typeof output === 'function') output = output(length);
	  isUint8Array('output', output, length);
	  return output
	}

	function toTypeString (value) {
	  return Object.prototype.toString.call(value).slice(8, -1)
	}

	var lib = (secp256k1) => {
	  return {
	    contextRandomize (seed) {
	      assert(
	        seed === null || seed instanceof Uint8Array,
	        'Expected seed to be an Uint8Array or null'
	      );
	      if (seed !== null) isUint8Array('seed', seed, 32);

	      switch (secp256k1.contextRandomize(seed)) {
	        case 1:
	          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
	      }
	    },

	    privateKeyVerify (seckey) {
	      isUint8Array('private key', seckey, 32);

	      return secp256k1.privateKeyVerify(seckey) === 0
	    },

	    privateKeyNegate (seckey) {
	      isUint8Array('private key', seckey, 32);

	      switch (secp256k1.privateKeyNegate(seckey)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    privateKeyTweakAdd (seckey, tweak) {
	      isUint8Array('private key', seckey, 32);
	      isUint8Array('tweak', tweak, 32);

	      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.TWEAK_ADD)
	      }
	    },

	    privateKeyTweakMul (seckey, tweak) {
	      isUint8Array('private key', seckey, 32);
	      isUint8Array('tweak', tweak, 32);

	      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
	        case 0:
	          return seckey
	        case 1:
	          throw new Error(errors.TWEAK_MUL)
	      }
	    },

	    publicKeyVerify (pubkey) {
	      isUint8Array('public key', pubkey, [33, 65]);

	      return secp256k1.publicKeyVerify(pubkey) === 0
	    },

	    publicKeyCreate (seckey, compressed = true, output) {
	      isUint8Array('private key', seckey, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyCreate(output, seckey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SECKEY_INVALID)
	        case 2:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyConvert (pubkey, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyConvert(output, pubkey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyNegate (pubkey, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyNegate(output, pubkey)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	        case 3:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyCombine (pubkeys, compressed = true, output) {
	      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');
	      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');
	      for (const pubkey of pubkeys) {
	        isUint8Array('public key', pubkey, [33, 65]);
	      }
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_COMBINE)
	        case 3:
	          throw new Error(errors.PUBKEY_SERIALIZE)
	      }
	    },

	    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('tweak', tweak, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.TWEAK_ADD)
	      }
	    },

	    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('tweak', tweak, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.TWEAK_MUL)
	      }
	    },

	    signatureNormalize (sig) {
	      isUint8Array('signature', sig, 64);

	      switch (secp256k1.signatureNormalize(sig)) {
	        case 0:
	          return sig
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	      }
	    },

	    signatureExport (sig, output) {
	      isUint8Array('signature', sig, 64);
	      output = getAssertedOutput(output, 72);

	      const obj = { output, outputlen: 72 };
	      switch (secp256k1.signatureExport(obj, sig)) {
	        case 0:
	          return output.slice(0, obj.outputlen)
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    signatureImport (sig, output) {
	      isUint8Array('signature', sig);
	      output = getAssertedOutput(output, 64);

	      switch (secp256k1.signatureImport(output, sig)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdsaSign (msg32, seckey, options = {}, output) {
	      isUint8Array('message', msg32, 32);
	      isUint8Array('private key', seckey, 32);
	      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
	      if (options.data !== undefined) isUint8Array('options.data', options.data);
	      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
	      output = getAssertedOutput(output, 64);

	      const obj = { signature: output, recid: null };
	      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
	        case 0:
	          return obj
	        case 1:
	          throw new Error(errors.SIGN)
	        case 2:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdsaVerify (sig, msg32, pubkey) {
	      isUint8Array('signature', sig, 64);
	      isUint8Array('message', msg32, 32);
	      isUint8Array('public key', pubkey, [33, 65]);

	      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
	        case 0:
	          return true
	        case 3:
	          return false
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.PUBKEY_PARSE)
	      }
	    },

	    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
	      isUint8Array('signature', sig, 64);
	      assert(
	        toTypeString(recid) === 'Number' &&
	          recid >= 0 &&
	          recid <= 3,
	        'Expected recovery id to be a Number within interval [0, 3]'
	      );
	      isUint8Array('message', msg32, 32);
	      isCompressed(compressed);
	      output = getAssertedOutput(output, compressed ? 33 : 65);

	      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.SIG_PARSE)
	        case 2:
	          throw new Error(errors.RECOVER)
	        case 3:
	          throw new Error(errors.IMPOSSIBLE_CASE)
	      }
	    },

	    ecdh (pubkey, seckey, options = {}, output) {
	      isUint8Array('public key', pubkey, [33, 65]);
	      isUint8Array('private key', seckey, 32);
	      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
	      if (options.data !== undefined) isUint8Array('options.data', options.data);
	      if (options.hashfn !== undefined) {
	        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
	        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
	        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
	        isUint8Array('output', output);
	      } else {
	        output = getAssertedOutput(output, 32);
	      }

	      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
	        case 0:
	          return output
	        case 1:
	          throw new Error(errors.PUBKEY_PARSE)
	        case 2:
	          throw new Error(errors.ECDH)
	      }
	    }
	  }
	};

	const EC = requireElliptic().ec;

	const ec = new EC('secp256k1');
	const ecparams = ec.curve;

	// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
	// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
	const BN = ecparams.n.constructor;

	function loadCompressedPublicKey (first, xbuf) {
	  let x = new BN(xbuf);

	  // overflow
	  if (x.cmp(ecparams.p) >= 0) return null
	  x = x.toRed(ecparams.red);

	  // compute corresponding Y
	  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
	  if ((first === 0x03) !== y.isOdd()) y = y.redNeg();

	  return ec.keyPair({ pub: { x: x, y: y } })
	}

	function loadUncompressedPublicKey (first, xbuf, ybuf) {
	  let x = new BN(xbuf);
	  let y = new BN(ybuf);

	  // overflow
	  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

	  x = x.toRed(ecparams.red);
	  y = y.toRed(ecparams.red);

	  // is odd flag
	  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

	  // x*x*x + b = y*y
	  const x3 = x.redSqr().redIMul(x);
	  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

	  return ec.keyPair({ pub: { x: x, y: y } })
	}

	function loadPublicKey (pubkey) {
	  // length should be validated in interface
	  const first = pubkey[0];
	  switch (first) {
	    case 0x02:
	    case 0x03:
	      if (pubkey.length !== 33) return null
	      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
	    case 0x04:
	    case 0x06:
	    case 0x07:
	      if (pubkey.length !== 65) return null
	      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
	    default:
	      return null
	  }
	}

	function savePublicKey (output, point) {
	  const pubkey = point.encode(null, output.length === 33);
	  // Loop should be faster because we do not need create extra Uint8Array
	  // output.set(new Uint8Array(pubkey))
	  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];
	}

	var elliptic$1 = {
	  contextRandomize () {
	    return 0
	  },

	  privateKeyVerify (seckey) {
	    const bn = new BN(seckey);
	    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
	  },

	  privateKeyNegate (seckey) {
	    const bn = new BN(seckey);
	    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(negate);
	    return 0
	  },

	  privateKeyTweakAdd (seckey, tweak) {
	    const bn = new BN(tweak);
	    if (bn.cmp(ecparams.n) >= 0) return 1

	    bn.iadd(new BN(seckey));
	    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
	    if (bn.isZero()) return 1

	    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(tweaked);

	    return 0
	  },

	  privateKeyTweakMul (seckey, tweak) {
	    let bn = new BN(tweak);
	    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

	    bn.imul(new BN(seckey));
	    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);

	    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
	    seckey.set(tweaked);

	    return 0
	  },

	  publicKeyVerify (pubkey) {
	    const pair = loadPublicKey(pubkey);
	    return pair === null ? 1 : 0
	  },

	  publicKeyCreate (output, seckey) {
	    const bn = new BN(seckey);
	    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

	    const point = ec.keyFromPrivate(seckey).getPublic();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyConvert (output, pubkey) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const point = pair.getPublic();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyNegate (output, pubkey) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const point = pair.getPublic();
	    point.y = point.y.redNeg();
	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyCombine (output, pubkeys) {
	    const pairs = new Array(pubkeys.length);
	    for (let i = 0; i < pubkeys.length; ++i) {
	      pairs[i] = loadPublicKey(pubkeys[i]);
	      if (pairs[i] === null) return 1
	    }

	    let point = pairs[0].getPublic();
	    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
	    if (point.isInfinity()) return 2

	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyTweakAdd (output, pubkey, tweak) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    tweak = new BN(tweak);
	    if (tweak.cmp(ecparams.n) >= 0) return 2

	    const point = pair.getPublic().add(ecparams.g.mul(tweak));
	    if (point.isInfinity()) return 2

	    savePublicKey(output, point);

	    return 0
	  },

	  publicKeyTweakMul (output, pubkey, tweak) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    tweak = new BN(tweak);
	    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

	    const point = pair.getPublic().mul(tweak);
	    savePublicKey(output, point);

	    return 0
	  },

	  signatureNormalize (sig) {
	    const r = new BN(sig.subarray(0, 32));
	    const s = new BN(sig.subarray(32, 64));
	    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

	    if (s.cmp(ec.nh) === 1) {
	      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);
	    }

	    return 0
	  },

	  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
	  // Adapted for Uint8Array instead Buffer
	  signatureExport (obj, sig) {
	    const sigR = sig.subarray(0, 32);
	    const sigS = sig.subarray(32, 64);
	    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
	    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

	    const { output } = obj;

	    // Prepare R
	    let r = output.subarray(4, 4 + 33);
	    r[0] = 0x00;
	    r.set(sigR, 1);

	    let lenR = 33;
	    let posR = 0;
	    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

	    r = r.subarray(posR);
	    if (r[0] & 0x80) return 1
	    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

	    // Prepare S
	    let s = output.subarray(6 + 33, 6 + 33 + 33);
	    s[0] = 0x00;
	    s.set(sigS, 1);

	    let lenS = 33;
	    let posS = 0;
	    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

	    s = s.subarray(posS);
	    if (s[0] & 0x80) return 1
	    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

	    // Set output length for return
	    obj.outputlen = 6 + lenR + lenS;

	    // Output in specified format
	    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
	    output[0] = 0x30;
	    output[1] = obj.outputlen - 2;
	    output[2] = 0x02;
	    output[3] = r.length;
	    output.set(r, 4);
	    output[4 + lenR] = 0x02;
	    output[5 + lenR] = s.length;
	    output.set(s, 6 + lenR);

	    return 0
	  },

	  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
	  // Adapted for Uint8Array instead Buffer
	  signatureImport (output, sig) {
	    if (sig.length < 8) return 1
	    if (sig.length > 72) return 1
	    if (sig[0] !== 0x30) return 1
	    if (sig[1] !== sig.length - 2) return 1
	    if (sig[2] !== 0x02) return 1

	    const lenR = sig[3];
	    if (lenR === 0) return 1
	    if (5 + lenR >= sig.length) return 1
	    if (sig[4 + lenR] !== 0x02) return 1

	    const lenS = sig[5 + lenR];
	    if (lenS === 0) return 1
	    if ((6 + lenR + lenS) !== sig.length) return 1

	    if (sig[4] & 0x80) return 1
	    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

	    if (sig[lenR + 6] & 0x80) return 1
	    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

	    let sigR = sig.subarray(4, 4 + lenR);
	    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);
	    if (sigR.length > 32) return 1

	    let sigS = sig.subarray(6 + lenR);
	    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);
	    if (sigS.length > 32) throw new Error('S length is too long')

	    let r = new BN(sigR);
	    if (r.cmp(ecparams.n) >= 0) r = new BN(0);

	    let s = new BN(sig.subarray(6 + lenR));
	    if (s.cmp(ecparams.n) >= 0) s = new BN(0);

	    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);
	    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);

	    return 0
	  },

	  ecdsaSign (obj, message, seckey, data, noncefn) {
	    if (noncefn) {
	      const _noncefn = noncefn;
	      noncefn = (counter) => {
	        const nonce = _noncefn(message, seckey, null, data, counter);

	        const isValid = nonce instanceof Uint8Array && nonce.length === 32;
	        if (!isValid) throw new Error('This is the way')

	        return new BN(nonce)
	      };
	    }

	    const d = new BN(seckey);
	    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

	    let sig;
	    try {
	      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
	    } catch (err) {
	      return 1
	    }

	    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);
	    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);
	    obj.recid = sig.recoveryParam;

	    return 0
	  },

	  ecdsaVerify (sig, msg32, pubkey) {
	    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };

	    const sigr = new BN(sigObj.r);
	    const sigs = new BN(sigObj.s);
	    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
	    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 2

	    const point = pair.getPublic();
	    const isValid = ec.verify(msg32, sigObj, point);
	    return isValid ? 0 : 3
	  },

	  ecdsaRecover (output, sig, recid, msg32) {
	    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };

	    const sigr = new BN(sigObj.r);
	    const sigs = new BN(sigObj.s);
	    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

	    if (sigr.isZero() || sigs.isZero()) return 2

	    // Can throw `throw new Error('Unable to find sencond key candinate');`
	    let point;
	    try {
	      point = ec.recoverPubKey(msg32, sigObj, recid);
	    } catch (err) {
	      return 2
	    }

	    savePublicKey(output, point);

	    return 0
	  },

	  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
	    const pair = loadPublicKey(pubkey);
	    if (pair === null) return 1

	    const scalar = new BN(seckey);
	    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

	    const point = pair.getPublic().mul(scalar);

	    if (hashfn === undefined) {
	      const data = point.encode(null, true);
	      const sha256 = ec.hash().update(data).digest();
	      for (let i = 0; i < 32; ++i) output[i] = sha256[i];
	    } else {
	      if (!xbuf) xbuf = new Uint8Array(32);
	      const x = point.getX().toArray('be', 32);
	      for (let i = 0; i < 32; ++i) xbuf[i] = x[i];

	      if (!ybuf) ybuf = new Uint8Array(32);
	      const y = point.getY().toArray('be', 32);
	      for (let i = 0; i < 32; ++i) ybuf[i] = y[i];

	      const hash = hashfn(xbuf, ybuf, data);

	      const isValid = hash instanceof Uint8Array && hash.length === output.length;
	      if (!isValid) return 2

	      output.set(hash);
	    }

	    return 0
	  }
	};

	var elliptic = lib(elliptic$1);

	class PrivKeyFormatException extends Error {
	    constructor(privKey) {
	        super(`Invalid key length. Expected 32, but got ${privKey.length}`);
	    }
	}
	class MissingPrivKeyArgumentException extends Error {
	    constructor() {
	        super(`Missing argument privKey`);
	    }
	}

	function createPublicKey(privKey) {
	    validatePrivKeyFormat(privKey);
	    return require$$0$3.Buffer.from(elliptic.publicKeyCreate(privKey, true).buffer);
	}
	function randomBytes(size) {
	    return cryptoBrowserifyExports.randomBytes(size);
	}
	function sha256(buffer) {
	    return cryptoBrowserifyExports.createHash("sha256").update(buffer).digest();
	}
	const hash256 = sha256;
	function hashConcat(items) {
	    return hash256(require$$0$3.Buffer.concat(items));
	}
	/**
	 * @param content the content that the signature signs. It will be digested before validating.
	 * @param pubKey The pubKey to validate the signature with
	 * @param signature the signature to validate
	 *
	 * @return true if signature ok, false otherwise
	 */
	function checkSignature(content, pubKey, signature) {
	    const digest = hash256(content);
	    return checkDigestSignature(digest, pubKey, signature);
	}
	/**
	 * @param digest the signed digest. It will not be digested before validating.
	 * @param pubKey The pubKey to validate the signature with
	 * @param signature the signature to validate
	 *
	 * @return true if signature ok, false otherwise
	 */
	function checkDigestSignature(digest, pubKey, signature) {
	    if (!signature)
	        return false;
	    return elliptic.ecdsaVerify(signature, digest, pubKey);
	}
	/**
	 * @param content to sign. It will be digested before signing.
	 * @param privKey The private key to sign the content with
	 *
	 * @return the signature
	 */
	function sign$1(content, privKey) {
	    validatePrivKeyFormat(privKey);
	    const digestBuffer = sha256(content);
	    return signDigest(digestBuffer, privKey);
	}
	/**
	 * @param digestBuffer to sign. It will not be digested before signing.
	 * @param privKey The private key to sign the digest with
	 *
	 * @return the signature
	 */
	function signDigest(digestBuffer, privKey) {
	    return require$$0$3.Buffer.from(elliptic.ecdsaSign(digestBuffer, privKey).signature);
	}
	/**
	 * Creates a key pair (which usually represents one user)
	 * @param privKey to create key pair based on
	 * @returns {{pubKey: Buffer, privKey: Buffer}}
	 */
	function makeKeyPair(privKey) {
	    let pubKey;
	    if (privKey) {
	        privKey = ensureBuffer(privKey);
	        pubKey = createPublicKey(privKey);
	    }
	    else {
	        do {
	            privKey = randomBytes(32);
	        } while (!elliptic.privateKeyVerify(privKey));
	        pubKey = require$$0$3.Buffer.from(elliptic.publicKeyCreate(privKey).buffer);
	    }
	    return { pubKey, privKey };
	}
	/**
	 * Generates a 16bytes TUID (Text unique ID) (a 32characters long string)
	 * @returns string
	 */
	function makeTuid() {
	    return randomBytes(16).toString("hex");
	}
	/**
	 * Verify that keypair is correct. Providing the private key, this function returns its associated public key
	 * @param privKey: Buffer
	 * @returns {{pubKey: Buffer, privKey: Buffer}}
	 */
	function verifyKeyPair(privKey) {
	    validatePrivKeyFormat(privKey);
	    const pubKey = require$$0$3.Buffer.from(elliptic.publicKeyCreate(privKey).buffer);
	    return { pubKey, privKey };
	}
	function validatePrivKeyFormat(privKey) {
	    if (!privKey) {
	        throw new MissingPrivKeyArgumentException();
	    }
	    if (!require$$0$3.Buffer.isBuffer(privKey) || privKey.length !== 32) {
	        throw new PrivKeyFormatException(privKey);
	    }
	}

	var encryption$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		checkDigestSignature: checkDigestSignature,
		checkSignature: checkSignature,
		createPublicKey: createPublicKey,
		hash256: hash256,
		hashConcat: hashConcat,
		makeKeyPair: makeKeyPair,
		makeTuid: makeTuid,
		randomBytes: randomBytes,
		sha256: sha256,
		sign: sign$1,
		signDigest: signDigest,
		verifyKeyPair: verifyKeyPair
	});

	var require$$3 = /*@__PURE__*/getAugmentedNamespace(encryption$1);

	const { Buffer: Buffer$2 } = require$$0$3;
	var serialization = require$$1$2;
	var HASH_PREFIX_LEAF = binarytree.HASH_PREFIX_LEAF;
	var encryption = require$$3;
	function CryptoSystem() { }
	CryptoSystem.prototype.digest = function (buffer) {
	    return encryption.hash256(buffer);
	};
	/**
	 *
	 * @param {Buffer} buffer
	 * @param {CryptoSystem} cryptoSystem
	 */
	function hashingFun(buffer, cryptoSystem) {
	    if (cryptoSystem === null) {
	        throw new Error("In this case we need the CryptoSystem to calculate the hash");
	    }
	    else {
	        return cryptoSystem.digest(buffer);
	    }
	}
	/**
	 *
	 * @param {CryptoSystem} cryptoSystem
	 */
	function MerkleHashCalculator(cryptoSystem) {
	    this.cryptoSystem = cryptoSystem;
	}
	/**
	 * @param {number} prefix
	 * @param {Buffer} hashLeft
	 * @param {Buffer} hashRight
	 */
	MerkleHashCalculator.prototype.calculateNodeHash = function (prefix, hashLeft, hashRight) {
	    return this.calculateNodeHashInternal(prefix, hashLeft, hashRight, hashingFun);
	};
	/**
	 * @param {*} value
	 */
	MerkleHashCalculator.prototype.calculateLeafHash = function (value) {
	    return this.calculateHashOfValueInternal(value, serialization.encodeValue, hashingFun);
	};
	/**
	 * @param {number} prefix
	 * @param {Buffer} hashLeft
	 * @param {Buffer} hashRight
	 */
	MerkleHashCalculator.prototype.calculateNodeHashInternal = function (prefix, hashLeft, hashRight, hashFunc) {
	    var buf = Buffer$2.alloc(1);
	    buf.writeInt8(prefix);
	    var bufferSum = Buffer$2.concat([buf, hashLeft, hashRight]);
	    return hashFunc(bufferSum, this.cryptoSystem);
	};
	MerkleHashCalculator.prototype.calculateHashOfValueInternal = function (valuetoHash, serializeFun, hashFunc) {
	    var buf = Buffer$2.alloc(1);
	    buf.writeInt8(HASH_PREFIX_LEAF);
	    var bufferSum = Buffer$2.concat([buf, serializeFun(valuetoHash)]);
	    return hashFunc(bufferSum, this.cryptoSystem);
	};
	MerkleHashCalculator.prototype.isContainerProofValueLeaf = function (value) {
	    if (value == null) {
	        return false;
	    }
	    if (value.constructor === Array || typeof value === 'object') {
	        return true;
	    }
	    else {
	        return false;
	    }
	};
	var merklehashcalculator = { MerkleHashCalculator, CryptoSystem };

	var util$1 = require$$0$1;
	const { Buffer: Buffer$1 } = require$$0$3;
	var PathSet = path.PathSet;
	var PathLeafElement$1 = path.PathLeafElement;
	var EmptyLeaf$1 = binarytree.EmptyLeaf;
	var Leaf$1 = binarytree.Leaf;
	var Node$1 = binarytree.Node;
	var BinaryTree = binarytree.BinaryTree;
	var ArrayHeadNode$1 = binarytree.ArrayHeadNode;
	var DictHeadNode$1 = binarytree.DictHeadNode;
	const NO_PATHS = new PathSet([]);
	/**
	 * The factory does the conversion between list of elements and tree of elements.
	 *
	 * Note: The idea is that you should sub class for each type of element you want to build.
	 */
	function BinaryTreeFactory$1() { }
	/**
	 * Transforms the incoming leaf into an [BinaryTreeElement]
	 * The idea with this function is that it can be recursive (if the leaf in turn is complex object with sub objects).
	 *
	 * Note: If we don't have a path here we can try to find the leaf in the cache.
	 *
	 * @param leaf the raw data we should wrap in a leaf
	 * @param paths a collection of proof paths that might point to this leaf
	 * @return the resulting [BinaryTreeElement] the leaf got converted to
	 */
	BinaryTreeFactory$1.prototype.handleLeaf = function (leaf, paths, isRoot = false) {
	    if (paths.length == 0 && !isRoot) {
	        return this.innerHandleLeaf(leaf, this.getEmptyPathSet());
	    }
	    else {
	        return this.innerHandleLeaf(leaf, paths);
	    }
	};
	/**
	 *
	 */
	BinaryTreeFactory$1.prototype.getEmptyPathSet = function () {
	    return NO_PATHS;
	};
	/**
	 * At this point we should have looked in cache.
	 *
	 * @param leaf we should turn into a tree element
	 * @param {PathSet} paths
	 * @return the tree element we created.
	 */
	BinaryTreeFactory$1.prototype.innerHandleLeaf = function (leaf, paths) {
	    if (leaf == null) {
	        return this.handlePrimitiveLeaf(leaf, paths);
	    }
	    if (Buffer$1.isBuffer(leaf)) {
	        return this.handlePrimitiveLeaf(leaf, paths);
	    }
	    if (typeof leaf === 'string') {
	        return this.handlePrimitiveLeaf(leaf, paths);
	    }
	    if (typeof leaf === 'number') {
	        return this.handlePrimitiveLeaf(leaf, paths);
	    }
	    if (typeof leaf === 'bigint') {
	        return this.handlePrimitiveLeaf(leaf, paths);
	    }
	    if (typeof leaf === 'boolean') {
	        return this.handlePrimitiveLeaf(leaf ? 1 : 0, paths);
	    }
	    if (leaf.constructor === Array) {
	        return this.buildFromArray(leaf, paths);
	    }
	    if (typeof leaf === 'object') {
	        return this.buildFromDictionary(leaf, paths);
	    }
	    else {
	        throw new Error("Unsupporting data type");
	    }
	};
	/**
	 * Just like [handleLeaf] but we know that this leaf should not be a complex type, but something we can
	 * immediately wrap
	 *
	 * @param leaf
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.handlePrimitiveLeaf = function (leaf, paths) {
	    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
	    if (pathElem != null && !(pathElem instanceof PathLeafElement$1)) {
	        throw new Error("Path does not match the tree structure. We are at a leaf " + leaf + " but found path element " + pathElem);
	    }
	    return new Leaf$1(leaf, pathElem);
	};
	/**
	 * Calls itself until the return value only holds 1 element
	 *
	 * Note: This method can only create standard [Node] that fills up the area between the "top" and the leaves.
	 *        These "in-between" nodes cannot be "path leaf" or have any interesting properties.
	 *
	 * @param layer What layer we aim calculate
	 * @param inList The args of nodes we should build from
	 * @return All [BinaryTreeElement] nodes of the next layer
	 */
	BinaryTreeFactory$1.prototype.buildHigherLayer = function (layer, inList) {
	    if (inList.length === 0) {
	        throw new Error("Cannot work on empty arrays. Layer: " + layer);
	    }
	    else if (inList.length === 1) {
	        return inList;
	    }
	    var returnArray = new Array();
	    var nrOfNodesToCreate = Math.floor(inList.length / 2);
	    var leftValue = null;
	    var isLeft = true;
	    for (var i = 0; i < inList.length; i++) {
	        if (isLeft) {
	            leftValue = inList[i];
	            isLeft = false;
	        }
	        else {
	            var tempNode = new Node$1(leftValue, inList[i]);
	            returnArray.push(tempNode);
	            nrOfNodesToCreate--;
	            isLeft = true;
	            leftValue = null;
	        }
	    }
	    if (!isLeft) {
	        // If there is odd number of nodes, then move the last node up one level
	        returnArray.push(leftValue);
	    }
	    // Extra check
	    if (nrOfNodesToCreate != 0) {
	        util$1.logDebug("Why didn't we build exactly the correct amount? Layer: " + layer + " , residue: " + nrOfNodesToCreate + " , input args size: " + inList.length + ".");
	    }
	    return this.buildHigherLayer((layer + 1), returnArray);
	};
	BinaryTreeFactory$1.prototype.build = function (data) {
	    return this.buildWithPath(data, NO_PATHS);
	};
	/**
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.buildWithPath = function (data, paths) {
	    var result = this.handleLeaf(data, paths, true);
	    return new BinaryTree(result);
	};
	/**
	 * @param {Array} array
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.buildFromArray = function (array, paths) {
	    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
	    // 1. Build leaf layer
	    if (array.length == 0) {
	        return new ArrayHeadNode$1(new EmptyLeaf$1(), new EmptyLeaf$1(), array, 0, 0, pathElem);
	    }
	    var leafArray = this.buildLeafElements(array, paths);
	    // 2. Build all higher layers
	    var result = this.buildHigherLayer(1, leafArray);
	    // 3. Fix and return the root node
	    var orgRoot = result[0];
	    if (orgRoot instanceof Node$1) {
	        return new ArrayHeadNode$1(orgRoot.left, orgRoot.right, array, array.length, pathElem);
	    }
	    if (orgRoot instanceof Leaf$1) {
	        return this.buildFromOneLeaf(array, orgRoot, pathElem);
	    }
	    else {
	        throw new Error("Should not find element of this type here");
	    }
	};
	/**
	 *
	 */
	BinaryTreeFactory$1.prototype.buildFromOneLeaf = function (array, orgRoot, pathElem) {
	    if (array.length > 1) {
	        throw new Error("How come we got a leaf returned when we had " + array.length + " elements is the args?");
	    }
	    else {
	        return new ArrayHeadNode$1(orgRoot, new EmptyLeaf$1(), array, array.length, pathElem);
	    }
	};
	/**
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.buildLeafElements = function (leafList, paths) {
	    var leafArray = new Array();
	    var onlyArrayPaths = paths.keepOnlyArrayPaths(); // For performance, since we will loop soon
	    for (var i = 0; i < leafList.length; i++) {
	        var pathsRelevantForThisLeaf = onlyArrayPaths.getTailIfFirstElementIsArrayOfThisIndexFromList(i);
	        var leaf = leafList[i];
	        var binaryTreeElement = this.handleLeaf(leaf, pathsRelevantForThisLeaf);
	        leafArray.push(binaryTreeElement);
	    }
	    return leafArray;
	};
	/**
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.buildFromDictionary = function (dict, paths) {
	    var pathElem = paths.getPathLeafOrElseAnyCurrentPathElement();
	    // Needs to be sorted, or else the order is undefined
	    var keys = Object.keys(dict).sort();
	    if (keys.length == 0) {
	        return new DictHeadNode$1(new EmptyLeaf$1(), new EmptyLeaf$1(), dict, keys.length, 0, pathElem);
	    }
	    // 1. Build first (leaf) layer
	    var leafArray = this.buildLeafElementFromDict(keys, dict, paths);
	    // 2. Build all higher layers
	    var result = this.buildHigherLayer(1, leafArray);
	    // 3. Fix and return the root node
	    var orgRoot = result[0];
	    if (orgRoot instanceof Node$1) {
	        return new DictHeadNode$1(orgRoot.left, orgRoot.right, dict, keys.length, pathElem);
	    }
	    else {
	        throw new Error("Should not find element of this type here: " + typeof orgRoot);
	    }
	};
	/**
	 * @param {PathSet} paths
	 */
	BinaryTreeFactory$1.prototype.buildLeafElementFromDict = function (keys, dict, paths) {
	    var leafArray = new Array();
	    var onlyDictPaths = paths.keepOnlyDictPaths(); // For performance, since we will loop soon
	    for (var i = 0; i < keys.length; i++) {
	        // The key cannot not be proved, so NO_PATHS
	        var key = keys[i];
	        var keyElement = this.handleLeaf(key, NO_PATHS);
	        leafArray.push(keyElement);
	        var content = dict[key];
	        var pathsRelevantForThisLeaf = onlyDictPaths.getTailIfFirstElementIsDictOfThisKeyFromList(key);
	        var contentElement = this.handleLeaf(content, pathsRelevantForThisLeaf);
	        leafArray.push(contentElement);
	    }
	    return leafArray;
	};
	var binarytreefactory = { BinaryTreeFactory: BinaryTreeFactory$1 };

	path.SearchablePathElement;
	var HASH_PREFIX_NODE = binarytree.HASH_PREFIX_NODE;
	var HASH_PREFIX_NODE_ARRAY = binarytree.HASH_PREFIX_NODE_ARRAY;
	var HASH_PREFIX_NODE_DICT = binarytree.HASH_PREFIX_NODE_DICT;
	/**
	 *
	 */
	function MerkleProofElement() { }
	/**
	 *
	 * @param {Buffer} prefix
	 * @param {MerkleProofElement} left
	 * @param {MerkleProofElement} right
	 */
	function ProofNode$1(prefix, left, right) {
	    this.prefix = prefix;
	    this.left = left;
	    this.right = right;
	}
	ProofNode$1.prototype = Object.create(MerkleProofElement.prototype);
	ProofNode$1.prototype.constructor = ProofNode$1;
	/**
	 *
	 * @param {MerkleProofElement} left
	 * @param {MerkleProofElement} right
	 */
	function ProofNodeSimple$1(left, right) {
	    ProofNode$1.call(this, HASH_PREFIX_NODE, left, right);
	}
	ProofNodeSimple$1.prototype = Object.create(ProofNode$1.prototype);
	ProofNodeSimple$1.prototype.constructor = ProofNodeSimple$1;
	/**
	 *
	 * @param {*} content
	 * @param {SearchablePathElement} pathElem
	 */
	function ProofValueLeaf$2(content, pathElem) {
	    this.content = content;
	    this.pathElem = pathElem;
	}
	ProofValueLeaf$2.prototype = Object.create(MerkleProofElement.prototype);
	ProofValueLeaf$2.prototype.constructor = ProofValueLeaf$2;
	/**
	 *
	 * @param {Buffer} merkleHash
	 */
	function ProofHashedLeaf$2(merkleHash) {
	    this.merkleHash = merkleHash;
	}
	ProofHashedLeaf$2.prototype = Object.create(MerkleProofElement.prototype);
	ProofHashedLeaf$2.prototype.constructor = ProofHashedLeaf$2;
	/**
	 * @param {ProofHashedLeaf} other
	 */
	ProofHashedLeaf$2.prototype.equals = function (other) {
	    if (other instanceof ProofHashedLeaf$2) {
	        return this.merkleHash.equals(other.merkleHash);
	    }
	    else {
	        return false;
	    }
	};
	/**
	 *
	 * @param {MerkleProofElement} left
	 * @param {MerkleProofElement} right
	 * @param {SearchablePathElement} pathElem
	 */
	function ProofNodeArrayHead$1(left, right, pathElem = null) {
	    ProofNode$1.call(this, HASH_PREFIX_NODE_ARRAY, left, right);
	    this.pathElem = pathElem;
	}
	ProofNodeArrayHead$1.prototype = Object.create(ProofNode$1.prototype);
	ProofNodeArrayHead$1.prototype.constructor = ProofNodeArrayHead$1;
	/**
	 *
	 * @param {MerkleProofElement} left
	 * @param {MerkleProofElement} right
	 * @param {SearchablePathElement} pathElem
	 */
	function ProofNodeDictHead$1(left, right, pathElem = null) {
	    ProofNode$1.call(this, HASH_PREFIX_NODE_DICT, left, right);
	    this.pathElem = pathElem;
	}
	ProofNodeDictHead$1.prototype = Object.create(ProofNode$1.prototype);
	ProofNodeDictHead$1.prototype.constructor = ProofNodeDictHead$1;
	/**
	 *
	 * @param {MerkleProofElement} root
	 */
	function MerkleProofTree$1(root) {
	    this.root = root;
	}
	MerkleProofTree$1.prototype.maxLevel = function () {
	    return this.maxLevelInternal(this.root);
	};
	/**
	 * @param {MerkleProofElement} node
	 */
	MerkleProofTree$1.prototype.maxLevelInternal = function (node) {
	    if (node instanceof ProofValueLeaf$2) {
	        return 1;
	    }
	    else if (node instanceof ProofHashedLeaf$2) {
	        return 1;
	    }
	    else if (node instanceof ProofNode$1) {
	        return Math.max(this.maxLevelInternal(node.left), this.maxLevelInternal(node.right)) + 1;
	    }
	    else {
	        throw new Error("Should be able to handle node type: " + typeof node);
	    }
	};
	var merkleprooftree = { ProofNode: ProofNode$1, ProofNodeSimple: ProofNodeSimple$1, ProofHashedLeaf: ProofHashedLeaf$2, ProofValueLeaf: ProofValueLeaf$2,
	    ProofNodeArrayHead: ProofNodeArrayHead$1, ProofNodeDictHead: ProofNodeDictHead$1, MerkleProofElement, MerkleProofTree: MerkleProofTree$1 };

	const { Buffer } = require$$0$3;
	binarytree.BinaryTreeElement;
	var Node = binarytree.Node;
	var Leaf = binarytree.Leaf;
	var EmptyLeaf = binarytree.EmptyLeaf;
	binarytree.BinaryTree;
	var ProofHashedLeaf$1 = merkleprooftree.ProofHashedLeaf;
	var ProofValueLeaf$1 = merkleprooftree.ProofValueLeaf;
	merkleprooftree.MerkleProofElement;
	var MerkleProofTree = merkleprooftree.MerkleProofTree;
	var ProofNodeArrayHead = merkleprooftree.ProofNodeArrayHead;
	var ProofNodeDictHead = merkleprooftree.ProofNodeDictHead;
	var PathLeafElement = path.PathLeafElement;
	var SubTreeRootNode = binarytree.SubTreeRootNode;
	var ArrayHeadNode = binarytree.ArrayHeadNode;
	var DictHeadNode = binarytree.DictHeadNode;
	var ProofNodeSimple = merkleprooftree.ProofNodeSimple;
	const EMPTY_HASH = new Buffer.alloc(32);
	/**
	 *
	 */
	function MerkleProofTreeFactory$1() { }
	/**
	 * @param {BinaryTree} orginalTree
	 */
	MerkleProofTreeFactory$1.prototype.buildFromBinaryTree = function (orginalTree, calculator) {
	    var rootElem = this.buildFromBinaryTreeInternal(orginalTree.root, calculator);
	    return new MerkleProofTree(rootElem);
	};
	/**
	 * @param {BinaryTreeElement} elem
	 * @param {*} calculator
	 */
	MerkleProofTreeFactory$1.prototype.buildFromBinaryTreeInternal = function (elem, calculator) {
	    if (elem instanceof EmptyLeaf) {
	        return new ProofHashedLeaf$1(EMPTY_HASH);
	    }
	    else if (elem instanceof Leaf) {
	        var pathElem = elem.pathElem;
	        if (pathElem != null) {
	            if (pathElem instanceof PathLeafElement) {
	                return new ProofValueLeaf$1(elem.content, pathElem.previous);
	            }
	            else {
	                throw new Error("The path and structure don't match. We are at a leaf, but path elem is not a leaf: " + pathElem);
	            }
	        }
	        else {
	            // make a hash
	            var hash = calculator.calculateLeafHash(elem.content);
	            return new ProofHashedLeaf$1(hash);
	        }
	    }
	    else if (elem instanceof SubTreeRootNode) {
	        var pathElem = elem.pathElem;
	        if (pathElem != null) {
	            if (pathElem instanceof PathLeafElement) {
	                // Don't convert it
	                return new ProofValueLeaf$1(elem.content, pathElem.previous);
	            }
	            else {
	                return this.convertNode(elem, calculator);
	            }
	        }
	        else {
	            return this.convertNode(elem, calculator);
	        }
	    }
	    else if (elem instanceof Node) {
	        return this.convertNode(elem, calculator);
	    }
	    else {
	        throw new Error("Cannot handle " + elem);
	    }
	};
	/**
	 * @param {Node} node
	 */
	MerkleProofTreeFactory$1.prototype.convertNode = function (node, calculator) {
	    var left = this.buildFromBinaryTreeInternal(node.left, calculator);
	    var right = this.buildFromBinaryTreeInternal(node.right, calculator);
	    if (left instanceof ProofHashedLeaf$1 && right instanceof ProofHashedLeaf$1) {
	        var addedHash = calculator.calculateNodeHash(node.getPrefixByte(), left.merkleHash, right.merkleHash);
	        return new ProofHashedLeaf$1(addedHash);
	    }
	    else {
	        return this.buildNodeOfCorrectType(node, left, right);
	    }
	};
	/**
	 * @param {ArrayHeadNode} node
	 */
	MerkleProofTreeFactory$1.prototype.extractSearchablePathElement = function (node) {
	    var pathElem = node.pathElem;
	    if (pathElem != null) {
	        return pathElem.previous;
	    }
	    else {
	        return null;
	    }
	};
	/**
	 * @param {Node} node
	 * @param {MerkleProofElement} left
	 * @param {MerkleProofElement} right
	 */
	MerkleProofTreeFactory$1.prototype.buildNodeOfCorrectType = function (node, left, right) {
	    if (node instanceof ArrayHeadNode) {
	        return new ProofNodeArrayHead(left, right, this.extractSearchablePathElement(node));
	    }
	    else if (node instanceof DictHeadNode) {
	        return new ProofNodeDictHead(left, right, this.extractSearchablePathElement(node));
	    }
	    else if (node instanceof Node) {
	        return new ProofNodeSimple(left, right);
	    }
	    else {
	        throw new Error("Should have taken care of this node type: " + node);
	    }
	};
	var merkleprooftreefactory = { MerkleProofTreeFactory: MerkleProofTreeFactory$1 };

	/**
	 *
	 * @param {Buffer} merkleHash
	 */
	function MerkleHashSummary$1(merkleHash) {
	    this.merkleHash = merkleHash;
	}
	/**
	 * @param {MerkleHashSummary} other
	 */
	MerkleHashSummary$1.prototype.equals = function (other) {
	    if (this === other)
	        return true;
	    if (typeof this != typeof other)
	        return false;
	    if (this.merkleHash.compare(other.merkleHash) === 0) {
	        return true;
	    }
	    return false;
	};
	var merklehashcarrier = { MerkleHashSummary: MerkleHashSummary$1 };

	binarytreefactory.BinaryTreeFactory;
	merkleprooftreefactory.MerkleProofTreeFactory;
	merklehashcalculator.MerkleHashCalculator;
	merkleprooftree.MerkleProofTree;
	merkleprooftree.MerkleProofElement;
	var ProofHashedLeaf = merkleprooftree.ProofHashedLeaf;
	var ProofValueLeaf = merkleprooftree.ProofValueLeaf;
	var ProofNode = merkleprooftree.ProofNode;
	var MerkleHashSummary = merklehashcarrier.MerkleHashSummary;
	/**
	 *
	 * @param {BinaryTreeFactory} treeFactory
	 * @param {MerkleProofTreeFactory} proofFactory
	 */
	function MerkleHashSummaryFactory$1(treeFactory, proofFactory) {
	    this.treeFactory = treeFactory;
	    this.proofFactory = proofFactory;
	}
	/**
	 * @param {any} value
	 * @param {MerkleHashCalculator} calculator
	 */
	MerkleHashSummaryFactory$1.prototype.calculateMerkleRoot = function (value, calculator) {
	    var binaryTree = this.treeFactory.build(value);
	    var proofTree = this.proofFactory.buildFromBinaryTree(binaryTree, calculator);
	    return this.calculateMerkleRootOfTree(proofTree, calculator);
	};
	/**
	 * @param {MerkleProofTree} value
	 * @param {MerkleHashCalculator} calculator
	 */
	MerkleHashSummaryFactory$1.prototype.calculateMerkleTreeRoot = function (tree, calculator) {
	    return this.calculateMerkleRootOfTree(tree, calculator);
	};
	/**
	 * @param {MerkleProofTree} proofTree
	 * @param {MerkleHashCalculator} calculator
	 */
	MerkleHashSummaryFactory$1.prototype.calculateMerkleRootOfTree = function (proofTree, calculator) {
	    var calculatedSummary = this.calculateMerkleRootInternal(proofTree.root, calculator);
	    return new MerkleHashSummary(calculatedSummary);
	};
	/**
	 * @param {MerkleProofElement} currentElement
	 * @param {MerkleHashCalculator} calculator
	 */
	MerkleHashSummaryFactory$1.prototype.calculateMerkleRootInternal = function (currentElement, calculator) {
	    if (currentElement instanceof ProofHashedLeaf) {
	        return currentElement.merkleHash;
	    }
	    else if (currentElement instanceof ProofValueLeaf) {
	        var value = currentElement.content;
	        if (calculator.isContainerProofValueLeaf(value)) {
	            // We have a container value to prove, so need to convert the value to a binary tree, and THEN hash it
	            var merkleProofTree = this.buildProofTree(value, calculator);
	            return this.calculateMerkleRootInternal(merkleProofTree.root, calculator);
	        }
	        else {
	            // This is a primitive value, just hash it
	            return calculator.calculateLeafHash(value);
	        }
	    }
	    else if (currentElement instanceof ProofNode) {
	        var left = this.calculateMerkleRootInternal(currentElement.left, calculator);
	        var right = this.calculateMerkleRootInternal(currentElement.right, calculator);
	        return calculator.calculateNodeHash(currentElement.prefix, left, right);
	    }
	    else {
	        throw new Error("Should have handled this type? " + typeof currentElement);
	    }
	};
	/**
	 * @param {any} value
	 * @param {MerkleHashCalculator} calculator
	 */
	MerkleHashSummaryFactory$1.prototype.buildProofTree = function (value, calculator) {
	    var root = this.treeFactory.build(value);
	    return this.proofFactory.buildFromBinaryTree(root, calculator);
	};
	var merklehashsummaryfactory = { MerkleHashSummaryFactory: MerkleHashSummaryFactory$1 };

	merklehashcalculator.MerkleHashCalculator;
	var MerkleHashSummaryFactory = merklehashsummaryfactory.MerkleHashSummaryFactory;
	var BinaryTreeFactory = binarytreefactory.BinaryTreeFactory;
	var MerkleProofTreeFactory = merkleprooftreefactory.MerkleProofTreeFactory;
	var treeFactory = new BinaryTreeFactory();
	var proofFactory = new MerkleProofTreeFactory();
	path.PathSet;
	merkleprooftree.MerkleProofTree;
	/**
	 * Calculates the merkle root hash of the structure.
	 *
	 * @param {any} value
	 * @param {MerkleHashCalculator} calculator describes the method we use for hashing and serialization
	 * @return the merkle root hash (32 bytes) of the data structure.
	 */
	function merkleHash(value, calculator) {
	    return merkleHashSummary(value, calculator).merkleHash;
	}
	/**
	 *
	 * @param {MerkleProofTree} tree
	 * @param {MerkleHashCalculator} calculator
	 */
	function merkleTreeHash(tree, calculator) {
	    return merkleProofHashSummary(tree, calculator).merkleHash;
	}
	/**
	 * Calculates the merkle root hash of the structure
	 *
	 * @param {any} value
	 * @param {MerkleHashCalculator} calculator describes the method we use for hashing and serialization
	 * @return the merkle root hash summary
	 */
	function merkleHashSummary(value, calculator) {
	    var summaryFactory = new MerkleHashSummaryFactory(treeFactory, proofFactory);
	    return summaryFactory.calculateMerkleRoot(value, calculator);
	}
	/**
	 *
	 * @param {MerkleProofTree} tree
	 * @param {MerkleHashCalculator} calculator
	 */
	function merkleProofHashSummary(tree, calculator) {
	    var summaryFactory = new MerkleHashSummaryFactory(treeFactory, proofFactory);
	    return summaryFactory.calculateMerkleTreeRoot(tree, calculator);
	}
	/**
	 *
	 * @param {any} value
	 * @param {PathSet} pathSet
	 * @param {MerkleHashCalculator} calculator
	 */
	function generateProof(value, pathSet, calculator) {
	    var binaryTree = treeFactory.buildWithPath(value, pathSet);
	    return proofFactory.buildFromBinaryTree(binaryTree, calculator);
	}
	var merkleproof = { merkleHash, merkleTreeHash, merkleHashSummary, generateProof };

	const theMerkleHashCalculator = new merklehashcalculator.MerkleHashCalculator(new merklehashcalculator.CryptoSystem());
	const gtvHash = (obj) => {
	    return merkleproof.merkleHashSummary(obj, theMerkleHashCalculator).merkleHash;
	};
	const encode$1 = encodeValue;
	const decode$1 = decodeValue;

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		decode: decode$1,
		encode: encode$1,
		gtvHash: gtvHash
	});

	const encode = encodeValueGtx;
	const decode = decodeValueGtx;

	var __awaiter$c = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function emptyGtx(blockchainRid) {
	    return { blockchainRid, operations: [], signers: [] };
	}
	/**
	 * Adds a function call to a GTX. Creates a new GTX if none specified.
	 * This function will throw Error if gtx is already signed
	 * @param opName the name of the function to call
	 * @param args the array of arguments of the function call. If no args, this must be an empty array
	 * @param gtx the function call will be added to this gtx
	 * @returns the gtx
	 * @throws if gtx is null or if gtx is already signed
	 */
	function addTransactionToGtx(opName, args, gtx) {
	    if (gtx == null) {
	        throw new MissingGtxException();
	    }
	    if (gtx.signatures) {
	        throw new AlreadySignedTransactionException("function");
	    }
	    gtx.operations.push({ opName: opName, args: args });
	    return gtx;
	}
	function addSignerToGtx(signer, gtx) {
	    if (gtx.signatures) {
	        throw new AlreadySignedTransactionException("signer");
	    }
	    gtx.signers.push(signer);
	}
	/**
	 * Serializes the gtx to get tx hash
	 * @param gtx the gtx to serialize
	 */
	function getDigest(gtx) {
	    return gtvHash(gtxToRawGtx(gtx));
	}
	/**
	 * Serializes the gtx for signing
	 * @param gtx the gtx to serialize
	 */
	function getDigestToSign(gtx) {
	    return gtvHash(gtxToRawGtxBody(gtx));
	}
	function getDigestToSignFromRawGtxBody(gtxBody) {
	    return gtvHash(gtxBody);
	}
	function gtxToRawGtxBody(gtx) {
	    return [
	        gtx.blockchainRid,
	        gtx.operations.map((op) => [op.opName, op.args]),
	        gtx.signers,
	    ];
	}
	function gtxToRawGtx(gtx) {
	    var _a;
	    return [
	        [
	            gtx.blockchainRid,
	            gtx.operations.map((op) => [op.opName, op.args]),
	            gtx.signers,
	        ],
	        (_a = gtx.signatures) !== null && _a !== void 0 ? _a : [],
	    ];
	}
	function sign(gtx, privOrSigProv, pubKey) {
	    return __awaiter$c(this, void 0, void 0, function* () {
	        if (privOrSigProv instanceof require$$0$3.Buffer) {
	            const digestToSign = getDigestToSign(gtx);
	            const signature = signDigest(digestToSign, privOrSigProv);
	            return addSignature(pubKey || makeKeyPair(privOrSigProv).pubKey, signature, gtx);
	        }
	        else {
	            // Removes signatures and extract the rawgtxBody
	            const rawGtxBody = gtxToRawGtxBody(gtx);
	            const signature = yield privOrSigProv.sign(rawGtxBody);
	            return addSignature(privOrSigProv.pubKey, signature, gtx);
	        }
	    });
	}
	function signRawTransaction(_keyPair, _rawTransaction) {
	    throw Error("TODO");
	    //TODO
	    //const gtx = module.exports.deserialize(rawTransaction);
	    //module.exports.sign(keyPair.privKey, keyPair.pubKey, gtx);
	    // return module.exports.serialize(gtx)
	}
	/**
	 * Adds a signature to the gtx
	 */
	function addSignature(pubKeyBuffer, signatureBuffer, gtx) {
	    if (!gtx.signatures) {
	        gtx.signatures = Array(gtx.signers.length);
	    }
	    const signerIndex = gtx.signers.findIndex((signer) => pubKeyBuffer.equals(signer));
	    if (signerIndex === -1) {
	        throw new MissingSignerException();
	    }
	    gtx.signatures[signerIndex] = signatureBuffer;
	    return gtx;
	}
	function serialize(gtx) {
	    if (!gtx.signatures) {
	        // TODO
	        // The gtx is not signed, but we must include
	        // the signatures attribute, so let's add that.
	        gtx.signatures = [];
	    }
	    return encode([gtxToRawGtxBody(gtx), gtx.signatures]);
	}
	function deserialize(gtxBytes) {
	    const deserializedTx = decode(gtxBytes);
	    const body = deserializedTx[0];
	    const gtvTxBody = {
	        blockchainRid: body[0],
	        operations: body[1].map((operation) => ({
	            opName: operation[0],
	            args: operation[1],
	        })),
	        signers: body[2],
	    };
	    const signatures = deserializedTx[1];
	    return {
	        blockchainRid: gtvTxBody.blockchainRid,
	        operations: gtvTxBody.operations,
	        signers: gtvTxBody.signers,
	        signatures,
	    };
	}
	function checkGTXSignatures(txHash, gtx) {
	    var _a;
	    for (const i in gtx.signers) {
	        const signValid = checkDigestSignature(txHash, gtx.signers[i], (_a = gtx.signatures) === null || _a === void 0 ? void 0 : _a[i]);
	        if (!signValid)
	            return signValid;
	    }
	    return true;
	}
	function checkExistingGTXSignatures(txHash, gtx) {
	    var _a;
	    for (const i in gtx.signers) {
	        if ((_a = gtx.signatures) === null || _a === void 0 ? void 0 : _a[i]) {
	            const signValid = checkDigestSignature(txHash, gtx.signers[i], gtx.signatures[i]);
	            if (!signValid)
	                return signValid;
	        }
	    }
	    return true;
	}
	function newSignatureProvider(keyPair) {
	    let pub, priv;
	    if (keyPair) {
	        priv = ensureBuffer(keyPair.privKey);
	        pub = keyPair.pubKey ? ensureBuffer(keyPair.pubKey) : createPublicKey(priv);
	    }
	    else {
	        ({ privKey: priv, pubKey: pub } = makeKeyPair());
	    }
	    return {
	        pubKey: pub,
	        sign: (gtx) => __awaiter$c(this, void 0, void 0, function* () {
	            const signature = getDigestToSignFromRawGtxBody(gtx);
	            return signDigest(signature, priv);
	        }),
	    };
	}
	function rawGtvToGtx(gtv) {
	    if (Array.isArray(gtv) && gtv.length !== 2) {
	        throw new Error("Gtv must be an array of size 2");
	    }
	    const gtvArray = gtv;
	    if (!Array.isArray(gtvArray[0])) {
	        throw new Error("First element must be an array");
	    }
	    if (!Array.isArray(gtvArray[1])) {
	        throw new Error("Second element must be an array");
	    }
	    gtvArray[1].forEach((element) => {
	        if (!require$$0$3.Buffer.isBuffer(element)) {
	            throw new Error("Element must be a buffer");
	        }
	    });
	    const gtxBody = rawGtvToGtxBody(gtvArray[0]);
	    return Object.assign(Object.assign({}, gtxBody), { signatures: gtvArray[1] });
	}
	function rawGtvToGtxBody(gtv) {
	    if (Array.isArray(gtv) && gtv.length !== 3) {
	        throw new Error("Gtv must be an array of size 3");
	    }
	    const array = gtv;
	    if (!require$$0$3.Buffer.isBuffer(array[0])) {
	        throw new Error("First element must be a byte array");
	    }
	    if (!Array.isArray(array[1])) {
	        throw new Error("Second element must be an array");
	    }
	    if (!Array.isArray(array[2])) {
	        throw new Error("Third element must be an array");
	    }
	    array[2].forEach((element) => {
	        if (!require$$0$3.Buffer.isBuffer(element)) {
	            throw new Error("Element must be a buffer");
	        }
	    });
	    return {
	        blockchainRid: array[0],
	        operations: array[1].map((element) => rawGtvToRellOp(element)),
	        signers: array[2],
	    };
	}
	function rawGtvToRellOp(gtv) {
	    if (Array.isArray(gtv) && gtv.length !== 2) {
	        throw new Error("Gtv must be an array of size 2");
	    }
	    const array = gtv;
	    if (typeof array[0] !== "string") {
	        throw new Error("First element must be a string");
	    }
	    if (!Array.isArray(array[1])) {
	        throw new Error("Second element must be an array");
	    }
	    return { opName: array[0], args: array[1] };
	}

	var gtx = /*#__PURE__*/Object.freeze({
		__proto__: null,
		addSignature: addSignature,
		addSignerToGtx: addSignerToGtx,
		addTransactionToGtx: addTransactionToGtx,
		checkExistingGTXSignatures: checkExistingGTXSignatures,
		checkGTXSignatures: checkGTXSignatures,
		deserialize: deserialize,
		emptyGtx: emptyGtx,
		getDigest: getDigest,
		getDigestToSign: getDigestToSign,
		getDigestToSignFromRawGtxBody: getDigestToSignFromRawGtxBody,
		gtxToRawGtx: gtxToRawGtx,
		gtxToRawGtxBody: gtxToRawGtxBody,
		newSignatureProvider: newSignatureProvider,
		rawGtvToGtx: rawGtvToGtx,
		serialize: serialize,
		sign: sign,
		signRawTransaction: signRawTransaction
	});

	var _a$1;
	var MsgType;
	(function (MsgType) {
	    MsgType["Debug"] = "DEBUG";
	    MsgType["Info"] = "INFO";
	    MsgType["Error"] = "ERROR";
	    MsgType["Warning"] = "WARNING";
	})(MsgType || (MsgType = {}));
	var LogColor;
	(function (LogColor) {
	    LogColor["Red"] = "\u001B[91m";
	    LogColor["Green"] = "\u001B[92m";
	    LogColor["Blue"] = "\u001B[36m";
	    LogColor["Yellow"] = "\u001B[93m";
	    LogColor["StopColor"] = "\u001B[0m";
	})(LogColor || (LogColor = {}));
	var LogLevel;
	(function (LogLevel) {
	    LogLevel["Debug"] = "DEBUG";
	    LogLevel["Info"] = "INFO";
	    LogLevel["Error"] = "ERROR";
	    LogLevel["Warning"] = "WARNING";
	    LogLevel["Disabled"] = "DISABLED";
	})(LogLevel || (LogLevel = {}));
	const logLevelMap = {
	    [LogLevel.Warning]: 1,
	    [LogLevel.Info]: 2,
	    [LogLevel.Debug]: 3,
	    [LogLevel.Error]: 0,
	    [LogLevel.Disabled]: -1,
	};
	const DEFAULT_LOG_LEVEL = logLevelMap[LogLevel.Warning];
	let logLevel = typeof process === "undefined"
	    ? DEFAULT_LOG_LEVEL
	    : (_a$1 = logLevelMap[process.env.LOG_LEVEL]) !== null && _a$1 !== void 0 ? _a$1 : DEFAULT_LOG_LEVEL;
	function setLogLevel(level) {
	    if (typeof level === "number") {
	        console.warn("Passing a number is deprecated, please use LogLevel enum instead");
	        logLevel = level;
	        return;
	    }
	    logLevel = logLevelMap[level];
	}
	function getLogLevel() {
	    return logLevel;
	}
	function debug(message, moduleName) {
	    if (logLevel >= 3) {
	        emitLogMessage({
	            message,
	            moduleName,
	            msgType: MsgType.Debug,
	            color: LogColor.Blue,
	        });
	    }
	}
	function info(message, moduleName) {
	    if (logLevel >= 2) {
	        emitLogMessage({
	            message,
	            moduleName,
	            msgType: MsgType.Info,
	            color: LogColor.Green,
	        });
	    }
	}
	function error(message, moduleName) {
	    if (logLevel != -1) {
	        emitLogMessage({
	            message,
	            moduleName,
	            msgType: MsgType.Error,
	            color: LogColor.Red,
	        });
	    }
	}
	function warning(message, moduleName) {
	    if (logLevel >= 1) {
	        emitLogMessage({
	            message,
	            moduleName,
	            msgType: MsgType.Warning,
	            color: LogColor.Yellow,
	        });
	    }
	}
	function emitLogMessage({ msgType, message, color, moduleName, }) {
	    const time = getTimestamp();
	    const moduleNameMessage = moduleName ? `[${moduleName}]` : "";
	    console.log(`[${time}] ${color}${msgType}:${LogColor.StopColor} ${moduleNameMessage} ${message}`);
	}
	function getTimestamp() {
	    const pad = (n, s = 2) => `${new Array(s).fill(0)}${n}`.slice(-s);
	    const date = new Date();
	    return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}:${pad(date.getMilliseconds(), 3)}`;
	}
	function logger(moduleName) {
	    return {
	        debug: (message) => debug(message, moduleName),
	        info,
	        error,
	        warning,
	        setLogLevel,
	        disable: () => setLogLevel(logLevelMap[LogLevel.Disabled]),
	    };
	}

	var logger$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get LogLevel () { return LogLevel; },
		debug: debug,
		error: error,
		getLogLevel: getLogLevel,
		info: info,
		logger: logger,
		setLogLevel: setLogLevel,
		warning: warning
	});

	var __awaiter$b = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function createClient$1(restApiClient, blockchainRid, functionNames) {
	    functionNames.push("message");
	    function transaction(gtx$1) {
	        return {
	            gtx: gtx$1,
	            sign: function (privOrSigProv, pubKey) {
	                return __awaiter$b(this, void 0, void 0, function* () {
	                    debug(`signing transaction with ${privOrSigProv instanceof require$$0$3.Buffer
                        ? `privkey: ${privOrSigProv.toString("hex")}`
                        : `signature provider [pubKey: ${privOrSigProv.pubKey}]`}`);
	                    if (privOrSigProv instanceof require$$0$3.Buffer) {
	                        yield sign(this.gtx, privOrSigProv, pubKey);
	                    }
	                    else {
	                        yield sign(this.gtx, privOrSigProv);
	                    }
	                });
	            },
	            getTxRID: function () {
	                return this.getDigestToSign();
	            },
	            getDigestToSign: function () {
	                return getDigestToSign(this.gtx);
	            },
	            addSignature: function (pubKey, signature) {
	                addSignature(pubKey, signature, this.gtx);
	            },
	            // raw call
	            addOperation: function (name, ...args) {
	                addTransactionToGtx(name, args, this.gtx);
	            },
	            postAndWaitConfirmation() {
	                return restApiClient.postAndWaitConfirmation(serialize(this.gtx), this.getTxRID());
	            },
	            send: function (callback) {
	                const gtxBytes = serialize(this.gtx);
	                restApiClient.postTransaction(gtxBytes, callback);
	                this.gtx = null;
	                this.gtxBytes = gtxBytes;
	            },
	            encode: function () {
	                return serialize(this.gtx);
	            },
	        };
	    }
	    function addFunctions(req) {
	        functionNames.forEach((functionName) => {
	            req[functionName] = function (...args) {
	                addTransactionToGtx(functionName, args, this.gtx);
	            };
	        });
	    }
	    const client = {
	        newTransaction: function (signers) {
	            signers = removeDuplicateSigners(signers);
	            const newGtx = emptyGtx(require$$0$3.Buffer.from(blockchainRid, "hex"));
	            signers.forEach((signer) => addSignerToGtx(signer, newGtx));
	            const req = transaction(newGtx);
	            addFunctions(req);
	            return req;
	        },
	        transactionFromRawTransaction: function (rawTransaction) {
	            const gtx$1 = deserialize(rawTransaction);
	            debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
	            const req = transaction(gtx$1);
	            addFunctions(req);
	            return req;
	        },
	        query: function (nameOrObject, queryArguments) {
	            if (typeof nameOrObject === "string") {
	                return restApiClient.query(nameOrObject, queryArguments);
	            }
	            else {
	                return restApiClient.query(nameOrObject);
	            }
	        },
	    };
	    return client;
	}

	var gtxclient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createClient: createClient$1
	});

	var ResponseStatus;
	(function (ResponseStatus) {
	    ResponseStatus["Confirmed"] = "confirmed";
	    ResponseStatus["Rejected"] = "rejected";
	    ResponseStatus["Unknown"] = "unknown";
	    ResponseStatus["Waiting"] = "waiting";
	})(ResponseStatus || (ResponseStatus = {}));

	class TxRejectedError extends Error {
	    constructor(rejectReason) {
	        super(`Transaction was rejected, ${rejectReason}`);
	        this.name = "TxRejectedError";
	        this.fullReason = rejectReason;
	        const result = matchRellErrorString(rejectReason);
	        this.shortReason = result.shortReason;
	        this.rellLine = result.rellLine;
	        this.operation = result.operation;
	    }
	}
	class UnexpectedStatusError extends CustomError {
	    constructor(status, error) {
	        let errorMessage = `Unexpected status code from server. Code: ${status}.`;
	        if (status === null) {
	            super(errorMessage, 500); // default status code
	        }
	        else {
	            if (error) {
	                errorMessage += ` Message: ${error}.`;
	            }
	            super(errorMessage, status);
	        }
	    }
	}
	class LostMessageError extends Error {
	    constructor() {
	        super(`Server lost our message`);
	    }
	}
	class UnexpectedResponseError extends Error {
	    constructor() {
	        super(`got unexpected response from server`);
	    }
	}
	class InvalidTxRidException extends CustomError {
	    constructor(txRID) {
	        super(`expected length 32 of txRID, but got ${txRID && txRID.length}`, 400);
	    }
	}
	class SerializedTransactionFormatException extends CustomError {
	    constructor() {
	        super(`messageHash is not a Buffer`, 400);
	    }
	}
	class GetBridFromChainException extends Error {
	    constructor(chainId, reason) {
	        super(`Error resolving BRID for chainId ${chainId}, reason: ${reason}`);
	    }
	}
	class EmptyListOfUrlsException extends CustomError {
	    constructor() {
	        super(`Failed to initialize rest client with empty list of urls`, 400);
	    }
	}
	class InvalidBlockchainRIDException extends CustomError {
	    constructor() {
	        super(`Failed to initialize rest client with blockchain RID that is not 32 bytes`, 400);
	    }
	}

	var Method;
	(function (Method) {
	    Method["GET"] = "get";
	    Method["POST"] = "post";
	})(Method || (Method = {}));

	var __awaiter$a = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function handleRequest(method, path, endpoint, postObject) {
	    return __awaiter$a(this, void 0, void 0, function* () {
	        if (method == Method.GET) {
	            return yield get(path, endpoint);
	        }
	        else {
	            return yield post(path, endpoint, postObject);
	        }
	    });
	}
	/**
	 * Sends request to get data from a given API endpoint.
	 * @param path API endpoint of Rell backend
	 * @param endpoint
	 */
	function get(path, endpoint) {
	    return __awaiter$a(this, void 0, void 0, function* () {
	        debug(`GET URL ${new URL(path, endpoint).href}`);
	        try {
	            const response = yield fetch(new URL(path, endpoint).href);
	            const contentType = response.headers.get("Content-Type");
	            let rspBody;
	            if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
	                rspBody = yield response.json();
	            }
	            else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/plain")) {
	                rspBody = yield response.text();
	            }
	            return {
	                error: null,
	                statusCode: response.status,
	                rspBody,
	            };
	        }
	        catch (error$1) {
	            error(error$1.message);
	            return { error: error$1, statusCode: null, rspBody: null };
	        }
	    });
	}
	/**
	 * Sends request to post data to a given API endpoint.
	 * @param path API endpoint of Rell backend
	 * @param endpoint
	 * @param requestBody request body
	 */
	function post(path, endpoint, requestBody) {
	    return __awaiter$a(this, void 0, void 0, function* () {
	        debug(`POST URL ${new URL(path, endpoint).href}`);
	        debug(`POST body ${JSON.stringify(requestBody)}`);
	        if (require$$0$3.Buffer.isBuffer(requestBody)) {
	            try {
	                const requestOptions = {
	                    method: "post",
	                    body: requestBody,
	                    headers: {
	                        Accept: "application/octet-stream",
	                        "Content-Type": "application/octet-stream",
	                    },
	                };
	                const response = yield fetch(new URL(path, endpoint).href, requestOptions);
	                return {
	                    error: null,
	                    statusCode: response.status,
	                    rspBody: decodeValue(require$$0$3.Buffer.from(yield response.arrayBuffer())),
	                };
	            }
	            catch (error) {
	                return { error, statusCode: null, rspBody: null };
	            }
	        }
	        else {
	            try {
	                const response = yield fetch(new URL(path, endpoint).href, {
	                    method: "post",
	                    body: JSON.stringify(requestBody),
	                });
	                return {
	                    error: null,
	                    statusCode: response.status,
	                    rspBody: yield response.json(),
	                };
	            }
	            catch (error) {
	                return { error, statusCode: null, rspBody: null };
	            }
	        }
	    });
	}

	var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	const hasClientError = (statusCode) => statusCode >= 400 && statusCode < 500;
	const hasServerError = (statusCode) => statusCode >= 500 && statusCode < 600;
	function abortOnError({ method, path, config, postObject, }) {
	    return __awaiter$9(this, void 0, void 0, function* () {
	        return yield retryRequest({
	            method,
	            path,
	            config,
	            postObject,
	            validateStatusCode: (statuscode) => !hasServerError(statuscode),
	        });
	    });
	}
	function tryNextOnError({ method, path, config, postObject, }) {
	    return __awaiter$9(this, void 0, void 0, function* () {
	        return yield retryRequest({
	            method,
	            path,
	            config,
	            postObject,
	            validateStatusCode: (statusCode) => !hasClientError(statusCode) && !hasServerError(statusCode),
	        });
	    });
	}
	function singleEndpoint({ method, path, config, postObject, }) {
	    return __awaiter$9(this, void 0, void 0, function* () {
	        let statusCode, rspBody, error;
	        for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
	            const endpoint = nextEndpoint(config.endpointPool);
	            ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
	            const isError = statusCode
	                ? hasServerError(statusCode) || hasClientError(statusCode)
	                : false;
	            if (!isError && !error) {
	                return { error, statusCode, rspBody };
	            }
	            info(`${method} request failed on ${config.endpointPool[0]}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
	            yield sleep(config.attemptInterval);
	        }
	        // TS issue. Variable 'error' is used before being assigned.
	        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	        // @ts-expect-error
	        return { error, statusCode, rspBody };
	    });
	}
	function retryRequest({ method, path, config, postObject, validateStatusCode, }) {
	    return __awaiter$9(this, void 0, void 0, function* () {
	        let statusCode;
	        let rspBody;
	        let error;
	        const reachableEndpoints = filterReachableEndpoint(config.endpointPool);
	        if (reachableEndpoints.length < bftMajority(config.endpointPool.length)) {
	            setEndpointAsReachable(config.endpointPool);
	        }
	        for (const endpoint of shuffle(config.endpointPool)) {
	            if (isReachable(endpoint)) {
	                for (let attempt = 0; attempt < config.attemptsPerEndpoint; attempt++) {
	                    ({ error, statusCode, rspBody } = yield handleRequest(method, path, endpoint.url, postObject));
	                    const isStatusCodeValid = statusCode
	                        ? validateStatusCode(statusCode)
	                        : false;
	                    const isServerError = statusCode ? hasServerError(statusCode) : false;
	                    if (isStatusCodeValid && !error) {
	                        return { error, statusCode, rspBody };
	                    }
	                    if (isServerError) {
	                        setUnavailable(endpoint, config.unreachableDuration);
	                    }
	                    info(`${method} request failed on ${endpoint}. Attempt: ${attempt + 1} / ${config.attemptsPerEndpoint}`);
	                    yield sleep(config.attemptInterval);
	                }
	            }
	        }
	        // TS issue. Variable 'error' is used before being assigned.
	        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	        // @ts-expect-error
	        return { error, statusCode, rspBody };
	    });
	}

	class MissingPubKeyError extends CustomError {
	    constructor() {
	        super(`No public key was provided`, 400);
	    }
	}
	class MissingBlockchainIdentifierError extends CustomError {
	    constructor() {
	        super(`No blockchain identifier was provided. Include either a blockchainRid (string) or a blockchainIid (number).`, 400);
	    }
	}
	class MissingNodeUrlError extends CustomError {
	    constructor() {
	        super(`No node url or directory node url was provided. Include either a nodeUrl (string) or a directory node url (number).`, 400);
	    }
	}
	class BlockchainUrlUndefinedException extends CustomError {
	    constructor(brid) {
	        const idType = typeof brid === "string" ? "BRID" : "IID";
	        super(`Cannot find nodes hosting the blockchain with ${idType} ${brid}`, 400);
	    }
	}
	class DirectoryNodeUrlPoolException extends CustomError {
	    constructor() {
	        super(`No directory node url was provided`, 400);
	    }
	}
	class InvalidTransactionFormatException extends CustomError {
	    constructor() {
	        super(`The transaction is not in the right format`, 400);
	    }
	}
	class GetTransactionRidException extends CustomError {
	    constructor(error) {
	        super(`"Error occurred while getting transaction RID:", ${error}`, 400);
	    }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */

	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear$1;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */

	function eq$2(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq$2;

	var eq$1 = eq_1;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$4(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf$4;

	var assocIndexOf$3 = _assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$3(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete$1;

	var assocIndexOf$2 = _assocIndexOf;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$2(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet$1;

	var assocIndexOf$1 = _assocIndexOf;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas$1;

	var assocIndexOf = _assocIndexOf;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet$1;

	var listCacheClear = _listCacheClear,
	    listCacheDelete = _listCacheDelete,
	    listCacheGet = _listCacheGet,
	    listCacheHas = _listCacheHas,
	    listCacheSet = _listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$4(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype['delete'] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;

	var _ListCache = ListCache$4;

	var ListCache$3 = _ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$1() {
	  this.__data__ = new ListCache$3;
	  this.size = 0;
	}

	var _stackClear = stackClear$1;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function stackDelete$1(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete$1;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function stackGet$1(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet$1;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function stackHas$1(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas$1;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$8 = freeGlobal || freeSelf || Function('return this')();

	var _root = root$8;

	var root$7 = _root;

	/** Built-in value references. */
	var Symbol$4 = root$7.Symbol;

	var _Symbol = Symbol$4;

	var Symbol$3 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$c.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */

	var objectProto$b = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$b.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$1;

	var Symbol$2 = _Symbol,
	    getRawTag = _getRawTag,
	    objectToString = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$4(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	var _baseGetTag = baseGetTag$4;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */

	function isObject$5(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$5;

	var baseGetTag$3 = _baseGetTag,
	    isObject$4 = isObject_1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$2(value) {
	  if (!isObject$4(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$3(value);
	  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction$2;

	var root$6 = _root;

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$6['__core-js_shared__'];

	var _coreJsData = coreJsData$1;

	var coreJsData = _coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked$1;

	/** Used for built-in method references. */

	var funcProto$1 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$2(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource$2;

	var isFunction$1 = isFunction_1,
	    isMasked = _isMasked,
	    isObject$3 = isObject_1,
	    toSource$1 = _toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$a = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$3(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource$1(value));
	}

	var _baseIsNative = baseIsNative$1;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue$1;

	var baseIsNative = _baseIsNative,
	    getValue = _getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$7(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative$7;

	var getNative$6 = _getNative,
	    root$5 = _root;

	/* Built-in method references that are verified to be native. */
	var Map$4 = getNative$6(root$5, 'Map');

	var _Map = Map$4;

	var getNative$5 = _getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$4 = getNative$5(Object, 'create');

	var _nativeCreate = nativeCreate$4;

	var nativeCreate$3 = _nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear$1;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete$1;

	var nativeCreate$2 = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$1 ? undefined : result;
	  }
	  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet$1;

	var nativeCreate$1 = _nativeCreate;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
	}

	var _hashHas = hashHas$1;

	var nativeCreate = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	var _hashSet = hashSet$1;

	var hashClear = _hashClear,
	    hashDelete = _hashDelete,
	    hashGet = _hashGet,
	    hashHas = _hashHas,
	    hashSet = _hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype['delete'] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;

	var _Hash = Hash$1;

	var Hash = _Hash,
	    ListCache$2 = _ListCache,
	    Map$3 = _Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$3 || ListCache$2),
	    'string': new Hash
	  };
	}

	var _mapCacheClear = mapCacheClear$1;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */

	function isKeyable$1(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable$1;

	var isKeyable = _isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$4(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData$4;

	var getMapData$3 = _getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$3(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete$1;

	var getMapData$2 = _getMapData;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$2(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet$1;

	var getMapData$1 = _getMapData;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas$1;

	var getMapData = _getMapData;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet$1;

	var mapCacheClear = _mapCacheClear,
	    mapCacheDelete = _mapCacheDelete,
	    mapCacheGet = _mapCacheGet,
	    mapCacheHas = _mapCacheHas,
	    mapCacheSet = _mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$1.prototype.clear = mapCacheClear;
	MapCache$1.prototype['delete'] = mapCacheDelete;
	MapCache$1.prototype.get = mapCacheGet;
	MapCache$1.prototype.has = mapCacheHas;
	MapCache$1.prototype.set = mapCacheSet;

	var _MapCache = MapCache$1;

	var ListCache$1 = _ListCache,
	    Map$2 = _Map,
	    MapCache = _MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$1(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet$1;

	var ListCache = _ListCache,
	    stackClear = _stackClear,
	    stackDelete = _stackDelete,
	    stackGet = _stackGet,
	    stackHas = _stackHas,
	    stackSet = _stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$1(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$1.prototype.clear = stackClear;
	Stack$1.prototype['delete'] = stackDelete;
	Stack$1.prototype.get = stackGet;
	Stack$1.prototype.has = stackHas;
	Stack$1.prototype.set = stackSet;

	var _Stack = Stack$1;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */

	function arrayEach$1(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach$1;

	var getNative$4 = _getNative;

	var defineProperty$1 = (function() {
	  try {
	    var func = getNative$4(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty$1;

	var defineProperty = _defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue$2(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue$2;

	var baseAssignValue$1 = _baseAssignValue,
	    eq = eq_1;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue$2(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue$1(object, key, value);
	  }
	}

	var _assignValue = assignValue$2;

	var assignValue$1 = _assignValue,
	    baseAssignValue = _baseAssignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject$4(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue$1(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject$4;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */

	function baseTimes$1(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */

	function isObjectLike$5(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$5;

	var baseGetTag$2 = _baseGetTag,
	    isObjectLike$4 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$1(value) {
	  return isObjectLike$4(value) && baseGetTag$2(value) == argsTag$2;
	}

	var _baseIsArguments = baseIsArguments$1;

	var baseIsArguments = _baseIsArguments,
	    isObjectLike$3 = isObjectLike_1;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike$3(value) && hasOwnProperty$4.call(value, 'callee') &&
	    !propertyIsEnumerable$1.call(value, 'callee');
	};

	var isArguments_1 = isArguments$1;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */

	var isArray$3 = Array.isArray;

	var isArray_1 = isArray$3;

	var isBuffer$2 = {exports: {}};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */

	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	isBuffer$2.exports;

	(function (module, exports) {
		var root = _root,
		    stubFalse = stubFalse_1;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer$2, isBuffer$2.exports));

	var isBufferExports = isBuffer$2.exports;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$1(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex$1;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$2(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	var isLength_1 = isLength$2;

	var baseGetTag$1 = _baseGetTag,
	    isLength$1 = isLength_1,
	    isObjectLike$2 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
	typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
	typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
	typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
	typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
	typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
	typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
	typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
	typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
	typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
	typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$1(value) {
	  return isObjectLike$2(value) &&
	    isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray$1;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */

	function baseUnary$3(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary$3;

	var _nodeUtil = {exports: {}};

	_nodeUtil.exports;

	(function (module, exports) {
		var freeGlobal = _freeGlobal;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));

	var _nodeUtilExports = _nodeUtil.exports;

	var baseIsTypedArray = _baseIsTypedArray,
	    baseUnary$2 = _baseUnary,
	    nodeUtil$2 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$1 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;

	var isTypedArray_1 = isTypedArray$1;

	var baseTimes = _baseTimes,
	    isArguments = isArguments_1,
	    isArray$2 = isArray_1,
	    isBuffer$1 = isBufferExports,
	    isIndex = _isIndex,
	    isTypedArray = isTypedArray_1;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$2(value, inherited) {
	  var isArr = isArray$2(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer$1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$3.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys$2;

	/** Used for built-in method references. */

	var objectProto$4 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$3(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

	  return value === proto;
	}

	var _isPrototype = isPrototype$3;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */

	function overArg$2(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg$2;

	var overArg$1 = _overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$1 = overArg$1(Object.keys, Object);

	var _nativeKeys = nativeKeys$1;

	var isPrototype$2 = _isPrototype,
	    nativeKeys = _nativeKeys;

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$1(object) {
	  if (!isPrototype$2(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys$1;

	var isFunction = isFunction_1,
	    isLength = isLength_1;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$2(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	var isArrayLike_1 = isArrayLike$2;

	var arrayLikeKeys$1 = _arrayLikeKeys,
	    baseKeys = _baseKeys,
	    isArrayLike$1 = isArrayLike_1;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$3(object) {
	  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys(object);
	}

	var keys_1 = keys$3;

	var copyObject$3 = _copyObject,
	    keys$2 = keys_1;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign$1(object, source) {
	  return object && copyObject$3(source, keys$2(source), object);
	}

	var _baseAssign = baseAssign$1;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */

	function nativeKeysIn$1(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn$1;

	var isObject$2 = isObject_1,
	    isPrototype$1 = _isPrototype,
	    nativeKeysIn = _nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn$1(object) {
	  if (!isObject$2(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype$1(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn$1;

	var arrayLikeKeys = _arrayLikeKeys,
	    baseKeysIn = _baseKeysIn,
	    isArrayLike = isArrayLike_1;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$3(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	var keysIn_1 = keysIn$3;

	var copyObject$2 = _copyObject,
	    keysIn$2 = keysIn_1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn$1(object, source) {
	  return object && copyObject$2(source, keysIn$2(source), object);
	}

	var _baseAssignIn = baseAssignIn$1;

	var _cloneBuffer = {exports: {}};

	_cloneBuffer.exports;

	(function (module, exports) {
		var root = _root;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));

	var _cloneBufferExports = _cloneBuffer.exports;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */

	function copyArray$1(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray$1;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */

	function arrayFilter$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter$1;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */

	function stubArray$2() {
	  return [];
	}

	var stubArray_1 = stubArray$2;

	var arrayFilter = _arrayFilter,
	    stubArray$1 = stubArray_1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols$3;

	var copyObject$1 = _copyObject,
	    getSymbols$2 = _getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols$1(source, object) {
	  return copyObject$1(source, getSymbols$2(source), object);
	}

	var _copySymbols = copySymbols$1;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */

	function arrayPush$2(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush$2;

	var overArg = _overArg;

	/** Built-in value references. */
	var getPrototype$2 = overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype$2;

	var arrayPush$1 = _arrayPush,
	    getPrototype$1 = _getPrototype,
	    getSymbols$1 = _getSymbols,
	    stubArray = stubArray_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush$1(result, getSymbols$1(object));
	    object = getPrototype$1(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn$2;

	var copyObject = _copyObject,
	    getSymbolsIn$1 = _getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn$1(source, object) {
	  return copyObject(source, getSymbolsIn$1(source), object);
	}

	var _copySymbolsIn = copySymbolsIn$1;

	var arrayPush = _arrayPush,
	    isArray$1 = isArray_1;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys$2;

	var baseGetAllKeys$1 = _baseGetAllKeys,
	    getSymbols = _getSymbols,
	    keys$1 = keys_1;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$1(object) {
	  return baseGetAllKeys$1(object, keys$1, getSymbols);
	}

	var _getAllKeys = getAllKeys$1;

	var baseGetAllKeys = _baseGetAllKeys,
	    getSymbolsIn = _getSymbolsIn,
	    keysIn$1 = keysIn_1;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn$1(object) {
	  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn$1;

	var getNative$3 = _getNative,
	    root$4 = _root;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative$3(root$4, 'DataView');

	var _DataView = DataView$1;

	var getNative$2 = _getNative,
	    root$3 = _root;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative$2(root$3, 'Promise');

	var _Promise = Promise$2;

	var getNative$1 = _getNative,
	    root$2 = _root;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$1(root$2, 'Set');

	var _Set = Set$2;

	var getNative = _getNative,
	    root$1 = _root;

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = getNative(root$1, 'WeakMap');

	var _WeakMap = WeakMap$1;

	var DataView = _DataView,
	    Map$1 = _Map,
	    Promise$1 = _Promise,
	    Set$1 = _Set,
	    WeakMap = _WeakMap,
	    baseGetTag = _baseGetTag,
	    toSource = _toSource;

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$3 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$2 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map$1),
	    promiseCtorString = toSource(Promise$1),
	    setCtorString = toSource(Set$1),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$3 = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
	    (Map$1 && getTag$3(new Map$1) != mapTag$3) ||
	    (Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag) ||
	    (Set$1 && getTag$3(new Set$1) != setTag$3) ||
	    (WeakMap && getTag$3(new WeakMap) != weakMapTag$1)) {
	  getTag$3 = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$2;
	        case mapCtorString: return mapTag$3;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$3;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag$3;

	/** Used for built-in method references. */

	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray$1(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray$1;

	var root = _root;

	/** Built-in value references. */
	var Uint8Array$2 = root.Uint8Array;

	var _Uint8Array = Uint8Array$2;

	var Uint8Array$1 = _Uint8Array;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer$3(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer$3;

	var cloneArrayBuffer$2 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView$1(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView$1;

	/** Used to match `RegExp` flags from their coerced string values. */

	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp$1(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp$1;

	var Symbol$1 = _Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol$1(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol$1;

	var cloneArrayBuffer$1 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray$1(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray$1;

	var cloneArrayBuffer = _cloneArrayBuffer,
	    cloneDataView = _cloneDataView,
	    cloneRegExp = _cloneRegExp,
	    cloneSymbol = _cloneSymbol,
	    cloneTypedArray = _cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag$1(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$1:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag$1:
	      return cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag$1;

	var isObject$1 = isObject_1;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate$1 = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate$1;

	var baseCreate = _baseCreate,
	    getPrototype = _getPrototype,
	    isPrototype = _isPrototype;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject$1(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject$1;

	var getTag$2 = _getTag,
	    isObjectLike$1 = isObjectLike_1;

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap$1(value) {
	  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
	}

	var _baseIsMap = baseIsMap$1;

	var baseIsMap = _baseIsMap,
	    baseUnary$1 = _baseUnary,
	    nodeUtil$1 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;

	var isMap_1 = isMap$1;

	var getTag$1 = _getTag,
	    isObjectLike = isObjectLike_1;

	/** `Object#toString` result references. */
	var setTag$1 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet$1(value) {
	  return isObjectLike(value) && getTag$1(value) == setTag$1;
	}

	var _baseIsSet = baseIsSet$1;

	var baseIsSet = _baseIsSet,
	    baseUnary = _baseUnary,
	    nodeUtil = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	var isSet_1 = isSet$1;

	var Stack = _Stack,
	    arrayEach = _arrayEach,
	    assignValue = _assignValue,
	    baseAssign = _baseAssign,
	    baseAssignIn = _baseAssignIn,
	    cloneBuffer = _cloneBufferExports,
	    copyArray = _copyArray,
	    copySymbols = _copySymbols,
	    copySymbolsIn = _copySymbolsIn,
	    getAllKeys = _getAllKeys,
	    getAllKeysIn = _getAllKeysIn,
	    getTag = _getTag,
	    initCloneArray = _initCloneArray,
	    initCloneByTag = _initCloneByTag,
	    initCloneObject = _initCloneObject,
	    isArray = isArray_1,
	    isBuffer = isBufferExports,
	    isMap = isMap_1,
	    isObject = isObject_1,
	    isSet = isSet_1,
	    keys = keys_1,
	    keysIn = keysIn_1;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone$1(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$1,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone$1(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone$1(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone$1;

	var baseClone = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	var cloneDeep_1 = cloneDeep;

	var cloneDeep$1 = /*@__PURE__*/getDefaultExportFromCjs(cloneDeep_1);

	/*
	This file is part of web3.js.

	web3.js is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	web3.js is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
	*/
	class Web3EventEmitter {
	    constructor() {
	        this._emitter = new require$$0$4.EventEmitter();
	    }
	    on(eventName, fn) {
	        // eslint-disable-next-line @typescript-eslint/no-misused-promises
	        this._emitter.on(eventName, fn);
	    }
	    once(eventName, fn) {
	        // eslint-disable-next-line @typescript-eslint/no-misused-promises
	        this._emitter.once(eventName, fn);
	    }
	    off(eventName, fn) {
	        // eslint-disable-next-line @typescript-eslint/no-misused-promises
	        this._emitter.off(eventName, fn);
	    }
	    emit(eventName, params) {
	        this._emitter.emit(eventName, params);
	    }
	    listenerCount(eventName) {
	        return this._emitter.listenerCount(eventName);
	    }
	    listeners(eventName) {
	        return this._emitter.listeners(eventName);
	    }
	    eventNames() {
	        return this._emitter.eventNames();
	    }
	    removeAllListeners() {
	        this._emitter.removeAllListeners();
	    }
	    setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
	        this._emitter.setMaxListeners(maxListenersWarningThreshold);
	    }
	    getMaxListeners() {
	        return this._emitter.getMaxListeners();
	    }
	}

	/*
	This file is part of web3.js.

	web3.js is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	web3.js is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
	*/
	var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var _a;
	class Web3PromiEvent extends Web3EventEmitter {
	    constructor(executor) {
	        super();
	        // public tag to treat object as promise by different libs
	        // eslint-disable-next-line @typescript-eslint/prefer-as-const
	        this[_a] = "Promise";
	        this._promise = new Promise(executor);
	    }
	    then(onfulfilled, onrejected) {
	        return __awaiter$8(this, void 0, void 0, function* () {
	            return this._promise.then(onfulfilled, onrejected);
	        });
	    }
	    catch(onrejected) {
	        return __awaiter$8(this, void 0, void 0, function* () {
	            return this._promise.catch(onrejected);
	        });
	    }
	    finally(onfinally) {
	        return __awaiter$8(this, void 0, void 0, function* () {
	            return this._promise.finally(onfinally);
	        });
	    }
	    on(eventName, fn) {
	        super.on(eventName, fn);
	        return this;
	    }
	    once(eventName, fn) {
	        super.once(eventName, fn);
	        return this;
	    }
	}
	_a = Symbol.toStringTag;

	exports.FailoverStrategy = void 0;
	(function (FailoverStrategy) {
	    FailoverStrategy["AbortOnError"] = "abortOnError";
	    FailoverStrategy["TryNextOnError"] = "tryNextOnError";
	    FailoverStrategy["SingleEndpoint"] = "singleEndpoint";
	})(exports.FailoverStrategy || (exports.FailoverStrategy = {}));
	exports.ResponseStatus = void 0;
	(function (ResponseStatus) {
	    ResponseStatus["Confirmed"] = "confirmed";
	    ResponseStatus["Rejected"] = "rejected";
	    ResponseStatus["Unknown"] = "unknown";
	    ResponseStatus["Waiting"] = "waiting";
	})(exports.ResponseStatus || (exports.ResponseStatus = {}));

	var util;
	(function (util) {
	    util.assertEqual = (val) => val;
	    function assertIs(_arg) { }
	    util.assertIs = assertIs;
	    function assertNever(_x) {
	        throw new Error();
	    }
	    util.assertNever = assertNever;
	    util.arrayToEnum = (items) => {
	        const obj = {};
	        for (const item of items) {
	            obj[item] = item;
	        }
	        return obj;
	    };
	    util.getValidEnumValues = (obj) => {
	        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
	        const filtered = {};
	        for (const k of validKeys) {
	            filtered[k] = obj[k];
	        }
	        return util.objectValues(filtered);
	    };
	    util.objectValues = (obj) => {
	        return util.objectKeys(obj).map(function (e) {
	            return obj[e];
	        });
	    };
	    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
	        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
	        : (object) => {
	            const keys = [];
	            for (const key in object) {
	                if (Object.prototype.hasOwnProperty.call(object, key)) {
	                    keys.push(key);
	                }
	            }
	            return keys;
	        };
	    util.find = (arr, checker) => {
	        for (const item of arr) {
	            if (checker(item))
	                return item;
	        }
	        return undefined;
	    };
	    util.isInteger = typeof Number.isInteger === "function"
	        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
	        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	    function joinValues(array, separator = " | ") {
	        return array
	            .map((val) => (typeof val === "string" ? `'${val}'` : val))
	            .join(separator);
	    }
	    util.joinValues = joinValues;
	    util.jsonStringifyReplacer = (_, value) => {
	        if (typeof value === "bigint") {
	            return value.toString();
	        }
	        return value;
	    };
	})(util || (util = {}));
	var objectUtil;
	(function (objectUtil) {
	    objectUtil.mergeShapes = (first, second) => {
	        return {
	            ...first,
	            ...second, // second overwrites first
	        };
	    };
	})(objectUtil || (objectUtil = {}));
	const ZodParsedType = util.arrayToEnum([
	    "string",
	    "nan",
	    "number",
	    "integer",
	    "float",
	    "boolean",
	    "date",
	    "bigint",
	    "symbol",
	    "function",
	    "undefined",
	    "null",
	    "array",
	    "object",
	    "unknown",
	    "promise",
	    "void",
	    "never",
	    "map",
	    "set",
	]);
	const getParsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "undefined":
	            return ZodParsedType.undefined;
	        case "string":
	            return ZodParsedType.string;
	        case "number":
	            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
	        case "boolean":
	            return ZodParsedType.boolean;
	        case "function":
	            return ZodParsedType.function;
	        case "bigint":
	            return ZodParsedType.bigint;
	        case "symbol":
	            return ZodParsedType.symbol;
	        case "object":
	            if (Array.isArray(data)) {
	                return ZodParsedType.array;
	            }
	            if (data === null) {
	                return ZodParsedType.null;
	            }
	            if (data.then &&
	                typeof data.then === "function" &&
	                data.catch &&
	                typeof data.catch === "function") {
	                return ZodParsedType.promise;
	            }
	            if (typeof Map !== "undefined" && data instanceof Map) {
	                return ZodParsedType.map;
	            }
	            if (typeof Set !== "undefined" && data instanceof Set) {
	                return ZodParsedType.set;
	            }
	            if (typeof Date !== "undefined" && data instanceof Date) {
	                return ZodParsedType.date;
	            }
	            return ZodParsedType.object;
	        default:
	            return ZodParsedType.unknown;
	    }
	};

	const ZodIssueCode = util.arrayToEnum([
	    "invalid_type",
	    "invalid_literal",
	    "custom",
	    "invalid_union",
	    "invalid_union_discriminator",
	    "invalid_enum_value",
	    "unrecognized_keys",
	    "invalid_arguments",
	    "invalid_return_type",
	    "invalid_date",
	    "invalid_string",
	    "too_small",
	    "too_big",
	    "invalid_intersection_types",
	    "not_multiple_of",
	    "not_finite",
	]);
	const quotelessJson = (obj) => {
	    const json = JSON.stringify(obj, null, 2);
	    return json.replace(/"([^"]+)":/g, "$1:");
	};
	class ZodError extends Error {
	    constructor(issues) {
	        super();
	        this.issues = [];
	        this.addIssue = (sub) => {
	            this.issues = [...this.issues, sub];
	        };
	        this.addIssues = (subs = []) => {
	            this.issues = [...this.issues, ...subs];
	        };
	        const actualProto = new.target.prototype;
	        if (Object.setPrototypeOf) {
	            // eslint-disable-next-line ban/ban
	            Object.setPrototypeOf(this, actualProto);
	        }
	        else {
	            this.__proto__ = actualProto;
	        }
	        this.name = "ZodError";
	        this.issues = issues;
	    }
	    get errors() {
	        return this.issues;
	    }
	    format(_mapper) {
	        const mapper = _mapper ||
	            function (issue) {
	                return issue.message;
	            };
	        const fieldErrors = { _errors: [] };
	        const processError = (error) => {
	            for (const issue of error.issues) {
	                if (issue.code === "invalid_union") {
	                    issue.unionErrors.map(processError);
	                }
	                else if (issue.code === "invalid_return_type") {
	                    processError(issue.returnTypeError);
	                }
	                else if (issue.code === "invalid_arguments") {
	                    processError(issue.argumentsError);
	                }
	                else if (issue.path.length === 0) {
	                    fieldErrors._errors.push(mapper(issue));
	                }
	                else {
	                    let curr = fieldErrors;
	                    let i = 0;
	                    while (i < issue.path.length) {
	                        const el = issue.path[i];
	                        const terminal = i === issue.path.length - 1;
	                        if (!terminal) {
	                            curr[el] = curr[el] || { _errors: [] };
	                            // if (typeof el === "string") {
	                            //   curr[el] = curr[el] || { _errors: [] };
	                            // } else if (typeof el === "number") {
	                            //   const errorArray: any = [];
	                            //   errorArray._errors = [];
	                            //   curr[el] = curr[el] || errorArray;
	                            // }
	                        }
	                        else {
	                            curr[el] = curr[el] || { _errors: [] };
	                            curr[el]._errors.push(mapper(issue));
	                        }
	                        curr = curr[el];
	                        i++;
	                    }
	                }
	            }
	        };
	        processError(this);
	        return fieldErrors;
	    }
	    toString() {
	        return this.message;
	    }
	    get message() {
	        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	    }
	    get isEmpty() {
	        return this.issues.length === 0;
	    }
	    flatten(mapper = (issue) => issue.message) {
	        const fieldErrors = {};
	        const formErrors = [];
	        for (const sub of this.issues) {
	            if (sub.path.length > 0) {
	                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
	                fieldErrors[sub.path[0]].push(mapper(sub));
	            }
	            else {
	                formErrors.push(mapper(sub));
	            }
	        }
	        return { formErrors, fieldErrors };
	    }
	    get formErrors() {
	        return this.flatten();
	    }
	}
	ZodError.create = (issues) => {
	    const error = new ZodError(issues);
	    return error;
	};

	const errorMap = (issue, _ctx) => {
	    let message;
	    switch (issue.code) {
	        case ZodIssueCode.invalid_type:
	            if (issue.received === ZodParsedType.undefined) {
	                message = "Required";
	            }
	            else {
	                message = `Expected ${issue.expected}, received ${issue.received}`;
	            }
	            break;
	        case ZodIssueCode.invalid_literal:
	            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
	            break;
	        case ZodIssueCode.unrecognized_keys:
	            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
	            break;
	        case ZodIssueCode.invalid_union:
	            message = `Invalid input`;
	            break;
	        case ZodIssueCode.invalid_union_discriminator:
	            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
	            break;
	        case ZodIssueCode.invalid_enum_value:
	            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
	            break;
	        case ZodIssueCode.invalid_arguments:
	            message = `Invalid function arguments`;
	            break;
	        case ZodIssueCode.invalid_return_type:
	            message = `Invalid function return type`;
	            break;
	        case ZodIssueCode.invalid_date:
	            message = `Invalid date`;
	            break;
	        case ZodIssueCode.invalid_string:
	            if (typeof issue.validation === "object") {
	                if ("includes" in issue.validation) {
	                    message = `Invalid input: must include "${issue.validation.includes}"`;
	                    if (typeof issue.validation.position === "number") {
	                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
	                    }
	                }
	                else if ("startsWith" in issue.validation) {
	                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
	                }
	                else if ("endsWith" in issue.validation) {
	                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
	                }
	                else {
	                    util.assertNever(issue.validation);
	                }
	            }
	            else if (issue.validation !== "regex") {
	                message = `Invalid ${issue.validation}`;
	            }
	            else {
	                message = "Invalid";
	            }
	            break;
	        case ZodIssueCode.too_small:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodIssueCode.too_big:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "bigint")
	                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodIssueCode.custom:
	            message = `Invalid input`;
	            break;
	        case ZodIssueCode.invalid_intersection_types:
	            message = `Intersection results could not be merged`;
	            break;
	        case ZodIssueCode.not_multiple_of:
	            message = `Number must be a multiple of ${issue.multipleOf}`;
	            break;
	        case ZodIssueCode.not_finite:
	            message = "Number must be finite";
	            break;
	        default:
	            message = _ctx.defaultError;
	            util.assertNever(issue);
	    }
	    return { message };
	};

	let overrideErrorMap = errorMap;
	function setErrorMap(map) {
	    overrideErrorMap = map;
	}
	function getErrorMap() {
	    return overrideErrorMap;
	}

	const makeIssue = (params) => {
	    const { data, path, errorMaps, issueData } = params;
	    const fullPath = [...path, ...(issueData.path || [])];
	    const fullIssue = {
	        ...issueData,
	        path: fullPath,
	    };
	    let errorMessage = "";
	    const maps = errorMaps
	        .filter((m) => !!m)
	        .slice()
	        .reverse();
	    for (const map of maps) {
	        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
	    }
	    return {
	        ...issueData,
	        path: fullPath,
	        message: issueData.message || errorMessage,
	    };
	};
	const EMPTY_PATH = [];
	function addIssueToContext(ctx, issueData) {
	    const issue = makeIssue({
	        issueData: issueData,
	        data: ctx.data,
	        path: ctx.path,
	        errorMaps: [
	            ctx.common.contextualErrorMap,
	            ctx.schemaErrorMap,
	            getErrorMap(),
	            errorMap, // then global default map
	        ].filter((x) => !!x),
	    });
	    ctx.common.issues.push(issue);
	}
	class ParseStatus {
	    constructor() {
	        this.value = "valid";
	    }
	    dirty() {
	        if (this.value === "valid")
	            this.value = "dirty";
	    }
	    abort() {
	        if (this.value !== "aborted")
	            this.value = "aborted";
	    }
	    static mergeArray(status, results) {
	        const arrayValue = [];
	        for (const s of results) {
	            if (s.status === "aborted")
	                return INVALID;
	            if (s.status === "dirty")
	                status.dirty();
	            arrayValue.push(s.value);
	        }
	        return { status: status.value, value: arrayValue };
	    }
	    static async mergeObjectAsync(status, pairs) {
	        const syncPairs = [];
	        for (const pair of pairs) {
	            syncPairs.push({
	                key: await pair.key,
	                value: await pair.value,
	            });
	        }
	        return ParseStatus.mergeObjectSync(status, syncPairs);
	    }
	    static mergeObjectSync(status, pairs) {
	        const finalObject = {};
	        for (const pair of pairs) {
	            const { key, value } = pair;
	            if (key.status === "aborted")
	                return INVALID;
	            if (value.status === "aborted")
	                return INVALID;
	            if (key.status === "dirty")
	                status.dirty();
	            if (value.status === "dirty")
	                status.dirty();
	            if (key.value !== "__proto__" &&
	                (typeof value.value !== "undefined" || pair.alwaysSet)) {
	                finalObject[key.value] = value.value;
	            }
	        }
	        return { status: status.value, value: finalObject };
	    }
	}
	const INVALID = Object.freeze({
	    status: "aborted",
	});
	const DIRTY = (value) => ({ status: "dirty", value });
	const OK = (value) => ({ status: "valid", value });
	const isAborted = (x) => x.status === "aborted";
	const isDirty = (x) => x.status === "dirty";
	const isValid = (x) => x.status === "valid";
	const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

	var errorUtil;
	(function (errorUtil) {
	    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
	})(errorUtil || (errorUtil = {}));

	class ParseInputLazyPath {
	    constructor(parent, value, path, key) {
	        this._cachedPath = [];
	        this.parent = parent;
	        this.data = value;
	        this._path = path;
	        this._key = key;
	    }
	    get path() {
	        if (!this._cachedPath.length) {
	            if (this._key instanceof Array) {
	                this._cachedPath.push(...this._path, ...this._key);
	            }
	            else {
	                this._cachedPath.push(...this._path, this._key);
	            }
	        }
	        return this._cachedPath;
	    }
	}
	const handleResult = (ctx, result) => {
	    if (isValid(result)) {
	        return { success: true, data: result.value };
	    }
	    else {
	        if (!ctx.common.issues.length) {
	            throw new Error("Validation failed but no issues detected.");
	        }
	        return {
	            success: false,
	            get error() {
	                if (this._error)
	                    return this._error;
	                const error = new ZodError(ctx.common.issues);
	                this._error = error;
	                return this._error;
	            },
	        };
	    }
	};
	function processCreateParams(params) {
	    if (!params)
	        return {};
	    const { errorMap, invalid_type_error, required_error, description } = params;
	    if (errorMap && (invalid_type_error || required_error)) {
	        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	    }
	    if (errorMap)
	        return { errorMap: errorMap, description };
	    const customMap = (iss, ctx) => {
	        if (iss.code !== "invalid_type")
	            return { message: ctx.defaultError };
	        if (typeof ctx.data === "undefined") {
	            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
	        }
	        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
	    };
	    return { errorMap: customMap, description };
	}
	class ZodType {
	    constructor(def) {
	        /** Alias of safeParseAsync */
	        this.spa = this.safeParseAsync;
	        this._def = def;
	        this.parse = this.parse.bind(this);
	        this.safeParse = this.safeParse.bind(this);
	        this.parseAsync = this.parseAsync.bind(this);
	        this.safeParseAsync = this.safeParseAsync.bind(this);
	        this.spa = this.spa.bind(this);
	        this.refine = this.refine.bind(this);
	        this.refinement = this.refinement.bind(this);
	        this.superRefine = this.superRefine.bind(this);
	        this.optional = this.optional.bind(this);
	        this.nullable = this.nullable.bind(this);
	        this.nullish = this.nullish.bind(this);
	        this.array = this.array.bind(this);
	        this.promise = this.promise.bind(this);
	        this.or = this.or.bind(this);
	        this.and = this.and.bind(this);
	        this.transform = this.transform.bind(this);
	        this.brand = this.brand.bind(this);
	        this.default = this.default.bind(this);
	        this.catch = this.catch.bind(this);
	        this.describe = this.describe.bind(this);
	        this.pipe = this.pipe.bind(this);
	        this.readonly = this.readonly.bind(this);
	        this.isNullable = this.isNullable.bind(this);
	        this.isOptional = this.isOptional.bind(this);
	    }
	    get description() {
	        return this._def.description;
	    }
	    _getType(input) {
	        return getParsedType(input.data);
	    }
	    _getOrReturnCtx(input, ctx) {
	        return (ctx || {
	            common: input.parent.common,
	            data: input.data,
	            parsedType: getParsedType(input.data),
	            schemaErrorMap: this._def.errorMap,
	            path: input.path,
	            parent: input.parent,
	        });
	    }
	    _processInputParams(input) {
	        return {
	            status: new ParseStatus(),
	            ctx: {
	                common: input.parent.common,
	                data: input.data,
	                parsedType: getParsedType(input.data),
	                schemaErrorMap: this._def.errorMap,
	                path: input.path,
	                parent: input.parent,
	            },
	        };
	    }
	    _parseSync(input) {
	        const result = this._parse(input);
	        if (isAsync(result)) {
	            throw new Error("Synchronous parse encountered promise.");
	        }
	        return result;
	    }
	    _parseAsync(input) {
	        const result = this._parse(input);
	        return Promise.resolve(result);
	    }
	    parse(data, params) {
	        const result = this.safeParse(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    safeParse(data, params) {
	        var _a;
	        const ctx = {
	            common: {
	                issues: [],
	                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: getParsedType(data),
	        };
	        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
	        return handleResult(ctx, result);
	    }
	    async parseAsync(data, params) {
	        const result = await this.safeParseAsync(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    async safeParseAsync(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	                async: true,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: getParsedType(data),
	        };
	        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
	        const result = await (isAsync(maybeAsyncResult)
	            ? maybeAsyncResult
	            : Promise.resolve(maybeAsyncResult));
	        return handleResult(ctx, result);
	    }
	    refine(check, message) {
	        const getIssueProperties = (val) => {
	            if (typeof message === "string" || typeof message === "undefined") {
	                return { message };
	            }
	            else if (typeof message === "function") {
	                return message(val);
	            }
	            else {
	                return message;
	            }
	        };
	        return this._refinement((val, ctx) => {
	            const result = check(val);
	            const setError = () => ctx.addIssue({
	                code: ZodIssueCode.custom,
	                ...getIssueProperties(val),
	            });
	            if (typeof Promise !== "undefined" && result instanceof Promise) {
	                return result.then((data) => {
	                    if (!data) {
	                        setError();
	                        return false;
	                    }
	                    else {
	                        return true;
	                    }
	                });
	            }
	            if (!result) {
	                setError();
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    refinement(check, refinementData) {
	        return this._refinement((val, ctx) => {
	            if (!check(val)) {
	                ctx.addIssue(typeof refinementData === "function"
	                    ? refinementData(val, ctx)
	                    : refinementData);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    _refinement(refinement) {
	        return new ZodEffects({
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "refinement", refinement },
	        });
	    }
	    superRefine(refinement) {
	        return this._refinement(refinement);
	    }
	    optional() {
	        return ZodOptional.create(this, this._def);
	    }
	    nullable() {
	        return ZodNullable.create(this, this._def);
	    }
	    nullish() {
	        return this.nullable().optional();
	    }
	    array() {
	        return ZodArray.create(this, this._def);
	    }
	    promise() {
	        return ZodPromise.create(this, this._def);
	    }
	    or(option) {
	        return ZodUnion.create([this, option], this._def);
	    }
	    and(incoming) {
	        return ZodIntersection.create(this, incoming, this._def);
	    }
	    transform(transform) {
	        return new ZodEffects({
	            ...processCreateParams(this._def),
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "transform", transform },
	        });
	    }
	    default(def) {
	        const defaultValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodDefault({
	            ...processCreateParams(this._def),
	            innerType: this,
	            defaultValue: defaultValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodDefault,
	        });
	    }
	    brand() {
	        return new ZodBranded({
	            typeName: ZodFirstPartyTypeKind.ZodBranded,
	            type: this,
	            ...processCreateParams(this._def),
	        });
	    }
	    catch(def) {
	        const catchValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodCatch({
	            ...processCreateParams(this._def),
	            innerType: this,
	            catchValue: catchValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodCatch,
	        });
	    }
	    describe(description) {
	        const This = this.constructor;
	        return new This({
	            ...this._def,
	            description,
	        });
	    }
	    pipe(target) {
	        return ZodPipeline.create(this, target);
	    }
	    readonly() {
	        return ZodReadonly.create(this);
	    }
	    isOptional() {
	        return this.safeParse(undefined).success;
	    }
	    isNullable() {
	        return this.safeParse(null).success;
	    }
	}
	const cuidRegex = /^c[^\s-]{8,}$/i;
	const cuid2Regex = /^[a-z][a-z0-9]*$/;
	const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
	// const uuidRegex =
	//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
	const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
	// from https://stackoverflow.com/a/46181/1550155
	// old version: too slow, didn't support unicode
	// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
	//old email regex
	// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
	// eslint-disable-next-line
	// const emailRegex =
	//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
	// const emailRegex =
	//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// const emailRegex =
	//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
	const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
	// const emailRegex =
	//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	let emojiRegex;
	const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
	const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
	// Adapted from https://stackoverflow.com/a/3143231
	const datetimeRegex = (args) => {
	    if (args.precision) {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
	        }
	    }
	    else if (args.precision === 0) {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
	        }
	    }
	    else {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
	        }
	    }
	};
	function isValidIP(ip, version) {
	    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	class ZodString extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = String(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.string) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.string,
	                received: ctx.parsedType,
	            }
	            //
	            );
	            return INVALID;
	        }
	        const status = new ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.length < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.length > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "length") {
	                const tooBig = input.data.length > check.value;
	                const tooSmall = input.data.length < check.value;
	                if (tooBig || tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    if (tooBig) {
	                        addIssueToContext(ctx, {
	                            code: ZodIssueCode.too_big,
	                            maximum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    else if (tooSmall) {
	                        addIssueToContext(ctx, {
	                            code: ZodIssueCode.too_small,
	                            minimum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "email") {
	                if (!emailRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "email",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "emoji") {
	                if (!emojiRegex) {
	                    emojiRegex = new RegExp(_emojiRegex, "u");
	                }
	                if (!emojiRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "emoji",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "uuid") {
	                if (!uuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "uuid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid") {
	                if (!cuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "cuid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid2") {
	                if (!cuid2Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "cuid2",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ulid") {
	                if (!ulidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "ulid",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "url") {
	                try {
	                    new URL(input.data);
	                }
	                catch (_a) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "url",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "regex") {
	                check.regex.lastIndex = 0;
	                const testResult = check.regex.test(input.data);
	                if (!testResult) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "regex",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "trim") {
	                input.data = input.data.trim();
	            }
	            else if (check.kind === "includes") {
	                if (!input.data.includes(check.value, check.position)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { includes: check.value, position: check.position },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "toLowerCase") {
	                input.data = input.data.toLowerCase();
	            }
	            else if (check.kind === "toUpperCase") {
	                input.data = input.data.toUpperCase();
	            }
	            else if (check.kind === "startsWith") {
	                if (!input.data.startsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { startsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "endsWith") {
	                if (!input.data.endsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: { endsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "datetime") {
	                const regex = datetimeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_string,
	                        validation: "datetime",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ip") {
	                if (!isValidIP(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        validation: "ip",
	                        code: ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _regex(regex, validation, message) {
	        return this.refinement((data) => regex.test(data), {
	            validation,
	            code: ZodIssueCode.invalid_string,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    _addCheck(check) {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    email(message) {
	        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
	    }
	    url(message) {
	        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
	    }
	    emoji(message) {
	        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
	    }
	    uuid(message) {
	        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
	    }
	    cuid(message) {
	        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
	    }
	    cuid2(message) {
	        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
	    }
	    ulid(message) {
	        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
	    }
	    ip(options) {
	        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
	    }
	    datetime(options) {
	        var _a;
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "datetime",
	                precision: null,
	                offset: false,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "datetime",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
	            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    regex(regex, message) {
	        return this._addCheck({
	            kind: "regex",
	            regex: regex,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    includes(value, options) {
	        return this._addCheck({
	            kind: "includes",
	            value: value,
	            position: options === null || options === void 0 ? void 0 : options.position,
	            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    startsWith(value, message) {
	        return this._addCheck({
	            kind: "startsWith",
	            value: value,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    endsWith(value, message) {
	        return this._addCheck({
	            kind: "endsWith",
	            value: value,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    min(minLength, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minLength,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    max(maxLength, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxLength,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    length(len, message) {
	        return this._addCheck({
	            kind: "length",
	            value: len,
	            ...errorUtil.errToObj(message),
	        });
	    }
	    /**
	     * @deprecated Use z.string().min(1) instead.
	     * @see {@link ZodString.min}
	     */
	    nonempty(message) {
	        return this.min(1, errorUtil.errToObj(message));
	    }
	    trim() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "trim" }],
	        });
	    }
	    toLowerCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toLowerCase" }],
	        });
	    }
	    toUpperCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toUpperCase" }],
	        });
	    }
	    get isDatetime() {
	        return !!this._def.checks.find((ch) => ch.kind === "datetime");
	    }
	    get isEmail() {
	        return !!this._def.checks.find((ch) => ch.kind === "email");
	    }
	    get isURL() {
	        return !!this._def.checks.find((ch) => ch.kind === "url");
	    }
	    get isEmoji() {
	        return !!this._def.checks.find((ch) => ch.kind === "emoji");
	    }
	    get isUUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "uuid");
	    }
	    get isCUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid");
	    }
	    get isCUID2() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	    }
	    get isULID() {
	        return !!this._def.checks.find((ch) => ch.kind === "ulid");
	    }
	    get isIP() {
	        return !!this._def.checks.find((ch) => ch.kind === "ip");
	    }
	    get minLength() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxLength() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	ZodString.create = (params) => {
	    var _a;
	    return new ZodString({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodString,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
	function floatSafeRemainder(val, step) {
	    const valDecCount = (val.toString().split(".")[1] || "").length;
	    const stepDecCount = (step.toString().split(".")[1] || "").length;
	    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
	    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
	    return (valInt % stepInt) / Math.pow(10, decCount);
	}
	class ZodNumber extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	        this.step = this.multipleOf;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Number(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.number) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.number,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        let ctx = undefined;
	        const status = new ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "int") {
	                if (!util.isInteger(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.invalid_type,
	                        expected: "integer",
	                        received: "float",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (floatSafeRemainder(input.data, check.value) !== 0) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "finite") {
	                if (!Number.isFinite(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_finite,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    int(message) {
	        return this._addCheck({
	            kind: "int",
	            message: errorUtil.toString(message),
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value: value,
	            message: errorUtil.toString(message),
	        });
	    }
	    finite(message) {
	        return this._addCheck({
	            kind: "finite",
	            message: errorUtil.toString(message),
	        });
	    }
	    safe(message) {
	        return this._addCheck({
	            kind: "min",
	            inclusive: true,
	            value: Number.MIN_SAFE_INTEGER,
	            message: errorUtil.toString(message),
	        })._addCheck({
	            kind: "max",
	            inclusive: true,
	            value: Number.MAX_SAFE_INTEGER,
	            message: errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	    get isInt() {
	        return !!this._def.checks.find((ch) => ch.kind === "int" ||
	            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
	    }
	    get isFinite() {
	        let max = null, min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "finite" ||
	                ch.kind === "int" ||
	                ch.kind === "multipleOf") {
	                return true;
	            }
	            else if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	            else if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return Number.isFinite(min) && Number.isFinite(max);
	    }
	}
	ZodNumber.create = (params) => {
	    return new ZodNumber({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodNumber,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBigInt extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = BigInt(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.bigint) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.bigint,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        let ctx = undefined;
	        const status = new ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        type: "bigint",
	                        minimum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        type: "bigint",
	                        maximum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (input.data % check.value !== BigInt(0)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value,
	            message: errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	ZodBigInt.create = (params) => {
	    var _a;
	    return new ZodBigInt({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodBigInt,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBoolean extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Boolean(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.boolean) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.boolean,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodBoolean.create = (params) => {
	    return new ZodBoolean({
	        typeName: ZodFirstPartyTypeKind.ZodBoolean,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodDate extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = new Date(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.date) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.date,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (isNaN(input.data.getTime())) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_date,
	            });
	            return INVALID;
	        }
	        const status = new ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.getTime() < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_small,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        minimum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.getTime() > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.too_big,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        maximum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util.assertNever(check);
	            }
	        }
	        return {
	            status: status.value,
	            value: new Date(input.data.getTime()),
	        };
	    }
	    _addCheck(check) {
	        return new ZodDate({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    min(minDate, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minDate.getTime(),
	            message: errorUtil.toString(message),
	        });
	    }
	    max(maxDate, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxDate.getTime(),
	            message: errorUtil.toString(message),
	        });
	    }
	    get minDate() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min != null ? new Date(min) : null;
	    }
	    get maxDate() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max != null ? new Date(max) : null;
	    }
	}
	ZodDate.create = (params) => {
	    return new ZodDate({
	        checks: [],
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        typeName: ZodFirstPartyTypeKind.ZodDate,
	        ...processCreateParams(params),
	    });
	};
	class ZodSymbol extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.symbol) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.symbol,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodSymbol.create = (params) => {
	    return new ZodSymbol({
	        typeName: ZodFirstPartyTypeKind.ZodSymbol,
	        ...processCreateParams(params),
	    });
	};
	class ZodUndefined extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.undefined,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodUndefined.create = (params) => {
	    return new ZodUndefined({
	        typeName: ZodFirstPartyTypeKind.ZodUndefined,
	        ...processCreateParams(params),
	    });
	};
	class ZodNull extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.null) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.null,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodNull.create = (params) => {
	    return new ZodNull({
	        typeName: ZodFirstPartyTypeKind.ZodNull,
	        ...processCreateParams(params),
	    });
	};
	class ZodAny extends ZodType {
	    constructor() {
	        super(...arguments);
	        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
	        this._any = true;
	    }
	    _parse(input) {
	        return OK(input.data);
	    }
	}
	ZodAny.create = (params) => {
	    return new ZodAny({
	        typeName: ZodFirstPartyTypeKind.ZodAny,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnknown extends ZodType {
	    constructor() {
	        super(...arguments);
	        // required
	        this._unknown = true;
	    }
	    _parse(input) {
	        return OK(input.data);
	    }
	}
	ZodUnknown.create = (params) => {
	    return new ZodUnknown({
	        typeName: ZodFirstPartyTypeKind.ZodUnknown,
	        ...processCreateParams(params),
	    });
	};
	class ZodNever extends ZodType {
	    _parse(input) {
	        const ctx = this._getOrReturnCtx(input);
	        addIssueToContext(ctx, {
	            code: ZodIssueCode.invalid_type,
	            expected: ZodParsedType.never,
	            received: ctx.parsedType,
	        });
	        return INVALID;
	    }
	}
	ZodNever.create = (params) => {
	    return new ZodNever({
	        typeName: ZodFirstPartyTypeKind.ZodNever,
	        ...processCreateParams(params),
	    });
	};
	class ZodVoid extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.void,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	}
	ZodVoid.create = (params) => {
	    return new ZodVoid({
	        typeName: ZodFirstPartyTypeKind.ZodVoid,
	        ...processCreateParams(params),
	    });
	};
	class ZodArray extends ZodType {
	    _parse(input) {
	        const { ctx, status } = this._processInputParams(input);
	        const def = this._def;
	        if (ctx.parsedType !== ZodParsedType.array) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (def.exactLength !== null) {
	            const tooBig = ctx.data.length > def.exactLength.value;
	            const tooSmall = ctx.data.length < def.exactLength.value;
	            if (tooBig || tooSmall) {
	                addIssueToContext(ctx, {
	                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
	                    minimum: (tooSmall ? def.exactLength.value : undefined),
	                    maximum: (tooBig ? def.exactLength.value : undefined),
	                    type: "array",
	                    inclusive: true,
	                    exact: true,
	                    message: def.exactLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.minLength !== null) {
	            if (ctx.data.length < def.minLength.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_small,
	                    minimum: def.minLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxLength !== null) {
	            if (ctx.data.length > def.maxLength.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_big,
	                    maximum: def.maxLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.all([...ctx.data].map((item, i) => {
	                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	            })).then((result) => {
	                return ParseStatus.mergeArray(status, result);
	            });
	        }
	        const result = [...ctx.data].map((item, i) => {
	            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	        });
	        return ParseStatus.mergeArray(status, result);
	    }
	    get element() {
	        return this._def.type;
	    }
	    min(minLength, message) {
	        return new ZodArray({
	            ...this._def,
	            minLength: { value: minLength, message: errorUtil.toString(message) },
	        });
	    }
	    max(maxLength, message) {
	        return new ZodArray({
	            ...this._def,
	            maxLength: { value: maxLength, message: errorUtil.toString(message) },
	        });
	    }
	    length(len, message) {
	        return new ZodArray({
	            ...this._def,
	            exactLength: { value: len, message: errorUtil.toString(message) },
	        });
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	ZodArray.create = (schema, params) => {
	    return new ZodArray({
	        type: schema,
	        minLength: null,
	        maxLength: null,
	        exactLength: null,
	        typeName: ZodFirstPartyTypeKind.ZodArray,
	        ...processCreateParams(params),
	    });
	};
	function deepPartialify(schema) {
	    if (schema instanceof ZodObject) {
	        const newShape = {};
	        for (const key in schema.shape) {
	            const fieldSchema = schema.shape[key];
	            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
	        }
	        return new ZodObject({
	            ...schema._def,
	            shape: () => newShape,
	        });
	    }
	    else if (schema instanceof ZodArray) {
	        return new ZodArray({
	            ...schema._def,
	            type: deepPartialify(schema.element),
	        });
	    }
	    else if (schema instanceof ZodOptional) {
	        return ZodOptional.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodNullable) {
	        return ZodNullable.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodTuple) {
	        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	    }
	    else {
	        return schema;
	    }
	}
	class ZodObject extends ZodType {
	    constructor() {
	        super(...arguments);
	        this._cached = null;
	        /**
	         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	         * If you want to pass through unknown properties, use `.passthrough()` instead.
	         */
	        this.nonstrict = this.passthrough;
	        // extend<
	        //   Augmentation extends ZodRawShape,
	        //   NewOutput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_output"]
	        //       : k extends keyof Output
	        //       ? Output[k]
	        //       : never;
	        //   }>,
	        //   NewInput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_input"]
	        //       : k extends keyof Input
	        //       ? Input[k]
	        //       : never;
	        //   }>
	        // >(
	        //   augmentation: Augmentation
	        // ): ZodObject<
	        //   extendShape<T, Augmentation>,
	        //   UnknownKeys,
	        //   Catchall,
	        //   NewOutput,
	        //   NewInput
	        // > {
	        //   return new ZodObject({
	        //     ...this._def,
	        //     shape: () => ({
	        //       ...this._def.shape(),
	        //       ...augmentation,
	        //     }),
	        //   }) as any;
	        // }
	        /**
	         * @deprecated Use `.extend` instead
	         *  */
	        this.augment = this.extend;
	    }
	    _getCached() {
	        if (this._cached !== null)
	            return this._cached;
	        const shape = this._def.shape();
	        const keys = util.objectKeys(shape);
	        return (this._cached = { shape, keys });
	    }
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.object) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const { status, ctx } = this._processInputParams(input);
	        const { shape, keys: shapeKeys } = this._getCached();
	        const extraKeys = [];
	        if (!(this._def.catchall instanceof ZodNever &&
	            this._def.unknownKeys === "strip")) {
	            for (const key in ctx.data) {
	                if (!shapeKeys.includes(key)) {
	                    extraKeys.push(key);
	                }
	            }
	        }
	        const pairs = [];
	        for (const key of shapeKeys) {
	            const keyValidator = shape[key];
	            const value = ctx.data[key];
	            pairs.push({
	                key: { status: "valid", value: key },
	                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (this._def.catchall instanceof ZodNever) {
	            const unknownKeys = this._def.unknownKeys;
	            if (unknownKeys === "passthrough") {
	                for (const key of extraKeys) {
	                    pairs.push({
	                        key: { status: "valid", value: key },
	                        value: { status: "valid", value: ctx.data[key] },
	                    });
	                }
	            }
	            else if (unknownKeys === "strict") {
	                if (extraKeys.length > 0) {
	                    addIssueToContext(ctx, {
	                        code: ZodIssueCode.unrecognized_keys,
	                        keys: extraKeys,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (unknownKeys === "strip") ;
	            else {
	                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
	            }
	        }
	        else {
	            // run catchall validation
	            const catchall = this._def.catchall;
	            for (const key of extraKeys) {
	                const value = ctx.data[key];
	                pairs.push({
	                    key: { status: "valid", value: key },
	                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
	                    ),
	                    alwaysSet: key in ctx.data,
	                });
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.resolve()
	                .then(async () => {
	                const syncPairs = [];
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    syncPairs.push({
	                        key,
	                        value: await pair.value,
	                        alwaysSet: pair.alwaysSet,
	                    });
	                }
	                return syncPairs;
	            })
	                .then((syncPairs) => {
	                return ParseStatus.mergeObjectSync(status, syncPairs);
	            });
	        }
	        else {
	            return ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get shape() {
	        return this._def.shape();
	    }
	    strict(message) {
	        errorUtil.errToObj;
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strict",
	            ...(message !== undefined
	                ? {
	                    errorMap: (issue, ctx) => {
	                        var _a, _b, _c, _d;
	                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
	                        if (issue.code === "unrecognized_keys")
	                            return {
	                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
	                            };
	                        return {
	                            message: defaultError,
	                        };
	                    },
	                }
	                : {}),
	        });
	    }
	    strip() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strip",
	        });
	    }
	    passthrough() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "passthrough",
	        });
	    }
	    // const AugmentFactory =
	    //   <Def extends ZodObjectDef>(def: Def) =>
	    //   <Augmentation extends ZodRawShape>(
	    //     augmentation: Augmentation
	    //   ): ZodObject<
	    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
	    //     Def["unknownKeys"],
	    //     Def["catchall"]
	    //   > => {
	    //     return new ZodObject({
	    //       ...def,
	    //       shape: () => ({
	    //         ...def.shape(),
	    //         ...augmentation,
	    //       }),
	    //     }) as any;
	    //   };
	    extend(augmentation) {
	        return new ZodObject({
	            ...this._def,
	            shape: () => ({
	                ...this._def.shape(),
	                ...augmentation,
	            }),
	        });
	    }
	    /**
	     * Prior to zod@1.0.12 there was a bug in the
	     * inferred type of merged objects. Please
	     * upgrade if you are experiencing issues.
	     */
	    merge(merging) {
	        const merged = new ZodObject({
	            unknownKeys: merging._def.unknownKeys,
	            catchall: merging._def.catchall,
	            shape: () => ({
	                ...this._def.shape(),
	                ...merging._def.shape(),
	            }),
	            typeName: ZodFirstPartyTypeKind.ZodObject,
	        });
	        return merged;
	    }
	    // merge<
	    //   Incoming extends AnyZodObject,
	    //   Augmentation extends Incoming["shape"],
	    //   NewOutput extends {
	    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_output"]
	    //       : k extends keyof Output
	    //       ? Output[k]
	    //       : never;
	    //   },
	    //   NewInput extends {
	    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_input"]
	    //       : k extends keyof Input
	    //       ? Input[k]
	    //       : never;
	    //   }
	    // >(
	    //   merging: Incoming
	    // ): ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"],
	    //   NewOutput,
	    //   NewInput
	    // > {
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    setKey(key, schema) {
	        return this.augment({ [key]: schema });
	    }
	    // merge<Incoming extends AnyZodObject>(
	    //   merging: Incoming
	    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
	    // ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"]
	    // > {
	    //   // const mergedShape = objectUtil.mergeShapes(
	    //   //   this._def.shape(),
	    //   //   merging._def.shape()
	    //   // );
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    catchall(index) {
	        return new ZodObject({
	            ...this._def,
	            catchall: index,
	        });
	    }
	    pick(mask) {
	        const shape = {};
	        util.objectKeys(mask).forEach((key) => {
	            if (mask[key] && this.shape[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    omit(mask) {
	        const shape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            if (!mask[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    /**
	     * @deprecated
	     */
	    deepPartial() {
	        return deepPartialify(this);
	    }
	    partial(mask) {
	        const newShape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            const fieldSchema = this.shape[key];
	            if (mask && !mask[key]) {
	                newShape[key] = fieldSchema;
	            }
	            else {
	                newShape[key] = fieldSchema.optional();
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    required(mask) {
	        const newShape = {};
	        util.objectKeys(this.shape).forEach((key) => {
	            if (mask && !mask[key]) {
	                newShape[key] = this.shape[key];
	            }
	            else {
	                const fieldSchema = this.shape[key];
	                let newField = fieldSchema;
	                while (newField instanceof ZodOptional) {
	                    newField = newField._def.innerType;
	                }
	                newShape[key] = newField;
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    keyof() {
	        return createZodEnum(util.objectKeys(this.shape));
	    }
	}
	ZodObject.create = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.strictCreate = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strict",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.lazycreate = (shape, params) => {
	    return new ZodObject({
	        shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const options = this._def.options;
	        function handleResults(results) {
	            // return first issue-free validation if it exists
	            for (const result of results) {
	                if (result.result.status === "valid") {
	                    return result.result;
	                }
	            }
	            for (const result of results) {
	                if (result.result.status === "dirty") {
	                    // add issues from dirty option
	                    ctx.common.issues.push(...result.ctx.common.issues);
	                    return result.result;
	                }
	            }
	            // return invalid
	            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return INVALID;
	        }
	        if (ctx.common.async) {
	            return Promise.all(options.map(async (option) => {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                return {
	                    result: await option._parseAsync({
	                        data: ctx.data,
	                        path: ctx.path,
	                        parent: childCtx,
	                    }),
	                    ctx: childCtx,
	                };
	            })).then(handleResults);
	        }
	        else {
	            let dirty = undefined;
	            const issues = [];
	            for (const option of options) {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                const result = option._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: childCtx,
	                });
	                if (result.status === "valid") {
	                    return result;
	                }
	                else if (result.status === "dirty" && !dirty) {
	                    dirty = { result, ctx: childCtx };
	                }
	                if (childCtx.common.issues.length) {
	                    issues.push(childCtx.common.issues);
	                }
	            }
	            if (dirty) {
	                ctx.common.issues.push(...dirty.ctx.common.issues);
	                return dirty.result;
	            }
	            const unionErrors = issues.map((issues) => new ZodError(issues));
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return INVALID;
	        }
	    }
	    get options() {
	        return this._def.options;
	    }
	}
	ZodUnion.create = (types, params) => {
	    return new ZodUnion({
	        options: types,
	        typeName: ZodFirstPartyTypeKind.ZodUnion,
	        ...processCreateParams(params),
	    });
	};
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	//////////                                 //////////
	//////////      ZodDiscriminatedUnion      //////////
	//////////                                 //////////
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	const getDiscriminator = (type) => {
	    if (type instanceof ZodLazy) {
	        return getDiscriminator(type.schema);
	    }
	    else if (type instanceof ZodEffects) {
	        return getDiscriminator(type.innerType());
	    }
	    else if (type instanceof ZodLiteral) {
	        return [type.value];
	    }
	    else if (type instanceof ZodEnum) {
	        return type.options;
	    }
	    else if (type instanceof ZodNativeEnum) {
	        // eslint-disable-next-line ban/ban
	        return Object.keys(type.enum);
	    }
	    else if (type instanceof ZodDefault) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else if (type instanceof ZodUndefined) {
	        return [undefined];
	    }
	    else if (type instanceof ZodNull) {
	        return [null];
	    }
	    else {
	        return null;
	    }
	};
	class ZodDiscriminatedUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.object) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const discriminator = this.discriminator;
	        const discriminatorValue = ctx.data[discriminator];
	        const option = this.optionsMap.get(discriminatorValue);
	        if (!option) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_union_discriminator,
	                options: Array.from(this.optionsMap.keys()),
	                path: [discriminator],
	            });
	            return INVALID;
	        }
	        if (ctx.common.async) {
	            return option._parseAsync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	        else {
	            return option._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	    }
	    get discriminator() {
	        return this._def.discriminator;
	    }
	    get options() {
	        return this._def.options;
	    }
	    get optionsMap() {
	        return this._def.optionsMap;
	    }
	    /**
	     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	     * have a different value for each object in the union.
	     * @param discriminator the name of the discriminator property
	     * @param types an array of object schemas
	     * @param params
	     */
	    static create(discriminator, options, params) {
	        // Get all the valid discriminator values
	        const optionsMap = new Map();
	        // try {
	        for (const type of options) {
	            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
	            if (!discriminatorValues) {
	                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
	            }
	            for (const value of discriminatorValues) {
	                if (optionsMap.has(value)) {
	                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
	                }
	                optionsMap.set(value, type);
	            }
	        }
	        return new ZodDiscriminatedUnion({
	            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
	            discriminator,
	            options,
	            optionsMap,
	            ...processCreateParams(params),
	        });
	    }
	}
	function mergeValues(a, b) {
	    const aType = getParsedType(a);
	    const bType = getParsedType(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
	        const bKeys = util.objectKeys(b);
	        const sharedKeys = util
	            .objectKeys(a)
	            .filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
	        if (a.length !== b.length) {
	            return { valid: false };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    else if (aType === ZodParsedType.date &&
	        bType === ZodParsedType.date &&
	        +a === +b) {
	        return { valid: true, data: a };
	    }
	    else {
	        return { valid: false };
	    }
	}
	class ZodIntersection extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const handleParsed = (parsedLeft, parsedRight) => {
	            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
	                return INVALID;
	            }
	            const merged = mergeValues(parsedLeft.value, parsedRight.value);
	            if (!merged.valid) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.invalid_intersection_types,
	                });
	                return INVALID;
	            }
	            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
	                status.dirty();
	            }
	            return { status: status.value, value: merged.data };
	        };
	        if (ctx.common.async) {
	            return Promise.all([
	                this._def.left._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	                this._def.right._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	            ]).then(([left, right]) => handleParsed(left, right));
	        }
	        else {
	            return handleParsed(this._def.left._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }), this._def.right._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }));
	        }
	    }
	}
	ZodIntersection.create = (left, right, params) => {
	    return new ZodIntersection({
	        left: left,
	        right: right,
	        typeName: ZodFirstPartyTypeKind.ZodIntersection,
	        ...processCreateParams(params),
	    });
	};
	class ZodTuple extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.array) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        if (ctx.data.length < this._def.items.length) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.too_small,
	                minimum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            return INVALID;
	        }
	        const rest = this._def.rest;
	        if (!rest && ctx.data.length > this._def.items.length) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.too_big,
	                maximum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            status.dirty();
	        }
	        const items = [...ctx.data]
	            .map((item, itemIndex) => {
	            const schema = this._def.items[itemIndex] || this._def.rest;
	            if (!schema)
	                return null;
	            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
	        })
	            .filter((x) => !!x); // filter nulls
	        if (ctx.common.async) {
	            return Promise.all(items).then((results) => {
	                return ParseStatus.mergeArray(status, results);
	            });
	        }
	        else {
	            return ParseStatus.mergeArray(status, items);
	        }
	    }
	    get items() {
	        return this._def.items;
	    }
	    rest(rest) {
	        return new ZodTuple({
	            ...this._def,
	            rest,
	        });
	    }
	}
	ZodTuple.create = (schemas, params) => {
	    if (!Array.isArray(schemas)) {
	        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	    }
	    return new ZodTuple({
	        items: schemas,
	        typeName: ZodFirstPartyTypeKind.ZodTuple,
	        rest: null,
	        ...processCreateParams(params),
	    });
	};
	class ZodRecord extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.object) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const pairs = [];
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        for (const key in ctx.data) {
	            pairs.push({
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
	                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
	            });
	        }
	        if (ctx.common.async) {
	            return ParseStatus.mergeObjectAsync(status, pairs);
	        }
	        else {
	            return ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get element() {
	        return this._def.valueType;
	    }
	    static create(first, second, third) {
	        if (second instanceof ZodType) {
	            return new ZodRecord({
	                keyType: first,
	                valueType: second,
	                typeName: ZodFirstPartyTypeKind.ZodRecord,
	                ...processCreateParams(third),
	            });
	        }
	        return new ZodRecord({
	            keyType: ZodString.create(),
	            valueType: first,
	            typeName: ZodFirstPartyTypeKind.ZodRecord,
	            ...processCreateParams(second),
	        });
	    }
	}
	class ZodMap extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.map) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.map,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
	            return {
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
	                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
	            };
	        });
	        if (ctx.common.async) {
	            const finalMap = new Map();
	            return Promise.resolve().then(async () => {
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    if (key.status === "aborted" || value.status === "aborted") {
	                        return INVALID;
	                    }
	                    if (key.status === "dirty" || value.status === "dirty") {
	                        status.dirty();
	                    }
	                    finalMap.set(key.value, value.value);
	                }
	                return { status: status.value, value: finalMap };
	            });
	        }
	        else {
	            const finalMap = new Map();
	            for (const pair of pairs) {
	                const key = pair.key;
	                const value = pair.value;
	                if (key.status === "aborted" || value.status === "aborted") {
	                    return INVALID;
	                }
	                if (key.status === "dirty" || value.status === "dirty") {
	                    status.dirty();
	                }
	                finalMap.set(key.value, value.value);
	            }
	            return { status: status.value, value: finalMap };
	        }
	    }
	}
	ZodMap.create = (keyType, valueType, params) => {
	    return new ZodMap({
	        valueType,
	        keyType,
	        typeName: ZodFirstPartyTypeKind.ZodMap,
	        ...processCreateParams(params),
	    });
	};
	class ZodSet extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.set) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.set,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const def = this._def;
	        if (def.minSize !== null) {
	            if (ctx.data.size < def.minSize.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_small,
	                    minimum: def.minSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minSize.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxSize !== null) {
	            if (ctx.data.size > def.maxSize.value) {
	                addIssueToContext(ctx, {
	                    code: ZodIssueCode.too_big,
	                    maximum: def.maxSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxSize.message,
	                });
	                status.dirty();
	            }
	        }
	        const valueType = this._def.valueType;
	        function finalizeSet(elements) {
	            const parsedSet = new Set();
	            for (const element of elements) {
	                if (element.status === "aborted")
	                    return INVALID;
	                if (element.status === "dirty")
	                    status.dirty();
	                parsedSet.add(element.value);
	            }
	            return { status: status.value, value: parsedSet };
	        }
	        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
	        if (ctx.common.async) {
	            return Promise.all(elements).then((elements) => finalizeSet(elements));
	        }
	        else {
	            return finalizeSet(elements);
	        }
	    }
	    min(minSize, message) {
	        return new ZodSet({
	            ...this._def,
	            minSize: { value: minSize, message: errorUtil.toString(message) },
	        });
	    }
	    max(maxSize, message) {
	        return new ZodSet({
	            ...this._def,
	            maxSize: { value: maxSize, message: errorUtil.toString(message) },
	        });
	    }
	    size(size, message) {
	        return this.min(size, message).max(size, message);
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	ZodSet.create = (valueType, params) => {
	    return new ZodSet({
	        valueType,
	        minSize: null,
	        maxSize: null,
	        typeName: ZodFirstPartyTypeKind.ZodSet,
	        ...processCreateParams(params),
	    });
	};
	class ZodFunction extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.validate = this.implement;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.function) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.function,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        function makeArgsIssue(args, error) {
	            return makeIssue({
	                data: args,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    getErrorMap(),
	                    errorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodIssueCode.invalid_arguments,
	                    argumentsError: error,
	                },
	            });
	        }
	        function makeReturnsIssue(returns, error) {
	            return makeIssue({
	                data: returns,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    getErrorMap(),
	                    errorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodIssueCode.invalid_return_type,
	                    returnTypeError: error,
	                },
	            });
	        }
	        const params = { errorMap: ctx.common.contextualErrorMap };
	        const fn = ctx.data;
	        if (this._def.returns instanceof ZodPromise) {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return OK(async function (...args) {
	                const error = new ZodError([]);
	                const parsedArgs = await me._def.args
	                    .parseAsync(args, params)
	                    .catch((e) => {
	                    error.addIssue(makeArgsIssue(args, e));
	                    throw error;
	                });
	                const result = await Reflect.apply(fn, this, parsedArgs);
	                const parsedReturns = await me._def.returns._def.type
	                    .parseAsync(result, params)
	                    .catch((e) => {
	                    error.addIssue(makeReturnsIssue(result, e));
	                    throw error;
	                });
	                return parsedReturns;
	            });
	        }
	        else {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return OK(function (...args) {
	                const parsedArgs = me._def.args.safeParse(args, params);
	                if (!parsedArgs.success) {
	                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
	                }
	                const result = Reflect.apply(fn, this, parsedArgs.data);
	                const parsedReturns = me._def.returns.safeParse(result, params);
	                if (!parsedReturns.success) {
	                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
	                }
	                return parsedReturns.data;
	            });
	        }
	    }
	    parameters() {
	        return this._def.args;
	    }
	    returnType() {
	        return this._def.returns;
	    }
	    args(...items) {
	        return new ZodFunction({
	            ...this._def,
	            args: ZodTuple.create(items).rest(ZodUnknown.create()),
	        });
	    }
	    returns(returnType) {
	        return new ZodFunction({
	            ...this._def,
	            returns: returnType,
	        });
	    }
	    implement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    strictImplement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    static create(args, returns, params) {
	        return new ZodFunction({
	            args: (args
	                ? args
	                : ZodTuple.create([]).rest(ZodUnknown.create())),
	            returns: returns || ZodUnknown.create(),
	            typeName: ZodFirstPartyTypeKind.ZodFunction,
	            ...processCreateParams(params),
	        });
	    }
	}
	class ZodLazy extends ZodType {
	    get schema() {
	        return this._def.getter();
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const lazySchema = this._def.getter();
	        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	    }
	}
	ZodLazy.create = (getter, params) => {
	    return new ZodLazy({
	        getter: getter,
	        typeName: ZodFirstPartyTypeKind.ZodLazy,
	        ...processCreateParams(params),
	    });
	};
	class ZodLiteral extends ZodType {
	    _parse(input) {
	        if (input.data !== this._def.value) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_literal,
	                expected: this._def.value,
	            });
	            return INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	    get value() {
	        return this._def.value;
	    }
	}
	ZodLiteral.create = (value, params) => {
	    return new ZodLiteral({
	        value: value,
	        typeName: ZodFirstPartyTypeKind.ZodLiteral,
	        ...processCreateParams(params),
	    });
	};
	function createZodEnum(values, params) {
	    return new ZodEnum({
	        values,
	        typeName: ZodFirstPartyTypeKind.ZodEnum,
	        ...processCreateParams(params),
	    });
	}
	class ZodEnum extends ZodType {
	    _parse(input) {
	        if (typeof input.data !== "string") {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            addIssueToContext(ctx, {
	                expected: util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodIssueCode.invalid_type,
	            });
	            return INVALID;
	        }
	        if (this._def.values.indexOf(input.data) === -1) {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	    get options() {
	        return this._def.values;
	    }
	    get enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Values() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    extract(values) {
	        return ZodEnum.create(values);
	    }
	    exclude(values) {
	        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
	    }
	}
	ZodEnum.create = createZodEnum;
	class ZodNativeEnum extends ZodType {
	    _parse(input) {
	        const nativeEnumValues = util.getValidEnumValues(this._def.values);
	        const ctx = this._getOrReturnCtx(input);
	        if (ctx.parsedType !== ZodParsedType.string &&
	            ctx.parsedType !== ZodParsedType.number) {
	            const expectedValues = util.objectValues(nativeEnumValues);
	            addIssueToContext(ctx, {
	                expected: util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodIssueCode.invalid_type,
	            });
	            return INVALID;
	        }
	        if (nativeEnumValues.indexOf(input.data) === -1) {
	            const expectedValues = util.objectValues(nativeEnumValues);
	            addIssueToContext(ctx, {
	                received: ctx.data,
	                code: ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return INVALID;
	        }
	        return OK(input.data);
	    }
	    get enum() {
	        return this._def.values;
	    }
	}
	ZodNativeEnum.create = (values, params) => {
	    return new ZodNativeEnum({
	        values: values,
	        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
	        ...processCreateParams(params),
	    });
	};
	class ZodPromise extends ZodType {
	    unwrap() {
	        return this._def.type;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== ZodParsedType.promise &&
	            ctx.common.async === false) {
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.promise,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        const promisified = ctx.parsedType === ZodParsedType.promise
	            ? ctx.data
	            : Promise.resolve(ctx.data);
	        return OK(promisified.then((data) => {
	            return this._def.type.parseAsync(data, {
	                path: ctx.path,
	                errorMap: ctx.common.contextualErrorMap,
	            });
	        }));
	    }
	}
	ZodPromise.create = (schema, params) => {
	    return new ZodPromise({
	        type: schema,
	        typeName: ZodFirstPartyTypeKind.ZodPromise,
	        ...processCreateParams(params),
	    });
	};
	class ZodEffects extends ZodType {
	    innerType() {
	        return this._def.schema;
	    }
	    sourceType() {
	        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
	            ? this._def.schema.sourceType()
	            : this._def.schema;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const effect = this._def.effect || null;
	        const checkCtx = {
	            addIssue: (arg) => {
	                addIssueToContext(ctx, arg);
	                if (arg.fatal) {
	                    status.abort();
	                }
	                else {
	                    status.dirty();
	                }
	            },
	            get path() {
	                return ctx.path;
	            },
	        };
	        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
	        if (effect.type === "preprocess") {
	            const processed = effect.transform(ctx.data, checkCtx);
	            if (ctx.common.issues.length) {
	                return {
	                    status: "dirty",
	                    value: ctx.data,
	                };
	            }
	            if (ctx.common.async) {
	                return Promise.resolve(processed).then((processed) => {
	                    return this._def.schema._parseAsync({
	                        data: processed,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                });
	            }
	            else {
	                return this._def.schema._parseSync({
	                    data: processed,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	        if (effect.type === "refinement") {
	            const executeRefinement = (acc
	            // effect: RefinementEffect<any>
	            ) => {
	                const result = effect.refinement(acc, checkCtx);
	                if (ctx.common.async) {
	                    return Promise.resolve(result);
	                }
	                if (result instanceof Promise) {
	                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
	                }
	                return acc;
	            };
	            if (ctx.common.async === false) {
	                const inner = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inner.status === "aborted")
	                    return INVALID;
	                if (inner.status === "dirty")
	                    status.dirty();
	                // return value is ignored
	                executeRefinement(inner.value);
	                return { status: status.value, value: inner.value };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((inner) => {
	                    if (inner.status === "aborted")
	                        return INVALID;
	                    if (inner.status === "dirty")
	                        status.dirty();
	                    return executeRefinement(inner.value).then(() => {
	                        return { status: status.value, value: inner.value };
	                    });
	                });
	            }
	        }
	        if (effect.type === "transform") {
	            if (ctx.common.async === false) {
	                const base = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (!isValid(base))
	                    return base;
	                const result = effect.transform(base.value, checkCtx);
	                if (result instanceof Promise) {
	                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
	                }
	                return { status: status.value, value: result };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((base) => {
	                    if (!isValid(base))
	                        return base;
	                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
	                });
	            }
	        }
	        util.assertNever(effect);
	    }
	}
	ZodEffects.create = (schema, effect, params) => {
	    return new ZodEffects({
	        schema,
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        effect,
	        ...processCreateParams(params),
	    });
	};
	ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	    return new ZodEffects({
	        schema,
	        effect: { type: "preprocess", transform: preprocess },
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        ...processCreateParams(params),
	    });
	};
	class ZodOptional extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === ZodParsedType.undefined) {
	            return OK(undefined);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	ZodOptional.create = (type, params) => {
	    return new ZodOptional({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodOptional,
	        ...processCreateParams(params),
	    });
	};
	class ZodNullable extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === ZodParsedType.null) {
	            return OK(null);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	ZodNullable.create = (type, params) => {
	    return new ZodNullable({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodNullable,
	        ...processCreateParams(params),
	    });
	};
	class ZodDefault extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        let data = ctx.data;
	        if (ctx.parsedType === ZodParsedType.undefined) {
	            data = this._def.defaultValue();
	        }
	        return this._def.innerType._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    removeDefault() {
	        return this._def.innerType;
	    }
	}
	ZodDefault.create = (type, params) => {
	    return new ZodDefault({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodDefault,
	        defaultValue: typeof params.default === "function"
	            ? params.default
	            : () => params.default,
	        ...processCreateParams(params),
	    });
	};
	class ZodCatch extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        // newCtx is used to not collect issues from inner types in ctx
	        const newCtx = {
	            ...ctx,
	            common: {
	                ...ctx.common,
	                issues: [],
	            },
	        };
	        const result = this._def.innerType._parse({
	            data: newCtx.data,
	            path: newCtx.path,
	            parent: {
	                ...newCtx,
	            },
	        });
	        if (isAsync(result)) {
	            return result.then((result) => {
	                return {
	                    status: "valid",
	                    value: result.status === "valid"
	                        ? result.value
	                        : this._def.catchValue({
	                            get error() {
	                                return new ZodError(newCtx.common.issues);
	                            },
	                            input: newCtx.data,
	                        }),
	                };
	            });
	        }
	        else {
	            return {
	                status: "valid",
	                value: result.status === "valid"
	                    ? result.value
	                    : this._def.catchValue({
	                        get error() {
	                            return new ZodError(newCtx.common.issues);
	                        },
	                        input: newCtx.data,
	                    }),
	            };
	        }
	    }
	    removeCatch() {
	        return this._def.innerType;
	    }
	}
	ZodCatch.create = (type, params) => {
	    return new ZodCatch({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodCatch,
	        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
	        ...processCreateParams(params),
	    });
	};
	class ZodNaN extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== ZodParsedType.nan) {
	            const ctx = this._getOrReturnCtx(input);
	            addIssueToContext(ctx, {
	                code: ZodIssueCode.invalid_type,
	                expected: ZodParsedType.nan,
	                received: ctx.parsedType,
	            });
	            return INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	}
	ZodNaN.create = (params) => {
	    return new ZodNaN({
	        typeName: ZodFirstPartyTypeKind.ZodNaN,
	        ...processCreateParams(params),
	    });
	};
	const BRAND = Symbol("zod_brand");
	class ZodBranded extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const data = ctx.data;
	        return this._def.type._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    unwrap() {
	        return this._def.type;
	    }
	}
	class ZodPipeline extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.common.async) {
	            const handleAsync = async () => {
	                const inResult = await this._def.in._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inResult.status === "aborted")
	                    return INVALID;
	                if (inResult.status === "dirty") {
	                    status.dirty();
	                    return DIRTY(inResult.value);
	                }
	                else {
	                    return this._def.out._parseAsync({
	                        data: inResult.value,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                }
	            };
	            return handleAsync();
	        }
	        else {
	            const inResult = this._def.in._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	            if (inResult.status === "aborted")
	                return INVALID;
	            if (inResult.status === "dirty") {
	                status.dirty();
	                return {
	                    status: "dirty",
	                    value: inResult.value,
	                };
	            }
	            else {
	                return this._def.out._parseSync({
	                    data: inResult.value,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	    }
	    static create(a, b) {
	        return new ZodPipeline({
	            in: a,
	            out: b,
	            typeName: ZodFirstPartyTypeKind.ZodPipeline,
	        });
	    }
	}
	class ZodReadonly extends ZodType {
	    _parse(input) {
	        const result = this._def.innerType._parse(input);
	        if (isValid(result)) {
	            result.value = Object.freeze(result.value);
	        }
	        return result;
	    }
	}
	ZodReadonly.create = (type, params) => {
	    return new ZodReadonly({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodReadonly,
	        ...processCreateParams(params),
	    });
	};
	const custom = (check, params = {}, 
	/**
	 * @deprecated
	 *
	 * Pass `fatal` into the params object instead:
	 *
	 * ```ts
	 * z.string().custom((val) => val.length > 5, { fatal: false })
	 * ```
	 *
	 */
	fatal) => {
	    if (check)
	        return ZodAny.create().superRefine((data, ctx) => {
	            var _a, _b;
	            if (!check(data)) {
	                const p = typeof params === "function"
	                    ? params(data)
	                    : typeof params === "string"
	                        ? { message: params }
	                        : params;
	                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
	                const p2 = typeof p === "string" ? { message: p } : p;
	                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
	            }
	        });
	    return ZodAny.create();
	};
	const late = {
	    object: ZodObject.lazycreate,
	};
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
	    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
	    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
	    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
	    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
	    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
	    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
	    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
	    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
	    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
	    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
	    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
	    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
	    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
	    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
	    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
	    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
	    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
	    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
	    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
	    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
	    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
	    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
	    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
	    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
	    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
	    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
	    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
	    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
	    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
	    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
	    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
	    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
	    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
	    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
	})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
	const instanceOfType = (
	// const instanceOfType = <T extends new (...args: any[]) => any>(
	cls, params = {
	    message: `Input not instance of ${cls.name}`,
	}) => custom((data) => data instanceof cls, params);
	const stringType = ZodString.create;
	const numberType = ZodNumber.create;
	const nanType = ZodNaN.create;
	const bigIntType = ZodBigInt.create;
	const booleanType = ZodBoolean.create;
	const dateType = ZodDate.create;
	const symbolType = ZodSymbol.create;
	const undefinedType = ZodUndefined.create;
	const nullType = ZodNull.create;
	const anyType = ZodAny.create;
	const unknownType = ZodUnknown.create;
	const neverType = ZodNever.create;
	const voidType = ZodVoid.create;
	const arrayType = ZodArray.create;
	const objectType = ZodObject.create;
	const strictObjectType = ZodObject.strictCreate;
	const unionType = ZodUnion.create;
	const discriminatedUnionType = ZodDiscriminatedUnion.create;
	const intersectionType = ZodIntersection.create;
	const tupleType = ZodTuple.create;
	const recordType = ZodRecord.create;
	const mapType = ZodMap.create;
	const setType = ZodSet.create;
	const functionType = ZodFunction.create;
	const lazyType = ZodLazy.create;
	const literalType = ZodLiteral.create;
	const enumType = ZodEnum.create;
	const nativeEnumType = ZodNativeEnum.create;
	const promiseType = ZodPromise.create;
	const effectsType = ZodEffects.create;
	const optionalType = ZodOptional.create;
	const nullableType = ZodNullable.create;
	const preprocessType = ZodEffects.createWithPreprocess;
	const pipelineType = ZodPipeline.create;
	const ostring = () => stringType().optional();
	const onumber = () => numberType().optional();
	const oboolean = () => booleanType().optional();
	const coerce = {
	    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
	    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
	    boolean: ((arg) => ZodBoolean.create({
	        ...arg,
	        coerce: true,
	    })),
	    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
	    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
	};
	const NEVER = INVALID;

	var z = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    defaultErrorMap: errorMap,
	    setErrorMap: setErrorMap,
	    getErrorMap: getErrorMap,
	    makeIssue: makeIssue,
	    EMPTY_PATH: EMPTY_PATH,
	    addIssueToContext: addIssueToContext,
	    ParseStatus: ParseStatus,
	    INVALID: INVALID,
	    DIRTY: DIRTY,
	    OK: OK,
	    isAborted: isAborted,
	    isDirty: isDirty,
	    isValid: isValid,
	    isAsync: isAsync,
	    get util () { return util; },
	    get objectUtil () { return objectUtil; },
	    ZodParsedType: ZodParsedType,
	    getParsedType: getParsedType,
	    ZodType: ZodType,
	    ZodString: ZodString,
	    ZodNumber: ZodNumber,
	    ZodBigInt: ZodBigInt,
	    ZodBoolean: ZodBoolean,
	    ZodDate: ZodDate,
	    ZodSymbol: ZodSymbol,
	    ZodUndefined: ZodUndefined,
	    ZodNull: ZodNull,
	    ZodAny: ZodAny,
	    ZodUnknown: ZodUnknown,
	    ZodNever: ZodNever,
	    ZodVoid: ZodVoid,
	    ZodArray: ZodArray,
	    ZodObject: ZodObject,
	    ZodUnion: ZodUnion,
	    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
	    ZodIntersection: ZodIntersection,
	    ZodTuple: ZodTuple,
	    ZodRecord: ZodRecord,
	    ZodMap: ZodMap,
	    ZodSet: ZodSet,
	    ZodFunction: ZodFunction,
	    ZodLazy: ZodLazy,
	    ZodLiteral: ZodLiteral,
	    ZodEnum: ZodEnum,
	    ZodNativeEnum: ZodNativeEnum,
	    ZodPromise: ZodPromise,
	    ZodEffects: ZodEffects,
	    ZodTransformer: ZodEffects,
	    ZodOptional: ZodOptional,
	    ZodNullable: ZodNullable,
	    ZodDefault: ZodDefault,
	    ZodCatch: ZodCatch,
	    ZodNaN: ZodNaN,
	    BRAND: BRAND,
	    ZodBranded: ZodBranded,
	    ZodPipeline: ZodPipeline,
	    ZodReadonly: ZodReadonly,
	    custom: custom,
	    Schema: ZodType,
	    ZodSchema: ZodType,
	    late: late,
	    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
	    coerce: coerce,
	    any: anyType,
	    array: arrayType,
	    bigint: bigIntType,
	    boolean: booleanType,
	    date: dateType,
	    discriminatedUnion: discriminatedUnionType,
	    effect: effectsType,
	    'enum': enumType,
	    'function': functionType,
	    'instanceof': instanceOfType,
	    intersection: intersectionType,
	    lazy: lazyType,
	    literal: literalType,
	    map: mapType,
	    nan: nanType,
	    nativeEnum: nativeEnumType,
	    never: neverType,
	    'null': nullType,
	    nullable: nullableType,
	    number: numberType,
	    object: objectType,
	    oboolean: oboolean,
	    onumber: onumber,
	    optional: optionalType,
	    ostring: ostring,
	    pipeline: pipelineType,
	    preprocess: preprocessType,
	    promise: promiseType,
	    record: recordType,
	    set: setType,
	    strictObject: strictObjectType,
	    string: stringType,
	    symbol: symbolType,
	    transformer: effectsType,
	    tuple: tupleType,
	    'undefined': undefinedType,
	    union: unionType,
	    unknown: unknownType,
	    'void': voidType,
	    NEVER: NEVER,
	    ZodIssueCode: ZodIssueCode,
	    quotelessJson: quotelessJson,
	    ZodError: ZodError
	});

	const WRONG_STRING_LENGTH = "wrong string length";
	const BlockIdentifierSchema = z.union([
	    z
	        .string()
	        .refine((val) => /^[0-9a-fA-F]{64}$/.test(val), WRONG_STRING_LENGTH),
	    z.number(),
	]);
	const isBlockIdentifierValid = (blockIdentifier, options) => {
	    const ctx = BlockIdentifierSchema.safeParse(blockIdentifier);
	    const { success } = ctx;
	    const hasError = "error" in ctx;
	    const { throwOnError = false } = options || {};
	    if (!hasError) {
	        return { success };
	    }
	    const { error } = ctx;
	    const isInvalidInputType = error.issues.some(({ code }) => code === "invalid_union");
	    const isInvalidStringLength = error.issues.some(({ message }) => message === WRONG_STRING_LENGTH);
	    const message = (() => {
	        if (isInvalidInputType) {
	            return `Invalid "blockIdentifier" type. Expected string or number, but received ${typeof blockIdentifier}.`;
	        }
	        if (isInvalidStringLength) {
	            return "Parameter 'blockIdentifier' does not have the correct format (64-character hexadecimal string).";
	        }
	        return error.issues.map((issue) => issue.message).join(", ");
	    })();
	    if (throwOnError) {
	        throw new Error(message);
	    }
	    return {
	        success,
	        error,
	        message: error.issues.map((issue) => issue.message).join(", "),
	    };
	};

	const IdentifierSchema = z.union([
	    z.object({
	        blockchainRid: z.undefined(),
	        blockchainIid: z.number(),
	    }),
	    z.object({
	        blockchainRid: z.string(),
	        blockchainIid: z.undefined(),
	    }),
	]);
	const NodeUrlSchema = z.union([
	    z.object({
	        nodeUrlPool: z.union([z.string(), z.array(z.string())]),
	        directoryNodeUrlPool: z.undefined(),
	    }),
	    z.object({
	        nodeUrlPool: z.undefined(),
	        directoryNodeUrlPool: z.union([z.string(), z.array(z.string())]),
	    }),
	]);
	const RestNetworkSettingsSchema = z.object({
	    statusPollingInterval: z.number().optional(),
	    statusPollingCount: z.number().optional(),
	    failOverConfig: z
	        .object({
	        strategy: z.nativeEnum(exports.FailoverStrategy).optional(),
	        attemptsPerEndpoint: z.number().optional(),
	        attemptInterval: z.number().optional(),
	        unreachableDuration: z.number().optional(),
	    })
	        .optional(),
	});
	const validateBlockChainIdentifier = (networkSettings, options) => {
	    const { throwOnError = false } = options || {};
	    const identifierValidationContext = IdentifierSchema.safeParse(networkSettings);
	    if ("error" in identifierValidationContext) {
	        const missingBlockchainIdentifierError = new MissingBlockchainIdentifierError();
	        if (throwOnError) {
	            throw missingBlockchainIdentifierError;
	        }
	        return {
	            success: identifierValidationContext.success,
	            error: identifierValidationContext.error,
	            message: missingBlockchainIdentifierError.message,
	        };
	    }
	    return { success: true };
	};
	const validateNodeUrl = (networkSettings, options) => {
	    const { throwOnError = false } = options || {};
	    const nodeUrlValidationContext = NodeUrlSchema.safeParse(networkSettings);
	    if ("error" in nodeUrlValidationContext) {
	        const missingNodeUrlError = new MissingNodeUrlError();
	        if (throwOnError) {
	            throw missingNodeUrlError;
	        }
	        return {
	            success: nodeUrlValidationContext.success,
	            error: nodeUrlValidationContext.error,
	            message: missingNodeUrlError.message,
	        };
	    }
	    return { success: true };
	};
	const validateRestNetworkSettings = (networkSettings, options) => {
	    const { throwOnError = false } = options || {};
	    const restNetworkSettingsValidationContext = RestNetworkSettingsSchema.safeParse(networkSettings);
	    if ("error" in restNetworkSettingsValidationContext) {
	        const { error: { issues }, } = restNetworkSettingsValidationContext;
	        const errorMessage = issues
	            .map(({ message, path }) => `${path[0]}: ${message}`)
	            .join(", ");
	        if (throwOnError) {
	            throw new Error(errorMessage);
	        }
	        return {
	            success: restNetworkSettingsValidationContext.success,
	            error: restNetworkSettingsValidationContext.error,
	            message: errorMessage,
	        };
	    }
	    return { success: true };
	};
	const isNetworkSettingValid = (networkSettings, options) => {
	    const identifierValidationContext = validateBlockChainIdentifier(networkSettings, options);
	    if ("error" in identifierValidationContext) {
	        return identifierValidationContext;
	    }
	    const nodeUrlValidationContext = validateNodeUrl(networkSettings, options);
	    if ("error" in nodeUrlValidationContext) {
	        return nodeUrlValidationContext;
	    }
	    const restNetworkSettingsValidationContext = validateRestNetworkSettings(networkSettings, options);
	    if ("error" in restNetworkSettingsValidationContext) {
	        return restNetworkSettingsValidationContext;
	    }
	    return { success: true };
	};

	const BufferSchema = z.union([
	    z.instanceof(Uint8Array),
	    z.instanceof(require$$0$3.Buffer),
	]);

	const KeyPairSchema = z.object({
	    privKey: BufferSchema,
	    pubKey: BufferSchema,
	});
	const SignatureProviderSchema = z.object({
	    pubKey: BufferSchema,
	    sign: z.function().args(BufferSchema).returns(z.promise(BufferSchema)),
	});
	const SignMethodSchema = z.union([
	    KeyPairSchema,
	    SignatureProviderSchema,
	]);
	const isSignMethodValid = (signMethod, options) => {
	    const signMethodValidationCtx = SignMethodSchema.safeParse(signMethod);
	    const { throwOnError = false } = options || {};
	    const hasError = "error" in signMethodValidationCtx;
	    if (!hasError) {
	        return { success: true };
	    }
	    const message = "Invalid sign method";
	    if (throwOnError) {
	        throw new Error(message);
	    }
	    return {
	        success: false,
	        error: signMethodValidationCtx.error,
	        message,
	    };
	};

	const TxRidSchema = BufferSchema.refine((x) => x.length === 32, "Rid must be 32 bytes long");
	const isTxRidValid = (rid, options) => {
	    const TxRidValidationContext = TxRidSchema.safeParse(rid);
	    const { throwOnError = false } = options || {};
	    const hasError = "error" in TxRidValidationContext;
	    if (!hasError) {
	        return { success: true };
	    }
	    const validationError = new InvalidTxRidException(rid);
	    if (throwOnError) {
	        throw validationError;
	    }
	    return {
	        success: false,
	        error: TxRidValidationContext.error,
	        message: validationError.message,
	    };
	};

	var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function createClient(settings) {
	    return __awaiter$7(this, void 0, void 0, function* () {
	        isNetworkSettingValid(settings, { throwOnError: true });
	        return {
	            config: yield getClientConfigFromSettings(settings),
	            query(nameOrQueryObject, args, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    let _name, _args;
	                    if (typeof nameOrQueryObject === "string") {
	                        _name = nameOrQueryObject;
	                        _args = args;
	                    }
	                    else {
	                        _name = nameOrQueryObject === null || nameOrQueryObject === void 0 ? void 0 : nameOrQueryObject.name;
	                        _args = nameOrQueryObject === null || nameOrQueryObject === void 0 ? void 0 : nameOrQueryObject.args;
	                    }
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `query_gtv/${this.config.blockchainRid}`, this.config, encodeValue(toQueryObjectGTV(_name, _args)));
	                    return new Promise((resolve, reject) => {
	                        handlePostResponse(error, statusCode, rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            signTransaction(transaction, signMethod, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    debug(`Signing transaction with ${!isKeyPair(signMethod) ? "signature provider containing " : ""}pubKey: ${toString(signMethod.pubKey)}`);
	                    const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
	                    try {
	                        const signedTx = yield (isKeyPair(signMethod)
	                            ? sign(gtx$1, signMethod.privKey, signMethod.pubKey)
	                            : sign(gtx$1, signMethod));
	                        const gtxBytes = getSerializedGTX(signedTx);
	                        if (typeof callback === "function") {
	                            callback(null, gtxBytes);
	                        }
	                        return gtxBytes;
	                    }
	                    catch (error) {
	                        if (typeof callback === "function") {
	                            callback(error, null);
	                        }
	                        throw new Error(error);
	                    }
	                });
	            },
	            sendTransaction(transaction, doStatusPolling = true, callback = undefined) {
	                const promiEvent = new Web3PromiEvent((resolve, reject) => __awaiter$7(this, void 0, void 0, function* () {
	                    var _a;
	                    try {
	                        const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
	                        if (gtx$1.signers.length !== ((_a = gtx$1.signatures) === null || _a === void 0 ? void 0 : _a.length)) {
	                            reject(new NumberOfSignersAndSignaturesException());
	                        }
	                        const gtxBytes = getSerializedGTX(gtx$1);
	                        const transactionObject = {
	                            tx: gtxBytes.toString("hex"),
	                        };
	                        const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `tx/${this.config.blockchainRid}`, this.config, transactionObject);
	                        const transactionRid = getDigestToSign(gtx$1);
	                        try {
	                            yield handlePostResponsePromisified(error, statusCode, rspBody);
	                            if (typeof callback === "function") {
	                                callback(null, {
	                                    status: exports.ResponseStatus.Waiting,
	                                    statusCode,
	                                    transactionRid: transactionRid,
	                                });
	                            }
	                        }
	                        catch (_error) {
	                            if (typeof callback === "function") {
	                                callback(_error, null);
	                            }
	                            return reject(_error);
	                        }
	                        const transactionReceipt = {
	                            status: exports.ResponseStatus.Waiting,
	                            statusCode: statusCode,
	                            transactionRid: transactionRid,
	                        };
	                        promiEvent.emit("sent", transactionReceipt);
	                        if (doStatusPolling === false) {
	                            return resolve(transactionReceipt);
	                        }
	                        const awaitConfirmation = (txRID) => __awaiter$7(this, void 0, void 0, function* () {
	                            var _b;
	                            let lastKnownResult;
	                            for (let i = 0; i < this.config.statusPollCount; i++) {
	                                lastKnownResult = yield this.getTransactionStatus(txRID);
	                                if (lastKnownResult.status === exports.ResponseStatus.Confirmed) {
	                                    return exports.ResponseStatus.Confirmed;
	                                }
	                                else if (lastKnownResult.status === exports.ResponseStatus.Rejected) {
	                                    throw new TxRejectedError((_b = lastKnownResult.rejectReason) !== null && _b !== void 0 ? _b : "");
	                                }
	                                yield sleep(this.config.statusPollInterval);
	                            }
	                            // TS issue. This could be fixed by inplementing new retry strategy
	                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	                            //@ts-expect-error
	                            return lastKnownResult.status;
	                        });
	                        const confirmationStatus = yield awaitConfirmation(getDigestToSign(gtx$1));
	                        resolve({
	                            status: confirmationStatus,
	                            statusCode: statusCode,
	                            transactionRid: transactionRid,
	                        });
	                    }
	                    catch (error) {
	                        reject(error);
	                    }
	                }));
	                return promiEvent;
	            },
	            signAndSendUniqueTransaction(transactionOrOperation, signMethod, doStatusPolling = true, callback = undefined) {
	                isSignMethodValid(signMethod, { throwOnError: true });
	                const promiEvent = new Web3PromiEvent((resolve, reject) => {
	                    const transaction = "name" in transactionOrOperation
	                        ? {
	                            operations: [transactionOrOperation],
	                            signers: [signMethod.pubKey],
	                        }
	                        : transactionOrOperation;
	                    const hasNop = transaction.operations.some((operation) => {
	                        return operation.name === "nop";
	                    });
	                    const transactionWithNop = hasNop
	                        ? transaction
	                        : this.addNop(transaction);
	                    this.signTransaction(transactionWithNop, signMethod)
	                        .then((signedTx) => {
	                        const sendTransactionPromiEvent = this.sendTransaction(signedTx, doStatusPolling, callback);
	                        sendTransactionPromiEvent.on("sent", (receipt) => {
	                            promiEvent.emit("sent", receipt);
	                        });
	                        resolve(sendTransactionPromiEvent);
	                    })
	                        .catch((error) => {
	                        reject(error);
	                    });
	                });
	                return promiEvent;
	            },
	            getTransaction(transactionRid, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    try {
	                        isTxRidValid(transactionRid, { throwOnError: true });
	                    }
	                    catch (error) {
	                        callback === null || callback === void 0 ? void 0 : callback(error, null);
	                        throw error;
	                    }
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${transactionRid.toString("hex")}`, this.config);
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 ? toBuffer$3(rspBody.tx) : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getTransactionStatus(transactionRid, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    try {
	                        isTxRidValid(transactionRid, { throwOnError: true });
	                    }
	                    catch (error) {
	                        callback === null || callback === void 0 ? void 0 : callback(error, null);
	                        throw error;
	                    }
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${transactionRid.toString("hex")}/status`, this.config);
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            addNop(transaction) {
	                const _transaction = cloneDeep$1(transaction);
	                const noOperation = {
	                    name: "nop",
	                    args: [cryptoBrowserifyExports.randomBytes(32)],
	                };
	                _transaction.operations = [..._transaction.operations, noOperation];
	                return _transaction;
	            },
	            getTransactionRid(transaction) {
	                try {
	                    const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
	                    return getDigestToSign(gtx$1);
	                }
	                catch (e) {
	                    throw new GetTransactionRidException(e);
	                }
	            },
	            getTransactionsInfo(limit = 25, beforeTime, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    const beforeTimeQueryParam = beforeTime
	                        ? `&before-time=${beforeTime.getTime()}`
	                        : "";
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}?limit=${limit}${beforeTimeQueryParam}`, this.config);
	                    const body = statusCode === 200
	                        ? rspBody === null || rspBody === void 0 ? void 0 : rspBody.map(formatTransactionInfoResponse)
	                        : rspBody;
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, body, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getTransactionInfo(transactionRid, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    try {
	                        isTxRidValid(transactionRid, { throwOnError: true });
	                    }
	                    catch (error) {
	                        callback === null || callback === void 0 ? void 0 : callback(error, null);
	                        throw error;
	                    }
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}/${toString(transactionRid)}`, this.config);
	                    const body = statusCode === 200 && rspBody
	                        ? formatTransactionInfoResponse(rspBody)
	                        : rspBody;
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, body, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getTransactionCount(callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `transactions/${this.config.blockchainRid}/count`, this.config);
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 ? rspBody.transactionsCount : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getBlockInfo(blockIdentifier, txs = false, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    isBlockIdentifierValid(blockIdentifier, { throwOnError: true });
	                    const queryString = typeof blockIdentifier === "string"
	                        ? blockIdentifier
	                        : `height/${blockIdentifier}`;
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}/${queryString}?txs=${txs}`, this.config);
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody !== null && rspBody
	                            ? formatBlockInfoResponse(rspBody)
	                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getLatestBlock(txs = false, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    const shouldIncludeFullTransaction = txs ? `&txs=${txs}` : "";
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}?limit=1${shouldIncludeFullTransaction}`, this.config);
	                    const indexOfLatestBlock = 0;
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody !== null && rspBody
	                            ? formatBlockInfoResponse(rspBody[indexOfLatestBlock])
	                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            getBlocksInfo(limit = 25, beforeTime, beforeHeight, txs, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    let filteringQueryParam = "";
	                    if (beforeTime) {
	                        filteringQueryParam = `&before-time=${beforeTime.getTime()}`;
	                    }
	                    else if (beforeHeight) {
	                        filteringQueryParam = `&before-height=${beforeHeight}`;
	                    }
	                    const shouldIncludeFullTransaction = txs ? `&txs=${txs}` : "";
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `blocks/${this.config.blockchainRid}?limit=${limit}${filteringQueryParam}${shouldIncludeFullTransaction}`, this.config);
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 && rspBody
	                            ? rspBody.map(formatBlockInfoResponse)
	                            : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	            encodeTransaction(transaction) {
	                const gtx$1 = getGTXFromBufferOrTransactionOrOperation(transaction, this.config.blockchainRid);
	                return serialize(gtx$1);
	            },
	            decodeTransactionToGtx(encodedTransaction) {
	                const gtx$1 = deserialize(encodedTransaction);
	                debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
	                return gtx$1;
	            },
	            getClientNodeUrlPool() {
	                return this.config.endpointPool.map((endpoint) => endpoint.url);
	            },
	            /**
	             * Retrieves a confirmation proof for a transaction with the specified sha256
	             * hash.
	             * @param txRid A buffer of 32 bytes
	             * @param callback parameters (error, responseObjectProof) if first
	             * parameter is not null, an error occurred.
	             * If first parameter is null, then the second parameter is an object
	             * like the following:
	             *
	             * {hash: messageHashBuffer,
	             *  blockHeader: blockHeaderBuffer,
	             *  signatures: [{pubKey: pubKeyBuffer, signature: sigBuffer}, ...],
	             *  merklePath: [{side: <0|1>, hash: <hash buffer level n-1>},
	             *               ...
	             *               {side: <0|1>, hash: <hash buffer level 1>}]}
	             *
	             * If no such transaction RID exists, the callback will be called with (null, null).
	             *
	             * The proof object can be validated using
	             * postchain-common.util.validateMerklePath(proof.merklePath, proof.hash,
	             * proof.blockHeader.slice(32, 64))
	             *
	             * The signatures must be validated agains some know trusted source for valid signers
	             * at this specific block height.
	             */
	            getConfirmationProof: function (txRid, callback) {
	                return __awaiter$7(this, void 0, void 0, function* () {
	                    try {
	                        isTxRidValid(txRid, { throwOnError: true });
	                    }
	                    catch (error) {
	                        callback === null || callback === void 0 ? void 0 : callback(error, null);
	                        throw error;
	                    }
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${this.config.blockchainRid}/${txRid.toString("hex")}/confirmationProof`, this.config);
	                    const confirmationProof = {
	                        merkleProofTree: "",
	                        txIndex: 0,
	                    };
	                    if (statusCode === 200) {
	                        try {
	                            const decodedProof = decodeValue(toBuffer$3(rspBody.proof));
	                            confirmationProof.txIndex = decodedProof.txIndex;
	                            confirmationProof.hash = decodedProof.hash;
	                            confirmationProof.blockHeader = decodedProof.blockHeader;
	                            confirmationProof.witness = decodedProof.witness;
	                            confirmationProof.merkleProofTree = decodedProof.merkleProofTree;
	                        }
	                        catch (decodeError) {
	                            if (callback) {
	                                callback(decodeError, null);
	                            }
	                            throw decodeError;
	                        }
	                    }
	                    return new Promise((resolve, reject) => {
	                        handleGetResponse(error, statusCode, statusCode === 200 ? confirmationProof : rspBody, callbackPromiseBuilder(reject, resolve, callback));
	                    });
	                });
	            },
	        };
	    });
	}

	var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function getClientConfigFromSettings(settings) {
	    var _a, _b, _c, _d, _e, _f;
	    return __awaiter$6(this, void 0, void 0, function* () {
	        const nodeUrlPoolToUse = yield getNodeUrlsFromSettings(settings);
	        if (nodeUrlPoolToUse.length === 0) {
	            const id = (_b = (_a = settings.blockchainRid) !== null && _a !== void 0 ? _a : settings.blockchainIid) !== null && _b !== void 0 ? _b : "Unknown";
	            throw new BlockchainUrlUndefinedException(id);
	        }
	        const endpointPool = createEndpointObjects(nodeUrlPoolToUse);
	        const blockchainRidToUse = yield (() => __awaiter$6(this, void 0, void 0, function* () {
	            if (settings.blockchainRid) {
	                return settings.blockchainRid;
	            }
	            if (settings.blockchainIid !== undefined) {
	                return yield getBlockchainRidFromIid(endpointPool, settings.blockchainIid);
	            }
	            throw new MissingBlockchainIdentifierError();
	        }))();
	        return {
	            endpointPool,
	            blockchainRid: blockchainRidToUse,
	            statusPollInterval: settings.statusPollInterval || 500,
	            statusPollCount: settings.statusPollCount || 20,
	            failoverStrategy: ((_c = settings.failOverConfig) === null || _c === void 0 ? void 0 : _c.strategy) || defaultFailoverConfig.strategy,
	            attemptsPerEndpoint: ((_d = settings.failOverConfig) === null || _d === void 0 ? void 0 : _d.attemptsPerEndpoint) ||
	                defaultFailoverConfig.attemptsPerEndpoint,
	            attemptInterval: ((_e = settings.failOverConfig) === null || _e === void 0 ? void 0 : _e.attemptInterval) ||
	                defaultFailoverConfig.attemptInterval,
	            unreachableDuration: ((_f = settings.failOverConfig) === null || _f === void 0 ? void 0 : _f.unreachableDuration) ||
	                defaultFailoverConfig.unreachableDuration,
	        };
	    });
	}
	function nodeDiscovery(directoryEndpointPool, failOverConfig, blockchainRid, blockchainIid) {
	    return __awaiter$6(this, void 0, void 0, function* () {
	        if (directoryEndpointPool.length === 0) {
	            throw new DirectoryNodeUrlPoolException();
	        }
	        if (!blockchainRid && blockchainIid === undefined) {
	            throw new MissingBlockchainIdentifierError();
	        }
	        const directoryIid = 0;
	        const directoryBRID = yield getBlockchainRidFromIid(directoryEndpointPool, directoryIid, failOverConfig);
	        const blockchainRidToUse = yield (() => __awaiter$6(this, void 0, void 0, function* () {
	            if (blockchainRid) {
	                return blockchainRid;
	            }
	            if (blockchainIid !== undefined) {
	                return yield getBlockchainRidFromIid(directoryEndpointPool, blockchainIid, failOverConfig);
	            }
	            throw new MissingBlockchainIdentifierError();
	        }))();
	        const queryObject = {
	            name: "cm_get_blockchain_api_urls",
	            args: { blockchain_rid: toBuffer$3(blockchainRidToUse) },
	        };
	        const D1Client = yield createClient({
	            nodeUrlPool: getUrlsFromEndpoints(directoryEndpointPool),
	            blockchainRid: directoryBRID,
	        });
	        const baseUrls = yield D1Client.query(queryObject);
	        return baseUrls;
	    });
	}
	function convertToRellOperation(operations) {
	    return operations.map((operation) => {
	        var _a;
	        return {
	            opName: operation.name,
	            args: (_a = operation.args) !== null && _a !== void 0 ? _a : [],
	        };
	    });
	}
	function getSerializedGTX(gtx$1) {
	    const gtxBytes = serialize(gtx$1);
	    if (!require$$0$3.Buffer.isBuffer(gtxBytes)) {
	        throw new SerializedTransactionFormatException();
	    }
	    return gtxBytes;
	}
	function getGTXFromBufferOrTransactionOrOperation(transaction, blockchainRid) {
	    if (require$$0$3.Buffer.isBuffer(transaction)) {
	        return deserialize(transaction);
	    }
	    else if ("operations" in transaction) {
	        return {
	            blockchainRid: toBuffer$3(blockchainRid),
	            operations: convertToRellOperation(transaction.operations),
	            signers: transaction.signers,
	            signatures: [],
	        };
	    }
	    else if ("name" in transaction) {
	        return {
	            blockchainRid: toBuffer$3(blockchainRid),
	            operations: convertToRellOperation([transaction]),
	            signers: [],
	            signatures: [],
	        };
	    }
	    else {
	        throw new InvalidTransactionFormatException();
	    }
	}
	const callbackPromiseBuilder = (reject, resolve, callback) => {
	    return (error, result) => {
	        if (error) {
	            if (typeof callback === "function") {
	                callback(error, null);
	            }
	            reject(error);
	        }
	        else {
	            if (typeof callback === "function") {
	                callback(null, result);
	            }
	            resolve(result);
	        }
	    };
	};
	const handlePostResponsePromisified = (error, statusCode, rspBody) => {
	    return new Promise((resolve, reject) => {
	        handlePostResponse(error, statusCode, rspBody, (_error) => {
	            if (_error) {
	                reject(_error);
	            }
	            else {
	                resolve();
	            }
	        });
	    });
	};
	function ensureArray(input) {
	    if (typeof input === "string") {
	        return [input];
	    }
	    return input;
	}
	const formatTransactionInfoResponse = (transactionInfoResponse) => {
	    return {
	        blockRid: toBuffer$3(transactionInfoResponse.blockRID),
	        blockHeight: transactionInfoResponse.blockHeight,
	        blockHeader: toBuffer$3(transactionInfoResponse.blockHeader),
	        witness: toBuffer$3(transactionInfoResponse.witness),
	        timestamp: transactionInfoResponse.timestamp,
	        txRid: toBuffer$3(transactionInfoResponse.txRID),
	        txHash: toBuffer$3(transactionInfoResponse.txHash),
	        txData: toBuffer$3(transactionInfoResponse.txData),
	    };
	};
	const formatBlockInfoResponse = (blockInfoResponse) => {
	    return {
	        rid: toBuffer$3(blockInfoResponse.rid),
	        prevBlockRid: toBuffer$3(blockInfoResponse.prevBlockRID),
	        header: toBuffer$3(blockInfoResponse.header),
	        transactions: blockInfoResponse.transactions.map(formatTransaction),
	        height: blockInfoResponse.height,
	        witness: toBuffer$3(blockInfoResponse.witness),
	        witnesses: blockInfoResponse.witnesses.map((witness) => {
	            return toBuffer$3(witness);
	        }),
	        timestamp: blockInfoResponse.timestamp,
	    };
	};
	const formatTransaction = (transaction) => {
	    const formattedTransaction = {
	        rid: toBuffer$3(transaction.rid),
	        hash: toBuffer$3(transaction.hash),
	    };
	    if (transaction.data !== undefined) {
	        formattedTransaction.data = toBuffer$3(transaction.data);
	    }
	    return formattedTransaction;
	};
	const isKeyPair = (keypair) => {
	    return (typeof keypair === "object" &&
	        keypair !== null &&
	        "privKey" in keypair &&
	        "pubKey" in keypair &&
	        keypair.privKey instanceof require$$0$3.Buffer &&
	        keypair.pubKey instanceof require$$0$3.Buffer);
	};
	function getNodeUrlsFromSettings(settings) {
	    return __awaiter$6(this, void 0, void 0, function* () {
	        if (settings.directoryNodeUrlPool) {
	            // If directoryNodeUrlPool is provided, use nodeDiscovery
	            return yield nodeDiscovery(createEndpointObjects(ensureArray(settings.directoryNodeUrlPool)), settings.failOverConfig, settings.blockchainRid, settings.blockchainIid);
	        }
	        else if (typeof settings.nodeUrlPool === "string") {
	            // If nodeUrlPool is a string, convert it to an array
	            return [settings.nodeUrlPool];
	        }
	        else if (Array.isArray(settings.nodeUrlPool)) {
	            // If nodeUrlPool is already an array, use it as-is
	            return settings.nodeUrlPool;
	        }
	        else {
	            // Default to an empty array if no valid configuration is provided
	            return [];
	        }
	    });
	}
	const defaultFailoverConfig = {
	    strategy: exports.FailoverStrategy.AbortOnError,
	    attemptsPerEndpoint: 3,
	    attemptInterval: 500,
	    unreachableDuration: 30000,
	};
	const createEndpointObjects = (endpointPoolUrls) => {
	    const endpoints = endpointPoolUrls.map((endpointUrl) => {
	        return { url: endpointUrl, whenAvailable: 0 };
	    });
	    return endpoints;
	};
	const getUrlsFromEndpoints = (endpointPool) => {
	    return endpointPool.map((endpoint) => endpoint.url);
	};

	var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function getBlockchainRidFromIid(endpointPool, chainId, failOverConfig = defaultFailoverConfig) {
	    return __awaiter$5(this, void 0, void 0, function* () {
	        const config = {
	            endpointPool,
	            statusPollInterval: 500,
	            statusPollCount: 20,
	            failoverStrategy: failOverConfig.strategy || defaultFailoverConfig.strategy,
	            attemptsPerEndpoint: failOverConfig.attemptsPerEndpoint ||
	                defaultFailoverConfig.attemptsPerEndpoint,
	            attemptInterval: failOverConfig.attemptInterval || defaultFailoverConfig.attemptInterval,
	            unreachableDuration: failOverConfig.unreachableDuration ||
	                defaultFailoverConfig.unreachableDuration,
	        };
	        const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `/brid/iid_${chainId}`, config);
	        if (error) {
	            throw new GetBridFromChainException(chainId, error.message);
	        }
	        else if (statusCode !== 200) {
	            throw new GetBridFromChainException(chainId, rspBody);
	        }
	        return rspBody;
	    });
	}
	function requestWithRetry(method, path, config, postObject) {
	    return __awaiter$5(this, void 0, void 0, function* () {
	        switch (config.failoverStrategy) {
	            case exports.FailoverStrategy.AbortOnError:
	                return yield abortOnError({ method, path, config, postObject });
	            case exports.FailoverStrategy.TryNextOnError:
	                return yield tryNextOnError({ method, path, config, postObject });
	            case exports.FailoverStrategy.SingleEndpoint:
	                return yield singleEndpoint({ method, path, config, postObject });
	        }
	    });
	}
	function nextEndpoint(endpointPool) {
	    return endpointPool[Math.floor(Math.random() * endpointPool.length)];
	}
	const shuffle = (array) => {
	    const shuffledArray = [...array];
	    for (let i = shuffledArray.length - 1; i > 0; i--) {
	        const j = Math.floor(Math.random() * (i + 1));
	        [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
	    }
	    return shuffledArray;
	};
	const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
	function convertToPrintable(responseObject) {
	    if (typeof responseObject === "bigint") {
	        return `${responseObject}n`;
	    }
	    else if (typeof responseObject === "object") {
	        return JSON.stringify(responseObject, (key, value) => typeof value === "bigint" ? `${value}n` : value);
	    }
	    else {
	        return responseObject;
	    }
	}
	function filterReachableEndpoint(endpointPool) {
	    return endpointPool.filter((endpoint) => isReachable(endpoint));
	}
	function isReachable(endpoint) {
	    return new Date().getTime() > endpoint.whenAvailable;
	}
	const bftMajority = (n) => n - (n - 1) / 3;
	const setEndpointAsReachable = (endpointPool) => {
	    endpointPool.forEach((endpoint) => {
	        endpoint.whenAvailable = 0;
	    });
	};
	const setUnavailable = (endpoint, unreachableDuration) => {
	    endpoint.whenAvailable = new Date().getTime() + unreachableDuration;
	};

	var restclientutil = /*#__PURE__*/Object.freeze({
		__proto__: null,
		bftMajority: bftMajority,
		convertToPrintable: convertToPrintable,
		filterReachableEndpoint: filterReachableEndpoint,
		getBlockchainRidFromIid: getBlockchainRidFromIid,
		isReachable: isReachable,
		nextEndpoint: nextEndpoint,
		requestWithRetry: requestWithRetry,
		setEndpointAsReachable: setEndpointAsReachable,
		setUnavailable: setUnavailable,
		shuffle: shuffle,
		sleep: sleep
	});

	var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function createRestClient(endpointPool, blockchainRid, maxSockets = 10, pollingInterval = 500, failOverConfig, unreachableDuration = 5000) {
	    validateInput(endpointPool, failOverConfig !== null && failOverConfig !== void 0 ? failOverConfig : {});
	    return {
	        config: {
	            endpointPool: createEndpointObjects(endpointPool),
	            pool: { maxSockets },
	            pollingInterval,
	            failoverStrategy: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.strategy) || exports.FailoverStrategy.AbortOnError,
	            attemptsPerEndpoint: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptsPerEndpoint) || 3,
	            attemptInterval: (failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptInterval) || 500,
	            unreachableDuration: unreachableDuration,
	        },
	        getTransaction: function (txRID, callback) {
	            return __awaiter$4(this, void 0, void 0, function* () {
	                if (!isTxRidValid(txRID)) {
	                    callback(new InvalidTxRidException(txRID), null);
	                }
	                else {
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${blockchainRid}/${txRID.toString("hex")}`, this.config);
	                    handleGetResponse(error, statusCode, statusCode === 200 ? toBuffer$3(rspBody.tx) : rspBody, callback);
	                }
	            });
	        },
	        postTransaction: function (serializedTransaction, callback) {
	            return __awaiter$4(this, void 0, void 0, function* () {
	                if (!require$$0$3.Buffer.isBuffer(serializedTransaction)) {
	                    throw new SerializedTransactionFormatException();
	                }
	                const transactionObject = {
	                    tx: serializedTransaction.toString("hex"),
	                };
	                const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `tx/${blockchainRid}`, this.config, transactionObject);
	                handlePostResponse(error, statusCode, rspBody, callback);
	            });
	        },
	        status: function (txRID, callback) {
	            return __awaiter$4(this, void 0, void 0, function* () {
	                if (!isTxRidValid(txRID)) {
	                    callback(new InvalidTxRidException(txRID), null);
	                }
	                else {
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.GET, `tx/${blockchainRid}/${txRID.toString("hex")}/status`, this.config);
	                    handleGetResponse(error, statusCode, rspBody, callback);
	                }
	            });
	        },
	        query: function (nameOrQueryObject, queryArguments) {
	            return __awaiter$4(this, void 0, void 0, function* () {
	                // eslint-disable-next-line no-async-promise-executor
	                return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
	                    const callback = (error, result) => {
	                        if (error) {
	                            reject(error);
	                        }
	                        else {
	                            resolve(result);
	                        }
	                    };
	                    const { error, statusCode, rspBody } = yield requestWithRetry(Method.POST, `query_gtv/${blockchainRid}`, this.config, encodeValue(toQueryObjectGTV(nameOrQueryObject, queryArguments)));
	                    handlePostResponse(error, statusCode, rspBody, callback);
	                }));
	            });
	        },
	        waitConfirmation(txRID) {
	            return new Promise((resolve, reject) => {
	                this.status(txRID, (error$1, result) => {
	                    if (error$1) {
	                        reject(error$1);
	                    }
	                    else {
	                        const status = result.status;
	                        switch (status) {
	                            case ResponseStatus.Confirmed:
	                                resolve(null);
	                                break;
	                            case ResponseStatus.Rejected:
	                                reject(new TxRejectedError(result.rejectReason));
	                                break;
	                            case ResponseStatus.Unknown:
	                                reject(new LostMessageError());
	                                break;
	                            case ResponseStatus.Waiting:
	                                setTimeout(() => this.waitConfirmation(txRID).then(resolve, reject), this.config.pollingInterval);
	                                break;
	                            default:
	                                error(status);
	                                reject(new UnexpectedResponseError());
	                        }
	                    }
	                });
	            });
	        },
	        postAndWaitConfirmation(serializedTransaction, txRID, validate) {
	            if (validate === true) {
	                return Promise.reject("Automatic validation is not yet implemented");
	            }
	            return new Promise((resolve, reject) => {
	                this.postTransaction(serializedTransaction, (error) => {
	                    if (error)
	                        reject(error);
	                    else {
	                        setTimeout(() => this.waitConfirmation(txRID).then(resolve, reject), 1011);
	                    }
	                });
	            });
	        },
	        getEndpointPool() {
	            return getUrlsFromEndpoints(this.config.endpointPool);
	        },
	    };
	}
	function validateInput(endpointPool, failOverConfig) {
	    if (!endpointPool.length) {
	        throw new EmptyListOfUrlsException();
	    }
	    if ((failOverConfig === null || failOverConfig === void 0 ? void 0 : failOverConfig.attemptsPerEndpoint) &&
	        failOverConfig.attemptsPerEndpoint < 1) {
	        debug("Attempts can not be 0 or below, setting it to 1");
	        failOverConfig.attemptsPerEndpoint = 1;
	    }
	}
	/**
	 * @param error response error
	 * @param statusCode response status code
	 * @param responseObject the responsebody from the server
	 * @param callback the callback function to propagate the error and response back to the caller
	 */
	function handleGetResponse(error$1, statusCode, responseObject, callback) {
	    try {
	        const responseObjectPrintable = convertToPrintable(responseObject);
	        debug(`error: ${error$1}, status code: ${statusCode}, response body: ${responseObjectPrintable}`);
	        if (error$1) {
	            callback(error$1, null);
	        }
	        else if (statusCode !== 200) {
	            callback(new UnexpectedStatusError(statusCode !== null && statusCode !== void 0 ? statusCode : 400, responseObjectPrintable), null);
	        }
	        else {
	            callback(null, responseObject);
	        }
	    }
	    catch (error$1) {
	        error(`restclient.handleGetResponse(): Failed to call the callback function. ${error$1}`);
	    }
	}
	/**
	 * @param error response error
	 * @param statusCode response status code
	 * @param responseObject the responsebody from the server
	 * @param callback the callback function to propagate the error and response back to the caller
	 */
	function handlePostResponse(error$1, statusCode, responseObject, callback) {
	    const responseObjectPrintable = convertToPrintable(responseObject);
	    debug(`error: ${error$1}, status code: ${statusCode}, response body: ${responseObjectPrintable}`);
	    try {
	        if (error$1) {
	            error(`In restclient post(). ${error$1}`);
	            callback(error$1, null);
	        }
	        else if (statusCode != 200) {
	            let errorMessage = `Unexpected status code from server. Code: ${statusCode}.`;
	            if (responseObjectPrintable) {
	                errorMessage += ` Message: ${responseObjectPrintable}.`;
	            }
	            error(errorMessage);
	            callback(new UnexpectedStatusError(statusCode !== null && statusCode !== void 0 ? statusCode : 400, responseObjectPrintable), responseObject);
	        }
	        else {
	            info(`Calling responseCallback with responseObject: ${responseObjectPrintable}`);
	            callback(null, responseObject);
	        }
	    }
	    catch (error$1) {
	        error(`restclient.handlePostResponse(): Failed to call callback function ${error$1}`);
	    }
	}

	var restclient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRestClient: createRestClient,
		handleGetResponse: handleGetResponse,
		handlePostResponse: handlePostResponse
	});

	var internalNodePrefix = require$$0$3.Buffer.alloc(1, 0);
	var leafPrefix = require$$0$3.Buffer.alloc(1, 1);
	var nonExistingNodeHash = require$$0$3.Buffer.alloc(32);
	function calculateRoot(hashes, depth, leafDepth) {
	    var numTransactions = hashes.length;
	    if (numTransactions === 0) {
	        return require$$0$3.Buffer.alloc(32);
	    }
	    if (depth === undefined) {
	        depth = 0;
	    }
	    if (!leafDepth) {
	        leafDepth = Math.ceil(Math.log2(numTransactions));
	    }
	    if (depth === leafDepth) {
	        return hashes[0];
	    }
	    var maxLeavesPerChild = Math.pow(2, leafDepth - depth - 1);
	    var prefix = depth === leafDepth - 1 ? leafPrefix : internalNodePrefix;
	    if (numTransactions <= maxLeavesPerChild) {
	        var left = calculateRoot(hashes, depth + 1, leafDepth);
	        return hashConcat([prefix, left, nonExistingNodeHash]);
	    }
	    var left = calculateRoot(hashes.slice(0, maxLeavesPerChild), depth + 1, leafDepth);
	    var right = calculateRoot(hashes.slice(maxLeavesPerChild), depth + 1, leafDepth);
	    return hashConcat([prefix, left, prefix, right]);
	}
	function internalMerklePath(hashes, targetIndex, depth, leafDepth) {
	    var numTransactions = hashes.length;
	    if (depth === leafDepth) {
	        return [];
	    }
	    var maxLeavesPerChild = Math.pow(2, leafDepth - depth - 1);
	    if (numTransactions <= maxLeavesPerChild) {
	        var path = internalMerklePath(hashes, targetIndex, depth + 1, leafDepth);
	        path.push({ side: 1, hash: nonExistingNodeHash });
	        return path;
	    }
	    if (targetIndex < maxLeavesPerChild) {
	        var path = internalMerklePath(hashes.slice(0, maxLeavesPerChild), targetIndex, depth + 1, leafDepth);
	        var right = calculateRoot(hashes.slice(maxLeavesPerChild), depth + 1, leafDepth);
	        path.push({ side: 1, hash: right });
	    }
	    else {
	        var left = calculateRoot(hashes.slice(0, maxLeavesPerChild), depth + 1, leafDepth);
	        var path = internalMerklePath(hashes.slice(maxLeavesPerChild), targetIndex - maxLeavesPerChild, depth + 1, leafDepth);
	        path.push({ side: 0, hash: left });
	    }
	    return path;
	}
	/*
	 * a path looks like this:
	 * {merklePath: [{side: <0|1>, hash: <hash buffer depth n-1>},
	 *               {side: <0|1>, hash: <hash buffer depth n-2>},
	 *               ...
	 *               {side: <0|1>, hash: <hash buffer depth 1>}]}
	 */
	function merklePath(hashes, target) {
	    if (!hashes || hashes.length == 0) {
	        throw new Error("Cannot make merkle path from empty transaction set");
	    }
	    var index = -1;
	    for (var i = 0; i < hashes.length; i++) {
	        if (hashes[i].equals(target)) {
	            index = i;
	            break;
	        }
	    }
	    if (index === -1) {
	        throw new Error("Target is not in list of hashes");
	    }
	    var leafDepth = Math.ceil(Math.log2(hashes.length));
	    var path = internalMerklePath(hashes, index, 0, leafDepth);
	    return path;
	}
	/**
	 *
	 * @param path The merkle path to validate.
	 * Format [{side: <0|1>, hash: <hash buffer depth n-1>},
	 *         {side: <0|1>, hash: <hash buffer depth n-2>},
	 *         ...,
	 *         {side: <0|1>, hash: <hash buffer depth 1>}]

	 * @param target the leaf hash that the path proves belongs in the merkleRoot
	 * @param merkleRoot The merkle root that supposedly contains the target via the supplied path.
	 * The merkle root is typically taken from a block header.
	 */
	function validateMerklePath(path, target, merkleRoot) {
	    let currentHash = target;
	    for (let i = 0; i < path.length; i++) {
	        const item = path[i];
	        const prefix = (i === 0) ? require$$0$3.Buffer.from([1]) : require$$0$3.Buffer.from([0]);
	        if (item.side === 0) {
	            currentHash = hashConcat([prefix, item.hash, prefix, currentHash]);
	        }
	        else {
	            if (item.hash.equals(nonExistingNodeHash)) {
	                currentHash = hashConcat([prefix, currentHash, nonExistingNodeHash]);
	            }
	            else {
	                currentHash = hashConcat([prefix, currentHash, prefix, item.hash]);
	            }
	        }
	    }
	    return merkleRoot.equals(currentHash);
	}

	var merkleHelper = /*#__PURE__*/Object.freeze({
		__proto__: null,
		calculateRoot: calculateRoot,
		merklePath: merklePath,
		validateMerklePath: validateMerklePath
	});

	var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	/**
	 * @deprecated Use the function createClient instead.
	 * Provides postchain clients that can be used to communicate with dapps within the chromia network
	 * @param chain0BRID brid of chain0
	 * @param rest rest client configured to node running chain0
	 */
	function chromiaClientProvider(chain0BRID, rest) {
	    const chain0Client = createClient$1(rest, chain0BRID, []);
	    return {
	        blockchainConnection: function (dappBRID) {
	            return __awaiter$3(this, void 0, void 0, function* () {
	                const queryObject = {
	                    type: "cm_get_blockchain_api_urls",
	                    blockchain_rid: dappBRID,
	                };
	                const baseUrls = yield chain0Client.query(queryObject);
	                if (!baseUrls.length) {
	                    throw new BlockchainUrlUndefinedException(dappBRID);
	                }
	                return createRestClient(baseUrls, dappBRID);
	            });
	        },
	    };
	}

	var chromiaClientProvider$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		chromiaClientProvider: chromiaClientProvider
	});

	var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function createStubClient() {
	    return __awaiter$2(this, void 0, void 0, function* () {
	        return {
	            config: {
	                endpointPool: [],
	                blockchainRid: "0000000000000000000000000000000000000000000000000000000000000000",
	                statusPollInterval: 5000,
	                statusPollCount: 5,
	                failoverStrategy: exports.FailoverStrategy.AbortOnError,
	                attemptsPerEndpoint: 3,
	                attemptInterval: 5000,
	                unreachableDuration: 30000,
	            },
	            query() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("query rejected");
	                });
	            },
	            signTransaction() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("signTransaction rejected");
	                });
	            },
	            sendTransaction() {
	                return new Web3PromiEvent((_resolve, reject) => reject("sendTransaction rejected"));
	            },
	            signAndSendUniqueTransaction() {
	                return new Web3PromiEvent((_resolve, reject) => reject("signAndSendUniqueTransaction rejected"));
	            },
	            getTransaction() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getTransaction rejected");
	                });
	            },
	            getTransactionStatus() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getTransactionStatus rejected");
	                });
	            },
	            addNop() {
	                throw new Error("addNop error");
	            },
	            getTransactionRid() {
	                throw new Error("getTransactionRid error");
	            },
	            getTransactionsInfo() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getTransactionsInfo rejected");
	                });
	            },
	            getTransactionInfo() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getTransactionInfo rejected");
	                });
	            },
	            getTransactionCount() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getTransactionCount rejected");
	                });
	            },
	            getBlockInfo() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getBlockInfo rejected");
	                });
	            },
	            getLatestBlock() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getLatestBlock rejected");
	                });
	            },
	            getBlocksInfo() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getBlocksInfo rejected");
	                });
	            },
	            encodeTransaction() {
	                throw new Error("encodeTransaction error");
	            },
	            decodeTransactionToGtx() {
	                throw new Error("decodeTransactionToGtx error");
	            },
	            getClientNodeUrlPool() {
	                return [];
	            },
	            getConfirmationProof() {
	                return __awaiter$2(this, void 0, void 0, function* () {
	                    return Promise.reject("getConfirmationProof rejected");
	                });
	            },
	        };
	    });
	}

	class MissingTransactionProof extends Error {
	    constructor(proofHash, fetchedTxHash) {
	        super(`Unable to verify source transaction proof,transaction hash in proof ${toString(proofHash)} does not match hash from fetched transaction ${toString(fetchedTxHash)}`);
	    }
	}
	class DifferentNumberOfSignersException extends Error {
	    constructor(length, comparableLength) {
	        super(`Transaction signatures amount ${length} do not match expected amount of signers ${comparableLength}`);
	    }
	}
	class SignatureException extends Error {
	    constructor(signer) {
	        super(`Expected signer ${toString(signer)} has not signed source transaction`);
	    }
	}
	class ProofRidException extends Error {
	    constructor() {
	        super("Unable to verify source transaction proof, got a different transaction from query than we asked for");
	    }
	}
	class SystemChainException extends Error {
	    constructor(errorMessage) {
	        super(`Query to system chain failed with error: ${errorMessage}`);
	    }
	}
	class ConfirmationProofException extends Error {
	    constructor(transactionRid) {
	        super(`Unable to fetch confirmation proof for transaction RID: ${toString(transactionRid)}.`);
	    }
	}
	class BlockAnchoringException extends Error {
	    constructor() {
	        super(`Block is not present in cluster anchoring chain`);
	    }
	}

	var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	function getClusterOfBlockchain(client, blockchainRid) {
	    return __awaiter$1(this, void 0, void 0, function* () {
	        try {
	            const clusterName = yield client.query({
	                name: "cm_get_blockchain_cluster",
	                args: { brid: blockchainRid },
	            });
	            return clusterName;
	        }
	        catch (error) {
	            throw new SystemChainException(error.message);
	        }
	    });
	}
	function getClusterInfo(client, name) {
	    return __awaiter$1(this, void 0, void 0, function* () {
	        try {
	            const clusterInfo = yield client.query({
	                name: "cm_get_cluster_info",
	                args: { name },
	            });
	            return clusterInfo;
	        }
	        catch (error) {
	            throw new SystemChainException(error.message);
	        }
	    });
	}
	function getAnchoringTransactionForBlockRid(client, blockchainRid, blockRid) {
	    return __awaiter$1(this, void 0, void 0, function* () {
	        try {
	            const anchoringTxForBlockRid = yield client.query({
	                name: "get_anchoring_transaction_for_block_rid",
	                args: { blockchain_rid: blockchainRid, block_rid: blockRid },
	            });
	            return convertToAnchoringTransaction(anchoringTxForBlockRid);
	        }
	        catch (error) {
	            throw new SystemChainException(error.message);
	        }
	    });
	}
	function convertToAnchoringTransaction(responseTx) {
	    const { tx_rid, tx_data, tx_op_index } = responseTx;
	    return {
	        txRid: tx_rid,
	        txData: tx_data,
	        txOpIndex: tx_op_index,
	    };
	}
	function calculateBlockRID(decodedTxProof) {
	    const sourceBlockHeader = decodedTxProof.blockHeader;
	    if (!sourceBlockHeader) {
	        throw new Error("Failed to get blockHeader from confirmation proof");
	    }
	    const decodeSourceBlockRid = decodeValue(sourceBlockHeader);
	    return gtvHash(decodeSourceBlockRid);
	}
	// fetch tx from txRID and verifies with secp256k1.ecdsaVerify that txRID and signer creates signatures that are on the blockchain transaction
	function fetchAndVerifyTransaction(sourceClient, txToProveRID, proofHash, txToProveSigners) {
	    var _a, _b, _c;
	    return __awaiter$1(this, void 0, void 0, function* () {
	        const rawTx = yield sourceClient.getTransaction(txToProveRID);
	        const txGtv = decodeValue(rawTx);
	        const fetchedTxHash = gtvHash(txGtv);
	        if (require$$0$3.Buffer.compare(fetchedTxHash, proofHash)) {
	            // We received another hash for tx RID than what was included in proof
	            // Possibly rouge or faulty node(s). Anyway, we need to give up.
	            throw new MissingTransactionProof(proofHash, fetchedTxHash);
	        }
	        const fetchedTx = rawGtvToGtx(txGtv);
	        if (txToProveSigners.length != ((_a = fetchedTx.signatures) === null || _a === void 0 ? void 0 : _a.length)) {
	            throw new DifferentNumberOfSignersException((_c = (_b = fetchedTx.signatures) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, txToProveSigners.length);
	        }
	        const txRID = getDigestToSign(fetchedTx);
	        if (require$$0$3.Buffer.compare(txRID, txToProveRID)) {
	            throw new ProofRidException();
	        }
	        for (const signer of txToProveSigners) {
	            let hasSignature = false;
	            for (const signature of fetchedTx.signatures) {
	                // verify that txRID (hash of gtxBody) signed by signers equals the signatures from network
	                if (checkDigestSignature(txRID, signer, signature)) {
	                    hasSignature = true;
	                    break;
	                }
	            }
	            if (!hasSignature)
	                throw new SignatureException(signer);
	        }
	        return { verifiedTx: fetchedTx, verifiedTxHash: fetchedTxHash };
	    });
	}
	function composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, anchoringTx, anchoringProof, isNetwork = true) {
	    let operationArgs;
	    operationArgs = {
	        sourceBlockchainRid: toBuffer$3(sourceBlockchainRid),
	        transactionHash: verifiedTxHash,
	        transactionProof: encodeValue(txProof),
	    };
	    if (isNetwork) {
	        operationArgs = Object.assign(Object.assign({}, operationArgs), { transactionData: anchoringTx === null || anchoringTx === void 0 ? void 0 : anchoringTx.txData, transactionIndex: anchoringTx === null || anchoringTx === void 0 ? void 0 : anchoringTx.txOpIndex, anchoringProof: anchoringProof && encodeValue(anchoringProof) });
	    }
	    return {
	        operations: [
	            {
	                name: "iccf_proof",
	                args: Object.values(operationArgs),
	            },
	        ],
	        signers: iccfTxSigners,
	    };
	}

	var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	/**
	 * Creates an ICCF (Inter-Chain Communication Framework) proof transaction.
	 * This function generates a proof that a specific transaction has occurred on the source blockchain
	 * and constructs an ICCF proof transaction that can be posted to the target blockchain.
	 *
	 * @param {IClient} client - The client configured to communicate with the management chain.
	 * @param {Buffer} txToProveRid - The RID of the transaction to be proven.
	 * @param {Buffer} txToProveHash - The hash of the transaction to be proven.
	 * @param {PubKey[]} txToProveSigners - An array of public keys representing signers of the transaction to be proven.
	 * @param {string} sourceBlockchainRid - The RID of the source blockchain.
	 * @param {string} targetBlockchainRid - The RID of the target blockchain.
	 * @param {PubKey[]} iccfTxSigners - An array of public keys representing signers of the ICCF proof transaction (optional, default: []).
	 * @param {boolean} forceIntraNetworkIccfOperation - Whether to force the ICCF operation to be performed within the same network (optional, default: false).
	 * @returns {Promise<IccfProof>} A promise that resolves to an ICCF proof object containing the ICCF proof transaction.
	 */
	function createIccfProofTx(client, txToProveRid, txToProveHash, txToProveSigners, sourceBlockchainRid, targetBlockchainRid, iccfTxSigners = [], forceIntraNetworkIccfOperation = false) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const clientConfiguredToSource = yield createClient({
	            directoryNodeUrlPool: getUrlsFromEndpoints(client.config.endpointPool),
	            blockchainRid: sourceBlockchainRid,
	        });
	        const txProof = yield clientConfiguredToSource.getConfirmationProof(txToProveRid);
	        if (!txProof || !txProof.hash) {
	            throw new ConfirmationProofException(txToProveRid);
	        }
	        const proofHash = txProof.hash;
	        const { verifiedTx, verifiedTxHash } = !txToProveHash.equals(proofHash)
	            ? yield fetchAndVerifyTransaction(clientConfiguredToSource, txToProveRid, proofHash, txToProveSigners)
	            : { verifiedTx: null, verifiedTxHash: txToProveHash };
	        const sourceCluster = yield getClusterOfBlockchain(client, toBuffer$3(sourceBlockchainRid));
	        const targetCluster = yield getClusterOfBlockchain(client, toBuffer$3(targetBlockchainRid));
	        if (!forceIntraNetworkIccfOperation && sourceCluster === targetCluster) {
	            // intra-cluster
	            const intraClusterProofTx = composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, undefined, undefined, false);
	            return { iccfTx: intraClusterProofTx };
	        }
	        else {
	            // intra-network
	            const anchoringClient = yield getAnchoringClient(client, sourceBlockchainRid, sourceCluster);
	            const anchoringTx = yield getBlockAnchoringTransaction(clientConfiguredToSource, anchoringClient, undefined, txProof);
	            const anchoringProof = yield anchoringClient.getConfirmationProof(anchoringTx.txRid);
	            const intraNetworkProofTx = composeProofTransactionObject(sourceBlockchainRid, verifiedTxHash, txProof, iccfTxSigners, anchoringTx, anchoringProof);
	            return { iccfTx: intraNetworkProofTx, verifiedTx };
	        }
	    });
	}
	/**
	 * Checks whether a given transaction is included in the cluster anchoring chain and returns the
	 * block anchoring transaction. If `txProof` is not provided, it fetches the confirmation proof
	 * using the `sourceClient`.
	 *
	 * @param sourceClient - A client configured to the blockchain where the trasnaction were made.
	 * @param anchoringClient - The client responsible for querying the anchoring blockchain.
	 * @param txRid - The transaction RID to check for anchoring.
	 * @param txProof - (Optional) The transaction proof for the specified `txRid`.
	 * @returns A Promise that resolves to the anchored transaction response object.
	 */
	function getBlockAnchoringTransaction(sourceClient, anchoringClient, txRid, txProof) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!txRid && !txProof) {
	            throw Error("Missing a txRid or TxProof");
	        }
	        const confirmationProof = txProof !== null && txProof !== void 0 ? txProof : (txRid && (yield sourceClient.getConfirmationProof(txRid)));
	        if (!confirmationProof) {
	            throw Error("Confirmation proof not found");
	        }
	        const blockRid = calculateBlockRID(confirmationProof);
	        const blockchainRid = sourceClient.config.blockchainRid;
	        const anchoringTxResponse = yield getAnchoringTransactionForBlockRid(anchoringClient, toBuffer$3(blockchainRid), blockRid);
	        if (!anchoringTxResponse) {
	            throw new BlockAnchoringException();
	        }
	        return anchoringTxResponse;
	    });
	}
	/**
	 * Checks whether a given transaction is included in the anchoring blockchain.
	 *
	 * @param sourceClient - A client configured to the blockchain where the trasnaction were made.
	 * @param anchoringClient - The client responsible for querying the anchoring blockchain.
	 * @param txRid - The transaction RID to check for anchoring.
	 * @param txProof - (Optional) The transaction proof for the specified `txRid`.
	 * @returns A Promise that resolves to `true` if the transaction is anchored, `false` otherwise.
	 */
	function isBlockAnchored(sourceClient, anchoringClient, txRid, txProof) {
	    return __awaiter(this, void 0, void 0, function* () {
	        return !!(yield getBlockAnchoringTransaction(sourceClient, anchoringClient, txRid, txProof));
	    });
	}
	/**
	 * Gets a client configured for the cluster anchoring blockchain of a cluster. Takes a specific
	 * cluster name or blockchain RID to determine the cluster.
	 * @param client - The client configured to communicate with the management chain.
	 * @param dappBlockchainRid - (Optional) The RID of a blockchain which anchoring wants to be checked.
	 * @param cluster - (Optional) The cluster of interest.
	 * @returns A Promise that resolves to the client configured to a cluster anchoring chain.
	 */
	function getAnchoringClient(client, dappBlockchainRid, cluster) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!dappBlockchainRid && !cluster) {
	            throw Error("Missing a dapp blockchainRid or cluster name");
	        }
	        const sourceCluster = cluster !== null && cluster !== void 0 ? cluster : (dappBlockchainRid &&
	            (yield getClusterOfBlockchain(client, toBuffer$3(dappBlockchainRid))));
	        if (!sourceCluster) {
	            throw Error("No cluster could be found");
	        }
	        const sourceClusterInfo = yield getClusterInfo(client, sourceCluster);
	        if (!sourceClusterInfo || !sourceClusterInfo.anchoring_chain) {
	            throw Error("Cluster info could not be found");
	        }
	        const clientConfiguredToAnchoringchain = yield createClient({
	            directoryNodeUrlPool: getUrlsFromEndpoints(client.config.endpointPool),
	            blockchainRid: toString(sourceClusterInfo.anchoring_chain),
	        });
	        return clientConfiguredToAnchoringchain;
	    });
	}

	/**
	 * Calculates and returns the transaction RID, i.e., the merkle root hash of the transaction.
	 * @param transaction The transaction in format of RawGtxBody
	 *
	 */
	const calculateTransactionRid = (transaction) => {
	    try {
	        return getDigestToSignFromRawGtxBody(transaction);
	    }
	    catch (e) {
	        throw new GetTransactionRidException(e);
	    }
	};

	/**
	 *
	 * Encodes the gtx using ASN.1.
	 * @returns the gtx encoded
	 */
	const encodeTransaction = (gtx$1) => {
	    return serialize(gtx$1);
	};

	/**
	 * Decodes the transaction using ASN.1.
	 * @returns the transaction decoded in GTX format
	 */
	const decodeTransactionToGtx = (encodedTransaction) => {
	    const gtx$1 = deserialize(encodedTransaction);
	    debug(`Output from deserializing a raw transaction: ${JSON.stringify(gtx$1)}`);
	    return gtx$1;
	};

	exports.AlreadySignedTransactionException = AlreadySignedTransactionException;
	exports.BlockAnchoringException = BlockAnchoringException;
	exports.BlockchainUrlUndefinedException = BlockchainUrlUndefinedException;
	exports.ConfirmationProofException = ConfirmationProofException;
	exports.CustomError = CustomError;
	exports.DifferentNumberOfSignersException = DifferentNumberOfSignersException;
	exports.DirectoryNodeUrlPoolException = DirectoryNodeUrlPoolException;
	exports.EmptyListOfUrlsException = EmptyListOfUrlsException;
	exports.GetBridFromChainException = GetBridFromChainException;
	exports.GetTransactionRidException = GetTransactionRidException;
	exports.InvalidBlockchainRIDException = InvalidBlockchainRIDException;
	exports.InvalidTransactionFormatException = InvalidTransactionFormatException;
	exports.InvalidTxRidException = InvalidTxRidException;
	exports.LostMessageError = LostMessageError;
	exports.MissingBlockchainIdentifierError = MissingBlockchainIdentifierError;
	exports.MissingGtxException = MissingGtxException;
	exports.MissingNodeUrlError = MissingNodeUrlError;
	exports.MissingPrivKeyArgumentException = MissingPrivKeyArgumentException;
	exports.MissingPubKeyError = MissingPubKeyError;
	exports.MissingSignerException = MissingSignerException;
	exports.MissingTransactionProof = MissingTransactionProof;
	exports.NumberOfSignersAndSignaturesException = NumberOfSignersAndSignaturesException;
	exports.PrivKeyFormatException = PrivKeyFormatException;
	exports.ProofRidException = ProofRidException;
	exports.SerializedTransactionFormatException = SerializedTransactionFormatException;
	exports.SignatureException = SignatureException;
	exports.SystemChainException = SystemChainException;
	exports.TxRejectedError = TxRejectedError;
	exports.UnexpectedArgumentTypeError = UnexpectedArgumentTypeError;
	exports.UnexpectedResponseError = UnexpectedResponseError;
	exports.UnexpectedStatusError = UnexpectedStatusError;
	exports.Web3PromiEvent = Web3PromiEvent;
	exports.calculateTransactionRid = calculateTransactionRid;
	exports.chromiaClient = chromiaClientProvider$1;
	exports.convertToRellOperation = convertToRellOperation;
	exports.createClient = createClient;
	exports.createIccfProofTx = createIccfProofTx;
	exports.createStubClient = createStubClient;
	exports.decodeTransactionToGtx = decodeTransactionToGtx;
	exports.encodeTransaction = encodeTransaction;
	exports.encryption = encryption$1;
	exports.formatter = formatter;
	exports.getAnchoringClient = getAnchoringClient;
	exports.getBlockAnchoringTransaction = getBlockAnchoringTransaction;
	exports.getDigestToSignFromRawGtxBody = getDigestToSignFromRawGtxBody;
	exports.gtv = index;
	exports.gtx = gtx;
	exports.gtxClient = gtxclient;
	exports.isBlockAnchored = isBlockAnchored;
	exports.logger = logger$1;
	exports.merkle = merkleHelper;
	exports.newSignatureProvider = newSignatureProvider;
	exports.restClient = restclient;
	exports.restClientutil = restclientutil;

}));
//# sourceMappingURL=index.js.map
